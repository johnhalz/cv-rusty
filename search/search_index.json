{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CV Rusty","text":"<p>A <code>no_std</code> computer vision library written in Rust, designed for live computations, embedded systems, and high-performance image processing.</p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>no_std</code> Compatible: Core library works without the standard library (only requires <code>alloc</code>)</li> <li>Zero-copy Image Representation: Efficient three-channel matrix structure for RGB images</li> <li>Image I/O: Built-in support for reading and writing JPEG and PNG images with automatic format conversion (requires <code>std</code> feature)</li> <li>Format Support: Handles RGB24, Grayscale (L8), and CMYK32 JPEG formats; RGB, RGBA, Grayscale, and Grayscale+Alpha PNG formats</li> <li>Safe API: Bounds-checked pixel access with ergonomic error handling</li> <li>Embedded Ready: Perfect for resource-constrained environments and real-time systems</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#standard-library-default","title":"Standard Library (default)","text":"<p>For applications with <code>std</code> support and file I/O:</p> <pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"#no_std-environments","title":"<code>no_std</code> Environments","text":"<p>For embedded systems or <code>no_std</code> environments (requires <code>alloc</code>):</p> <pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"#feature-flags","title":"Feature Flags","text":"<ul> <li><code>std</code> (enabled by default): Enables standard library support, including file I/O operations</li> <li><code>alloc</code>: Enables heap allocation support (required for core functionality)</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#reading-and-writing-images-requires-std-feature","title":"Reading and Writing Images (requires <code>std</code> feature)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, write_jpeg, write_png};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read a JPEG file into a Matrix3\n    let image = read_jpeg(\"photo.jpg\")?;\n    println!(\"JPEG dimensions: {}x{}\", image.width(), image.height());\n\n    // Read a PNG file into a Matrix3\n    let image = read_png(\"photo.png\")?;\n    println!(\"PNG dimensions: {}x{}\", image.width(), image.height());\n\n    // Access pixel data\n    if let Some((r, g, b)) = image.get_pixel(100, 100) {\n        println!(\"Pixel at (100, 100): RGB({}, {}, {})\", r, g, b);\n    }\n\n    // Write as JPEG with quality setting (1-100)\n    write_jpeg(&amp;image, \"output.jpg\", 90)?;\n\n    // Write as PNG (lossless)\n    write_png(&amp;image, \"output.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"#working-with-matrix3-no_std-compatible","title":"Working with Matrix3 (<code>no_std</code> compatible)","text":"<pre><code>use cv_rusty::matrix::Matrix3;\n\n// Create a new 640x480 image filled with zeros\nlet mut image = Matrix3::zeros(640, 480);\n\n// Set a pixel value\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel at (10, 20)\n\n// Get a pixel value\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Access raw data\nlet raw_data = image.data();\nprintln!(\"Total bytes: {}\", raw_data.len());\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; {\n        println!(\"Successfully loaded {}x{} image\", image.width(), image.height());\n    }\n    Err(ImageError::Io(e)) =&gt; {\n        eprintln!(\"File I/O error: {}\", e);\n    }\n    Err(ImageError::JpegDecode(e)) =&gt; {\n        eprintln!(\"JPEG decoding error: {}\", e);\n    }\n    Err(ImageError::PngDecode(e)) =&gt; {\n        eprintln!(\"PNG decoding error: {}\", e);\n    }\n    Err(ImageError::JpegEncode(e)) =&gt; {\n        eprintln!(\"JPEG encoding error: {}\", e);\n    }\n    Err(ImageError::PngEncode(e)) =&gt; {\n        eprintln!(\"PNG encoding error: {}\", e);\n    }\n    Err(ImageError::UnsupportedFormat(e)) =&gt; {\n        eprintln!(\"Unsupported format: {}\", e);\n    }\n}\n</code></pre>"},{"location":"#no_std-embedded-usage","title":"<code>no_std</code> Embedded Usage","text":"<pre><code>#![no_std]\n\nextern crate alloc;\nuse cv_rusty::Matrix3;\n\nfn process_image() {\n    // Create image data in memory\n    let mut image = Matrix3::zeros(320, 240);\n\n    // Process pixels (e.g., from a camera sensor)\n    for y in 0..240 {\n        for x in 0..320 {\n            // Set pixel from sensor data\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    // Send to display via SPI/I2C\n    let raw_data = image.data();\n    // ... send raw_data to hardware\n}\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#with-std-feature-file-io","title":"With <code>std</code> feature (file I/O)","text":"<p>Read and analyze a JPEG file:</p> <pre><code>cargo run --example read_jpeg_example path/to/your/image.jpg\n</code></pre> <p>Read and analyze a PNG file:</p> <pre><code>cargo run --example read_png_example path/to/your/image.png\n</code></pre> <p>Write images in JPEG and PNG formats:</p> <pre><code>cargo run --example write_image_example\n</code></pre> <p>Convert images between formats:</p> <pre><code>cargo run --example image_conversion path/to/your/image.jpg\n</code></pre>"},{"location":"#no_std-example","title":"<code>no_std</code> example","text":"<p>Demonstrate core functionality without file I/O:</p> <pre><code>cargo run --example no_std_example\n</code></pre> <p>Build for <code>no_std</code> environment:</p> <pre><code>cargo build --no-default-features\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":""},{"location":"#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix for representing RGB image data.</p> <p>Key Methods: - <code>new(width, height, data)</code> - Create from raw RGB data - <code>zeros(width, height)</code> - Create a zero-initialized matrix - <code>get_pixel(x, y)</code> - Get RGB values at a pixel location - <code>set_pixel(x, y, r, g, b)</code> - Set RGB values at a pixel location - <code>width()</code>, <code>height()</code>, <code>dimensions()</code> - Get matrix dimensions - <code>data()</code>, <code>data_mut()</code> - Access raw pixel data</p>"},{"location":"#ioread_jpegpath","title":"<code>io::read_jpeg(path)</code>","text":"<p>Reads a JPEG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB24 (24-bit color) - L8 (8-bit grayscale, converted to RGB) - CMYK32 (CMYK color space, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#ioread_pngpath","title":"<code>io::read_png(path)</code>","text":"<p>Reads a PNG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB (24-bit color) - RGBA (32-bit color with alpha, alpha channel stripped) - Grayscale (8-bit, converted to RGB) - Grayscale+Alpha (16-bit, alpha channel stripped, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#iowrite_jpegmatrix-path-quality","title":"<code>io::write_jpeg(matrix, path, quality)</code>","text":"<p>Writes a <code>Matrix3</code> as a JPEG image file.</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the JPEG file should be written - <code>quality</code> - JPEG quality (1-100, where 100 is best quality)</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_jpeg(&amp;image, \"output.jpg\", 90)?;\n</code></pre></p>"},{"location":"#iowrite_pngmatrix-path","title":"<code>io::write_png(matrix, path)</code>","text":"<p>Writes a <code>Matrix3</code> as a PNG image file (lossless compression).</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the PNG file should be written</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#embedded-systems","title":"Embedded Systems","text":"<ul> <li>Camera processing on microcontrollers</li> <li>Real-time video processing on FPGA/ASIC</li> <li>LCD/OLED display controllers</li> <li>Industrial vision systems</li> </ul>"},{"location":"#high-performance-applications","title":"High-Performance Applications","text":"<ul> <li>Real-time computer vision</li> <li>Video processing pipelines</li> <li>Live streaming applications</li> <li>Robotics and automation</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> <code>no_std</code> support</li> <li> JPEG image reading (with <code>std</code> feature)</li> <li> PNG image reading (with <code>std</code> feature)</li> <li> JPEG image writing (with <code>std</code> feature)</li> <li> PNG image writing (with <code>std</code> feature)</li> <li> Color space conversions (RGB \u2194 HSV, YUV)</li> <li> Basic image operations (resize, crop, rotate)</li> <li> Filtering and convolution</li> <li> Edge detection</li> <li> Feature detection</li> <li> SIMD optimizations</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is open source and available under the MIT License.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"architecture/","title":"CV Rusty Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>CV Rusty is a <code>no_std</code> compatible computer vision library written in Rust with a focus on performance, safety, and embedded systems support. The library is designed for live computations, real-time image processing applications, and resource-constrained environments.</p>"},{"location":"architecture/#project-structure","title":"Project Structure","text":"<pre><code>cv-rusty/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs          # Main library entry point\n\u2502   \u251c\u2500\u2500 matrix.rs       # Matrix data structures\n\u2502   \u2514\u2500\u2500 io.rs           # Image I/O operations\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 read_jpeg_example.rs\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"architecture/#module-design","title":"Module Design","text":""},{"location":"architecture/#librs","title":"<code>lib.rs</code>","text":"<p>The main library entry point configured for <code>no_std</code> compatibility. It uses feature flags to conditionally compile std-dependent code.</p> <p>Key Attributes: - <code>#![cfg_attr(not(feature = \"std\"), no_std)]</code> - Enables <code>no_std</code> when std feature is disabled - <code>extern crate alloc</code> - Required for heap allocations in <code>no_std</code> environments</p> <p>Public API: - <code>Matrix3</code> - Three-channel image matrix (always available) - <code>read_jpeg</code> - JPEG file reading function (only with <code>std</code> feature)</p>"},{"location":"architecture/#matrixrs","title":"<code>matrix.rs</code>","text":"<p>Contains the core data structure for representing multi-channel image data. This module is fully <code>no_std</code> compatible and only requires the <code>alloc</code> crate.</p> <p><code>no_std</code> Compatibility: - Uses <code>core::fmt</code> instead of <code>std::fmt</code> - Imports <code>Vec</code> from <code>alloc::vec::Vec</code> when <code>std</code> is not available - Imports <code>vec!</code> macro from <code>alloc::vec</code> for <code>no_std</code> environments</p>"},{"location":"architecture/#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix specifically designed for RGB image representation.</p> <p>Design Decisions: - Contiguous Memory Layout: Data is stored in a single <code>Vec&lt;u8&gt;</code> for cache efficiency - Interleaved Channels: RGB values are stored as <code>[R, G, B, R, G, B, ...]</code> for better spatial locality - Row-Major Order: Standard image representation order (y * width + x) - Bounds Checking: All pixel access methods return <code>Option</code> or <code>bool</code> to prevent panics</p> <p>Memory Layout: <pre><code>Pixel (0,0): [R, G, B] | Pixel (1,0): [R, G, B] | ... | Pixel (W-1,0): [R, G, B]\nPixel (0,1): [R, G, B] | Pixel (1,1): [R, G, B] | ... | Pixel (W-1,1): [R, G, B]\n...\nPixel (0,H-1): [R, G, B] | ... | Pixel (W-1,H-1): [R, G, B]\n</code></pre></p> <p>Index Calculation: <pre><code>let pixel_index = (y * width + x) * 3;\nlet r = data[pixel_index];\nlet g = data[pixel_index + 1];\nlet b = data[pixel_index + 2];\n</code></pre></p>"},{"location":"architecture/#iors","title":"<code>io.rs</code>","text":"<p>Handles image file I/O operations, currently supporting JPEG format. This module is only compiled when the <code>std</code> feature is enabled, as it requires file system access.</p> <p>Compilation Guard: - Only included when <code>#[cfg(feature = \"std\")]</code> is true - Requires <code>std::fs</code>, <code>std::io</code>, and <code>std::path</code></p>"},{"location":"architecture/#imageerror","title":"<code>ImageError</code>","text":"<p>Custom error type for image operations with variants: - <code>Io(io::Error)</code> - File system errors - <code>JpegDecode(String)</code> - JPEG decoding errors - <code>UnsupportedFormat(String)</code> - Unsupported pixel format errors</p>"},{"location":"architecture/#read_jpegpath","title":"<code>read_jpeg(path)</code>","text":"<p>Reads JPEG files and converts them to RGB <code>Matrix3</code>.</p> <p>Supported Input Formats: 1. RGB24 - Direct passthrough (most common) 2. L8 (Grayscale) - Converted by duplicating channel: <code>[G] -&gt; [G, G, G]</code> 3. CMYK32 - Converted using formula:    <pre><code>R = (1 - C) * (1 - K) * 255\nG = (1 - M) * (1 - K) * 255\nB = (1 - Y) * (1 - K) * 255\n</code></pre></p> <p>Processing Pipeline: 1. Open file with buffered reader 2. Create JPEG decoder 3. Decode image to raw pixels 4. Extract metadata (width, height, pixel format) 5. Convert to RGB if necessary 6. Construct <code>Matrix3</code> with RGB data</p>"},{"location":"architecture/#dependencies","title":"Dependencies","text":""},{"location":"architecture/#jpeg-decoder-v03","title":"<code>jpeg-decoder</code> (v0.3)","text":"<ul> <li>Purpose: JPEG image decoding</li> <li>Features: Supports multiple pixel formats, hardware acceleration</li> <li>License: MIT/Apache-2.0</li> <li>Availability: Optional, only included with <code>std</code> feature</li> <li>Note: This dependency requires <code>std</code>, so JPEG reading is not available in <code>no_std</code> environments</li> </ul>"},{"location":"architecture/#feature-flags","title":"Feature Flags","text":""},{"location":"architecture/#std-default","title":"<code>std</code> (default)","text":"<p>Enables standard library support, including: - File I/O operations (<code>io</code> module) - JPEG reading functionality - <code>std::error::Error</code> trait implementations</p>"},{"location":"architecture/#alloc","title":"<code>alloc</code>","text":"<p>Enables heap allocation support (required for core functionality): - <code>Vec&lt;u8&gt;</code> for storing pixel data - Dynamic memory allocation</p> <p>Feature Dependencies: <pre><code>[features]\ndefault = [\"std\"]\nstd = [\"jpeg-decoder\"]\nalloc = []\n</code></pre></p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":"<ol> <li><code>no_std</code> First: Core functionality works without standard library</li> <li>Zero-Copy When Possible: Minimize data copying during operations</li> <li>Memory Safety: Use Rust's type system to prevent buffer overflows</li> <li>Ergonomic API: Simple, intuitive interfaces for common operations</li> <li>Performance: Design for real-time processing applications</li> <li>Extensibility: Modular design allows easy addition of new formats and operations</li> <li>Embedded Ready: Suitable for microcontrollers and resource-constrained systems</li> </ol>"},{"location":"architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/#memory-layout","title":"Memory Layout","text":"<ul> <li>Contiguous allocation reduces cache misses</li> <li>Interleaved channels improve spatial locality for pixel operations</li> <li>Single allocation per image minimizes heap fragmentation</li> </ul>"},{"location":"architecture/#bounds-checking","title":"Bounds Checking","text":"<ul> <li>All pixel access is bounds-checked at compile time or returns <code>Option</code></li> <li>No unsafe code in current implementation</li> <li>Trade-off: slight overhead for safety guarantees</li> </ul>"},{"location":"architecture/#future-optimizations","title":"Future Optimizations","text":"<ul> <li>SIMD operations for bulk pixel processing</li> <li>Parallel processing with rayon for large images (with <code>std</code> feature)</li> <li>Memory pooling for repeated allocations</li> <li>Optional unsafe fast paths for performance-critical code</li> <li>Hardware accelerator support for embedded systems</li> <li>Zero-allocation operations where possible</li> </ul>"},{"location":"architecture/#no_std-support","title":"<code>no_std</code> Support","text":""},{"location":"architecture/#requirements","title":"Requirements","text":"<p>The core library (<code>Matrix3</code> and related operations) only requires: - <code>core</code> - Rust's core library (always available) - <code>alloc</code> - For heap allocations (<code>Vec</code>)</p>"},{"location":"architecture/#limitations-in-no_std","title":"Limitations in <code>no_std</code>","text":"<p>Without the <code>std</code> feature, the following are not available: - File I/O operations (<code>read_jpeg</code>, future <code>write_jpeg</code>) - <code>std::error::Error</code> trait (we use custom error types) - Threading/parallelization</p>"},{"location":"architecture/#embedded-use-cases","title":"Embedded Use Cases","text":"<p>The <code>no_std</code> design enables use in: - Microcontrollers (ARM Cortex-M, RISC-V) - Real-time Operating Systems (RTOS) - Bare-metal environments - FPGA/ASIC soft processors - Bootloaders and firmware</p>"},{"location":"architecture/#memory-considerations","title":"Memory Considerations","text":"<p>In <code>no_std</code> environments: - Heap allocation requires a global allocator to be configured - Large images may exceed available RAM on constrained devices - Consider using smaller images or streaming processing - Future: Support for static allocation and external memory</p>"},{"location":"architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/#unit-tests","title":"Unit Tests","text":"<ul> <li>Located inline with source code using <code>#[cfg(test)]</code></li> <li>Test coverage includes:</li> <li>Matrix creation and initialization</li> <li>Pixel access (get/set)</li> <li>Boundary conditions</li> <li>Error handling</li> </ul>"},{"location":"architecture/#doc-tests","title":"Doc Tests","text":"<ul> <li>Embedded in documentation comments</li> <li>Ensures examples in docs remain valid</li> <li>Run automatically with <code>cargo test</code></li> </ul>"},{"location":"architecture/#integration-tests","title":"Integration Tests","text":"<ul> <li>Examples serve as integration tests</li> <li>Real-world usage patterns</li> </ul>"},{"location":"architecture/#future-architecture-plans","title":"Future Architecture Plans","text":""},{"location":"architecture/#planned-modules","title":"Planned Modules","text":"<ol> <li><code>color.rs</code> - Color space conversions (RGB \u2194 HSV, LAB, YUV) - <code>no_std</code> compatible</li> <li><code>transform.rs</code> - Geometric transformations (resize, rotate, crop) - <code>no_std</code> compatible</li> <li><code>filter.rs</code> - Image filtering (blur, sharpen, edge detection) - <code>no_std</code> compatible</li> <li><code>features.rs</code> - Feature detection and extraction - <code>no_std</code> compatible</li> <li><code>codec/</code> - Additional image format support (PNG, BMP, TIFF) - requires <code>std</code> feature</li> <li><code>hw/</code> - Hardware accelerator interfaces for embedded systems - <code>no_std</code> compatible</li> </ol>"},{"location":"architecture/#trait-system","title":"Trait System","text":"<p>Future implementation of traits for polymorphism: <pre><code>pub trait ImageMatrix {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn channels(&amp;self) -&gt; usize;\n}\n\npub trait ImageReader {\n    fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Matrix3, ImageError&gt;;\n}\n\npub trait ImageWriter {\n    fn write&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;(), ImageError&gt;;\n}\n</code></pre></p>"},{"location":"architecture/#generic-matrix-types","title":"Generic Matrix Types","text":"<p>Potential expansion to support different channel counts and data types: - <code>Matrix&lt;T, C&gt;</code> - Generic over data type and channel count - <code>Matrix1&lt;T&gt;</code> - Single channel (grayscale) - <code>Matrix3&lt;T&gt;</code> - Three channels (RGB) - <code>Matrix4&lt;T&gt;</code> - Four channels (RGBA)</p>"},{"location":"architecture/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>When adding new features: 1. Follow existing module organization patterns 2. Design for <code>no_std</code> first - use <code>core</code> and <code>alloc</code> when possible 3. Add comprehensive tests (test with and without <code>std</code> feature) 4. Document all public APIs with examples 5. Consider performance implications, especially for embedded systems 6. Maintain memory safety without unsafe code (unless absolutely necessary) 7. Use feature flags appropriately (<code>std</code> for I/O, keep core logic <code>no_std</code>) 8. Update this architecture document</p>"},{"location":"architecture/#testing-strategy-for-no_std","title":"Testing Strategy for <code>no_std</code>","text":"<p>When testing <code>no_std</code> compatibility: <pre><code># Build without std\ncargo build --no-default-features\n\n# Build with std\ncargo build --features std\n\n# Run tests (requires std for test framework)\ncargo test\n</code></pre></p>"},{"location":"architecture/#version-history","title":"Version History","text":"<ul> <li>v0.1.0 - Initial release with <code>no_std</code> support, JPEG reading (with <code>std</code> feature), and Matrix3 support</li> </ul>"},{"location":"embedded/","title":"Embedded Systems Guide for CV Rusty","text":"<p>This guide explains how to use CV Rusty in embedded and <code>no_std</code> environments.</p>"},{"location":"embedded/#overview","title":"Overview","text":"<p>CV Rusty is designed to work in resource-constrained environments without the Rust standard library. The core functionality only requires the <code>alloc</code> crate for heap allocations.</p>"},{"location":"embedded/#requirements","title":"Requirements","text":""},{"location":"embedded/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Rust Edition: 2021 or later</li> <li>Memory: Heap allocator (<code>alloc</code> crate)</li> <li>No standard library: Works with <code>#![no_std]</code></li> </ul>"},{"location":"embedded/#memory-usage","title":"Memory Usage","text":"<p>For a <code>Matrix3</code> image, the memory requirements are: <pre><code>Memory = width \u00d7 height \u00d7 3 bytes + struct overhead (~24 bytes)\n</code></pre></p> <p>Examples: - 320\u00d7240 image: ~230 KB - 640\u00d7480 image: ~921 KB - 160\u00d7120 image: ~57 KB - 80\u00d760 image: ~14 KB</p>"},{"location":"embedded/#setup","title":"Setup","text":""},{"location":"embedded/#1-configure-cargotoml","title":"1. Configure Cargo.toml","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n\n# You'll need a global allocator for embedded systems\n# Choose one appropriate for your platform:\nembedded-alloc = \"0.5\"  # For simple embedded allocators\n</code></pre>"},{"location":"embedded/#2-configure-your-main-file","title":"2. Configure Your Main File","text":"<pre><code>#![no_std]\n#![no_main]\n\n// Import alloc for heap allocations\nextern crate alloc;\n\n// Set up a global allocator (example using embedded-alloc)\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n// Initialize the heap in your main/init function\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024; // 64 KB heap\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"embedded/#usage-patterns","title":"Usage Patterns","text":""},{"location":"embedded/#1-creating-images-from-sensor-data","title":"1. Creating Images from Sensor Data","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn capture_from_camera(width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n\n    // Read from camera sensor (pseudo-code)\n    for y in 0..height {\n        for x in 0..width {\n            let (r, g, b) = read_pixel_from_sensor(x, y);\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    image\n}\n</code></pre>"},{"location":"embedded/#2-processing-images-in-place","title":"2. Processing Images In-Place","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    let data = image.data_mut();\n\n    for pixel in data.iter_mut() {\n        let new_val = (*pixel as f32 * factor).min(255.0) as u8;\n        *pixel = new_val;\n    }\n}\n</code></pre>"},{"location":"embedded/#3-sending-to-display-via-spi","title":"3. Sending to Display via SPI","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn send_to_display(image: &amp;Matrix3, spi: &amp;mut SpiInterface) {\n    // Get raw RGB data\n    let data = image.data();\n\n    // Send to display in chunks to avoid large stack usage\n    const CHUNK_SIZE: usize = 256;\n    for chunk in data.chunks(CHUNK_SIZE) {\n        spi.write(chunk).ok();\n    }\n}\n</code></pre>"},{"location":"embedded/#4-low-memory-streaming-processing","title":"4. Low-Memory Streaming Processing","text":"<p>For very constrained systems, process images in chunks:</p> <pre><code>use cv_rusty::Matrix3;\n\nfn process_image_rows(width: usize, total_height: usize) {\n    // Process 10 rows at a time\n    const ROWS_PER_BATCH: usize = 10;\n\n    for start_row in (0..total_height).step_by(ROWS_PER_BATCH) {\n        let rows = ROWS_PER_BATCH.min(total_height - start_row);\n        let mut batch = Matrix3::zeros(width, rows);\n\n        // Fill batch from sensor\n        for y in 0..rows {\n            for x in 0..width {\n                let (r, g, b) = read_pixel_from_sensor(x, start_row + y);\n                batch.set_pixel(x, y, r, g, b);\n            }\n        }\n\n        // Process this batch\n        process_batch(&amp;mut batch);\n\n        // Send to output\n        output_batch(&amp;batch);\n    }\n}\n\nfn process_batch(batch: &amp;mut Matrix3) {\n    // Apply your image processing here\n}\n\nfn output_batch(batch: &amp;Matrix3) {\n    // Send to display or storage\n}\n</code></pre>"},{"location":"embedded/#platform-specific-examples","title":"Platform-Specific Examples","text":""},{"location":"embedded/#arm-cortex-m-stm32-nrf52-etc","title":"ARM Cortex-M (STM32, nRF52, etc.)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 32 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Initialize peripherals (camera, display, etc.)\n    let mut camera = init_camera();\n    let mut display = init_display();\n\n    loop {\n        // Capture small image (80x60 = ~14KB)\n        let image = capture_image(&amp;mut camera, 80, 60);\n\n        // Process image\n        let processed = apply_filters(&amp;image);\n\n        // Display result\n        send_to_display(&amp;processed, &amp;mut display);\n    }\n}\n\nfn capture_image(camera: &amp;mut Camera, width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n    // Capture logic...\n    image\n}\n\nfn apply_filters(image: &amp;Matrix3) -&gt; Matrix3 {\n    // Clone and process\n    let mut result = image.clone();\n    // Apply your filters...\n    result\n}\n</code></pre>"},{"location":"embedded/#esp32-embedded-rust","title":"ESP32 (Embedded Rust)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse esp_backtrace as _;\nuse esp_println::println;\nuse esp_alloc as _;\nuse cv_rusty::Matrix3;\n\n#[entry]\nfn main() -&gt; ! {\n    // ESP32 provides its own allocator\n    esp_alloc::heap_allocator!(72 * 1024); // 72 KB heap\n\n    println!(\"CV Rusty on ESP32\");\n\n    // ESP32-CAM can handle larger images (up to 640x480 on ESP32-S3)\n    let image = Matrix3::zeros(320, 240);\n    println!(\"Created {}x{} image\", image.width(), image.height());\n\n    loop {\n        // Process images from ESP32-CAM\n    }\n}\n</code></pre>"},{"location":"embedded/#risc-v","title":"RISC-V","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse riscv_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Your RISC-V application\n    let image = Matrix3::zeros(160, 120);\n\n    loop {\n        // Process images\n    }\n}\n</code></pre>"},{"location":"embedded/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"embedded/#1-stack-overflow","title":"1. Stack Overflow","text":"<p>Problem: Creating large images on the stack <pre><code>// DON'T: This might overflow the stack\nlet image = Matrix3::zeros(640, 480); // ~921 KB allocated\n</code></pre></p> <p>Solution: This is already safe! <code>Matrix3</code> uses <code>Vec</code> internally, which allocates on the heap.</p>"},{"location":"embedded/#2-heap-exhaustion","title":"2. Heap Exhaustion","text":"<p>Problem: Not enough heap space <pre><code>// Might fail if heap is too small\nlet image = Matrix3::zeros(640, 480); // Needs ~921 KB\n</code></pre></p> <p>Solution: Either increase heap size or use smaller images <pre><code>// Use smaller images for constrained devices\nlet image = Matrix3::zeros(160, 120); // Only ~57 KB\n\n// Or process in chunks (see streaming example above)\n</code></pre></p>"},{"location":"embedded/#3-missing-allocator","title":"3. Missing Allocator","text":"<p>Problem: Linker error about missing <code>__rust_alloc</code></p> <p>Solution: Always configure a global allocator: <pre><code>use embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n</code></pre></p>"},{"location":"embedded/#4-debug-formatting","title":"4. Debug Formatting","text":"<p>Problem: Using <code>println!</code> or <code>format!</code> in <code>no_std</code></p> <p>Solution: Use platform-specific printing (e.g., <code>defmt</code>, <code>esp_println</code>, or semihosting) <pre><code>// Instead of println!, use platform-specific macros\nuse defmt::info;\ninfo!(\"Image size: {}x{}\", image.width(), image.height());\n</code></pre></p>"},{"location":"embedded/#memory-optimization-tips","title":"Memory Optimization Tips","text":""},{"location":"embedded/#1-reuse-image-buffers","title":"1. Reuse Image Buffers","text":"<pre><code>// Keep one image buffer and reuse it\nstatic mut IMAGE_BUFFER: Option&lt;Matrix3&gt; = None;\n\nfn get_image_buffer(width: usize, height: usize) -&gt; &amp;'static mut Matrix3 {\n    unsafe {\n        if IMAGE_BUFFER.is_none() {\n            IMAGE_BUFFER = Some(Matrix3::zeros(width, height));\n        }\n        IMAGE_BUFFER.as_mut().unwrap()\n    }\n}\n</code></pre>"},{"location":"embedded/#2-in-place-operations","title":"2. In-Place Operations","text":"<pre><code>// Modify the image data directly instead of creating new images\nfn process_inplace(image: &amp;mut Matrix3) {\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                // Process and write back\n                let new_r = (r as u16 * 2).min(255) as u8;\n                image.set_pixel(x, y, new_r, g, b);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"embedded/#3-use-smaller-color-depths","title":"3. Use Smaller Color Depths","text":"<p>For very constrained systems, consider: - Downsampling images before processing - Using grayscale by keeping only one channel - Processing regions of interest (ROI) instead of full images</p> <pre><code>// Extract a region of interest\nfn extract_roi(src: &amp;Matrix3, x: usize, y: usize, w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"embedded/#performance-considerations","title":"Performance Considerations","text":""},{"location":"embedded/#typical-performance-arm-cortex-m4-80-mhz","title":"Typical Performance (ARM Cortex-M4 @ 80 MHz)","text":"<ul> <li>Creating 160\u00d7120 image: ~1 ms</li> <li>Pixel access: ~10 ns per pixel</li> <li>Full image iteration: ~5-10 ms for 160\u00d7120</li> </ul>"},{"location":"embedded/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Batch Operations: Process multiple pixels at once</li> <li>Cache Locality: Access pixels in row-major order</li> <li>Minimize Allocations: Reuse buffers when possible</li> <li>Direct Data Access: Use <code>data()</code> and <code>data_mut()</code> for bulk operations</li> </ol>"},{"location":"embedded/#testing-on-host-system","title":"Testing on Host System","text":"<p>You can test your embedded code on your development machine:</p> <pre><code># Build for embedded target\ncargo build --target thumbv7em-none-eabihf --no-default-features\n\n# Test on host (with std for test framework)\ncargo test\n</code></pre>"},{"location":"embedded/#integration-with-hardware-accelerators","title":"Integration with Hardware Accelerators","text":"<p>Many embedded systems have hardware acceleration for image processing:</p> <pre><code>// Example: Offload operations to DMA or GPU\nfn hardware_accelerated_copy(image: &amp;Matrix3, hw_buffer: &amp;mut [u8]) {\n    let data = image.data();\n\n    // Use DMA to copy data\n    dma_transfer(data, hw_buffer);\n\n    // Trigger hardware processor\n    trigger_hw_processor();\n}\n</code></pre>"},{"location":"embedded/#additional-resources","title":"Additional Resources","text":"<ul> <li>Embedded Rust Book</li> <li>rust-embedded/awesome-embedded-rust</li> <li>Allocators for embedded systems</li> </ul>"},{"location":"embedded/#support","title":"Support","text":"<p>For questions about using CV Rusty in embedded systems, please: 1. Check the examples in <code>examples/no_std_example.rs</code> 2. Review this guide 3. Open an issue on GitHub with your platform details</p>"},{"location":"embedded/#license","title":"License","text":"<p>Same as the main CV Rusty library (MIT).</p>"},{"location":"image-writing/","title":"Image Writing Functionality","text":"<p>This document describes the image writing capabilities added to cv-rusty, allowing you to save <code>Matrix3</code> objects as JPEG or PNG files.</p>"},{"location":"image-writing/#overview","title":"Overview","text":"<p>The library now supports writing RGB image data from <code>Matrix3</code> objects to disk in two popular formats: - JPEG - Lossy compression with adjustable quality - PNG - Lossless compression</p>"},{"location":"image-writing/#api-reference","title":"API Reference","text":""},{"location":"image-writing/#writing-jpeg-images","title":"Writing JPEG Images","text":"<pre><code>pub fn write_jpeg&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n    quality: u8,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the JPEG should be saved - <code>quality</code>: Compression quality (1-100)   - <code>1</code>: Lowest quality, smallest file size   - <code>100</code>: Highest quality, largest file size   - <code>90</code>: Recommended for most use cases   - Values outside 1-100 are automatically clamped</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_jpeg};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write high-quality JPEG\nwrite_jpeg(&amp;image, \"output.jpg\", 95)?;\n\n// Write smaller file with lower quality\nwrite_jpeg(&amp;image, \"compressed.jpg\", 60)?;\n</code></pre></p>"},{"location":"image-writing/#writing-png-images","title":"Writing PNG Images","text":"<pre><code>pub fn write_png&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the PNG should be saved</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_png};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write lossless PNG\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"image-writing/#format-comparison","title":"Format Comparison","text":""},{"location":"image-writing/#jpeg","title":"JPEG","text":"<p>Pros: - Smaller file sizes - Adjustable quality/size tradeoff - Widely supported - Good for photographs</p> <p>Cons: - Lossy compression (data loss) - Not suitable for text or sharp edges - No transparency support</p> <p>Typical file sizes (640\u00d7480 image): - Quality 95: ~35 KB - Quality 75: ~11 KB - Quality 50: ~6 KB</p>"},{"location":"image-writing/#png","title":"PNG","text":"<p>Pros: - Lossless compression (no data loss) - Perfect for graphics with sharp edges - Supports transparency (though cv-rusty uses RGB without alpha) - Good for iterative editing</p> <p>Cons: - Larger file sizes than JPEG - Less efficient for photographs</p> <p>Typical file sizes (640\u00d7480 image): - RGB gradient: ~240 KB</p>"},{"location":"image-writing/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>use cv_rusty::{read_jpeg, write_jpeg, write_png, Matrix3};\n\nfn process_and_save() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read an image\n    let mut image = read_jpeg(\"input.jpg\")?;\n\n    // Process the image (example: invert colors)\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                image.set_pixel(x, y, 255 - r, 255 - g, 255 - b);\n            }\n        }\n    }\n\n    // Save in multiple formats\n    write_jpeg(&amp;image, \"output_high_quality.jpg\", 95)?;\n    write_jpeg(&amp;image, \"output_web_quality.jpg\", 80)?;\n    write_png(&amp;image, \"output_lossless.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"image-writing/#error-handling","title":"Error Handling","text":"<p>Both functions return <code>Result&lt;(), ImageError&gt;</code> which can have the following error types:</p> <ul> <li><code>ImageError::Io</code>: File system errors (permissions, disk space, etc.)</li> <li><code>ImageError::JpegEncode</code>: JPEG encoding errors</li> <li><code>ImageError::PngEncode</code>: PNG encoding errors</li> </ul> <pre><code>use cv_rusty::io::{write_jpeg, ImageError};\n\nmatch write_jpeg(&amp;image, \"output.jpg\", 90) {\n    Ok(_) =&gt; println!(\"Image saved successfully\"),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegEncode(e)) =&gt; eprintln!(\"Encoding error: {}\", e),\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre>"},{"location":"image-writing/#quality-guidelines","title":"Quality Guidelines","text":""},{"location":"image-writing/#jpeg-quality-recommendations","title":"JPEG Quality Recommendations","text":"Quality Use Case File Size Visual Quality 90-100 Archival, printing, professional use Large Excellent 80-89 High-quality web images Medium Very Good 60-79 Standard web images, general use Small Good 40-59 Thumbnails, low-bandwidth scenarios Very Small Acceptable 1-39 Extreme compression Minimal Poor"},{"location":"image-writing/#when-to-use-each-format","title":"When to Use Each Format","text":"<p>Use JPEG when: - Working with photographs - File size is a concern - Minor quality loss is acceptable - Sharing on the web</p> <p>Use PNG when: - Preserving exact pixel values is critical - Working with graphics, text, or line art - Need to perform multiple save operations - File size is not a primary concern</p>"},{"location":"image-writing/#dependencies","title":"Dependencies","text":"<p>The image writing functionality requires the <code>std</code> feature (enabled by default) and uses: - <code>jpeg-encoder</code> (v0.6) for JPEG encoding - <code>png</code> (v0.17) for PNG encoding</p> <p>These dependencies are automatically included when using the default <code>std</code> feature.</p>"},{"location":"image-writing/#examples","title":"Examples","text":"<p>Run the included examples to see the functionality in action:</p> <pre><code># Create gradient images in both formats\ncargo run --example write_image_example\n\n# Convert an existing image to different formats\ncargo run --example image_conversion input.jpg\n\n# View all examples\nls examples/\n</code></pre>"},{"location":"image-writing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>JPEG encoding is generally faster than PNG for photographs</li> <li>PNG encoding time increases with image complexity</li> <li>Both encoders are optimized for single-threaded operation</li> <li>Memory usage is proportional to image size: width \u00d7 height \u00d7 3 bytes for RGB data</li> </ul>"},{"location":"image-writing/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for future versions: - Support for writing grayscale images - PNG transparency (RGBA) support - Progressive JPEG encoding - Configurable PNG compression levels - Batch processing utilities - SIMD-optimized encoding</p>"},{"location":"image-writing/#see-also","title":"See Also","text":"<ul> <li>README.md - General library documentation</li> <li>ARCHITECTURE.md - Library architecture</li> <li>API Documentation - Full API reference</li> </ul>"},{"location":"quick-reference/","title":"CV Rusty Quick Reference","text":""},{"location":"quick-reference/#installation","title":"Installation","text":""},{"location":"quick-reference/#with-standard-library-default","title":"With Standard Library (default)","text":"<pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"quick-reference/#for-embeddedno_std","title":"For Embedded/no_std","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"quick-reference/#feature-flags","title":"Feature Flags","text":"Feature Description Default <code>std</code> Standard library support + file I/O \u2713 <code>alloc</code> Heap allocation (required for core) -"},{"location":"quick-reference/#basic-operations","title":"Basic Operations","text":""},{"location":"quick-reference/#creating-images","title":"Creating Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// Create zero-filled image\nlet image = Matrix3::zeros(640, 480);\n\n// Create from raw RGB data\nlet data = vec![0u8; 640 * 480 * 3];\nlet image = Matrix3::new(640, 480, data);\n</code></pre>"},{"location":"quick-reference/#reading-images-requires-std","title":"Reading Images (requires <code>std</code>)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png};\n\n// Read JPEG\nlet image = read_jpeg(\"photo.jpg\")?;\n\n// Read PNG\nlet image = read_png(\"photo.png\")?;\n</code></pre>"},{"location":"quick-reference/#accessing-image-properties","title":"Accessing Image Properties","text":"<pre><code>let width = image.width();\nlet height = image.height();\nlet (w, h) = image.dimensions();\nlet raw_data = image.data();\n</code></pre>"},{"location":"quick-reference/#pixel-operations","title":"Pixel Operations","text":"<pre><code>// Get pixel\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Set pixel\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel\n</code></pre>"},{"location":"quick-reference/#direct-data-access","title":"Direct Data Access","text":"<pre><code>// Read-only access\nlet data = image.data();\nfor chunk in data.chunks_exact(3) {\n    let (r, g, b) = (chunk[0], chunk[1], chunk[2]);\n    // Process pixel...\n}\n\n// Mutable access\nlet data = image.data_mut();\nfor pixel in data.iter_mut() {\n    *pixel = (*pixel as u16 * 2).min(255) as u8;\n}\n</code></pre>"},{"location":"quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-reference/#brightness-adjustment","title":"Brightness Adjustment","text":"<pre><code>fn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    for pixel in image.data_mut().iter_mut() {\n        *pixel = (*pixel as f32 * factor).min(255.0) as u8;\n    }\n}\n</code></pre>"},{"location":"quick-reference/#grayscale-conversion","title":"Grayscale Conversion","text":"<pre><code>fn to_grayscale(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut gray = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let gray_val = (0.299 * r as f32 + \n                               0.587 * g as f32 + \n                               0.114 * b as f32) as u8;\n                gray.set_pixel(x, y, gray_val, gray_val, gray_val);\n            }\n        }\n    }\n    gray\n}\n</code></pre>"},{"location":"quick-reference/#region-of-interest-roi","title":"Region of Interest (ROI)","text":"<pre><code>fn extract_roi(src: &amp;Matrix3, x: usize, y: usize, \n               w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"quick-reference/#color-channel-operations","title":"Color Channel Operations","text":"<pre><code>// Extract red channel\nfn extract_red_channel(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut red = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, _, _)) = image.get_pixel(x, y) {\n                red.set_pixel(x, y, r, 0, 0);\n            }\n        }\n    }\n    red\n}\n</code></pre>"},{"location":"quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"quick-reference/#with-match","title":"With Match","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; println!(\"Loaded {}x{}\", image.width(), image.height()),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegDecode(e)) =&gt; eprintln!(\"JPEG error: {}\", e),\n    Err(ImageError::PngDecode(e)) =&gt; eprintln!(\"PNG error: {}\", e),\n    Err(ImageError::UnsupportedFormat(e)) =&gt; eprintln!(\"Format error: {}\", e),\n}\n</code></pre>"},{"location":"quick-reference/#with-operator","title":"With ? Operator","text":"<pre><code>fn process() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let jpeg_image = read_jpeg(\"photo.jpg\")?;\n    let png_image = read_png(\"photo.png\")?;\n    // Process images...\n    Ok(())\n}\n</code></pre>"},{"location":"quick-reference/#embeddedno_std-usage","title":"Embedded/no_std Usage","text":""},{"location":"quick-reference/#setup","title":"Setup","text":"<pre><code>#![no_std]\nextern crate alloc;\n\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"quick-reference/#create-small-images","title":"Create Small Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// 80x60 image = ~14 KB\nlet image = Matrix3::zeros(80, 60);\n</code></pre>"},{"location":"quick-reference/#process-in-chunks","title":"Process in Chunks","text":"<pre><code>const CHUNK_HEIGHT: usize = 10;\n\nfor start_y in (0..height).step_by(CHUNK_HEIGHT) {\n    let h = CHUNK_HEIGHT.min(height - start_y);\n    let chunk = Matrix3::zeros(width, h);\n    // Process chunk...\n}\n</code></pre>"},{"location":"quick-reference/#memory-requirements","title":"Memory Requirements","text":"Resolution Memory 80\u00d760 ~14 KB 160\u00d7120 ~57 KB 320\u00d7240 ~230 KB 640\u00d7480 ~921 KB <p>Formula: <code>width \u00d7 height \u00d7 3 bytes + 24 bytes overhead</code></p>"},{"location":"quick-reference/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use direct data access for bulk operations</li> <li>Process in row-major order for cache efficiency</li> <li>Reuse buffers instead of creating new images</li> <li>Modify in-place when possible</li> <li>Batch pixel operations to reduce overhead</li> </ol>"},{"location":"quick-reference/#build-commands","title":"Build Commands","text":"<pre><code># Build with std (default)\ncargo build\n\n# Build for no_std\ncargo build --no-default-features\n\n# Run tests\ncargo test\n\n# Run examples\ncargo run --example read_jpeg_example image.jpg\ncargo run --example read_png_example image.png\ncargo run --example no_std_example\n</code></pre>"},{"location":"quick-reference/#documentation","title":"Documentation","text":"<pre><code># Generate and open docs\ncargo doc --open\n</code></pre>"},{"location":"quick-reference/#support","title":"Support","text":"<ul> <li>GitHub: [Repository URL]</li> <li>Documentation: Run <code>cargo doc --open</code></li> <li>Examples: See <code>examples/</code> directory</li> <li>Architecture: See <code>ARCHITECTURE.md</code></li> <li>Embedded Guide: See <code>EMBEDDED.md</code></li> </ul>"}]}