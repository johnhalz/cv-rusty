{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CV Rusty","text":"<p>A <code>no_std</code> computer vision library written in Rust, designed for live computations, embedded systems, and high-performance image processing.</p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>no_std</code> Compatible: Core library works without the standard library (only requires <code>alloc</code>)</li> <li>Zero-copy Image Representation: Efficient three-channel matrix structure for RGB images</li> <li>Image I/O: Built-in support for reading and writing JPEG and PNG images with automatic format conversion (requires <code>std</code> feature)</li> <li>Format Support: Handles RGB24, Grayscale (L8), and CMYK32 JPEG formats; RGB, RGBA, Grayscale, and Grayscale+Alpha PNG formats</li> <li>Safe API: Bounds-checked pixel access with ergonomic error handling</li> <li>Embedded Ready: Perfect for resource-constrained environments and real-time systems</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#standard-library-default","title":"Standard Library (default)","text":"<p>For applications with <code>std</code> support and file I/O:</p> <pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"#no_std-environments","title":"<code>no_std</code> Environments","text":"<p>For embedded systems or <code>no_std</code> environments (requires <code>alloc</code>):</p> <pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"#feature-flags","title":"Feature Flags","text":"<ul> <li><code>std</code> (enabled by default): Enables standard library support, including file I/O operations</li> <li><code>alloc</code>: Enables heap allocation support (required for core functionality)</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#reading-and-writing-images-requires-std-feature","title":"Reading and Writing Images (requires <code>std</code> feature)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, write_jpeg, write_png};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read a JPEG file into a Matrix3\n    let image = read_jpeg(\"photo.jpg\")?;\n    println!(\"JPEG dimensions: {}x{}\", image.width(), image.height());\n\n    // Read a PNG file into a Matrix3\n    let image = read_png(\"photo.png\")?;\n    println!(\"PNG dimensions: {}x{}\", image.width(), image.height());\n\n    // Access pixel data\n    if let Some((r, g, b)) = image.get_pixel(100, 100) {\n        println!(\"Pixel at (100, 100): RGB({}, {}, {})\", r, g, b);\n    }\n\n    // Write as JPEG with quality setting (1-100)\n    write_jpeg(&amp;image, \"output.jpg\", 90)?;\n\n    // Write as PNG (lossless)\n    write_png(&amp;image, \"output.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"#working-with-matrix3-no_std-compatible","title":"Working with Matrix3 (<code>no_std</code> compatible)","text":"<pre><code>use cv_rusty::matrix::Matrix3;\n\n// Create a new 640x480 image filled with zeros\nlet mut image = Matrix3::zeros(640, 480);\n\n// Set a pixel value\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel at (10, 20)\n\n// Get a pixel value\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Access raw data\nlet raw_data = image.data();\nprintln!(\"Total bytes: {}\", raw_data.len());\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; {\n        println!(\"Successfully loaded {}x{} image\", image.width(), image.height());\n    }\n    Err(ImageError::Io(e)) =&gt; {\n        eprintln!(\"File I/O error: {}\", e);\n    }\n    Err(ImageError::JpegDecode(e)) =&gt; {\n        eprintln!(\"JPEG decoding error: {}\", e);\n    }\n    Err(ImageError::PngDecode(e)) =&gt; {\n        eprintln!(\"PNG decoding error: {}\", e);\n    }\n    Err(ImageError::JpegEncode(e)) =&gt; {\n        eprintln!(\"JPEG encoding error: {}\", e);\n    }\n    Err(ImageError::PngEncode(e)) =&gt; {\n        eprintln!(\"PNG encoding error: {}\", e);\n    }\n    Err(ImageError::UnsupportedFormat(e)) =&gt; {\n        eprintln!(\"Unsupported format: {}\", e);\n    }\n}\n</code></pre>"},{"location":"#no_std-embedded-usage","title":"<code>no_std</code> Embedded Usage","text":"<pre><code>#![no_std]\n\nextern crate alloc;\nuse cv_rusty::Matrix3;\n\nfn process_image() {\n    // Create image data in memory\n    let mut image = Matrix3::zeros(320, 240);\n\n    // Process pixels (e.g., from a camera sensor)\n    for y in 0..240 {\n        for x in 0..320 {\n            // Set pixel from sensor data\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    // Send to display via SPI/I2C\n    let raw_data = image.data();\n    // ... send raw_data to hardware\n}\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#with-std-feature-file-io","title":"With <code>std</code> feature (file I/O)","text":"<p>Read and analyze a JPEG file:</p> <pre><code>cargo run --example read_jpeg_example path/to/your/image.jpg\n</code></pre> <p>Read and analyze a PNG file:</p> <pre><code>cargo run --example read_png_example path/to/your/image.png\n</code></pre> <p>Write images in JPEG and PNG formats:</p> <pre><code>cargo run --example write_image_example\n</code></pre> <p>Convert images between formats:</p> <pre><code>cargo run --example image_conversion path/to/your/image.jpg\n</code></pre>"},{"location":"#no_std-example","title":"<code>no_std</code> example","text":"<p>Demonstrate core functionality without file I/O:</p> <pre><code>cargo run --example no_std_example\n</code></pre> <p>Build for <code>no_std</code> environment:</p> <pre><code>cargo build --no-default-features\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":""},{"location":"#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix for representing RGB image data.</p> <p>Key Methods: - <code>new(width, height, data)</code> - Create from raw RGB data - <code>zeros(width, height)</code> - Create a zero-initialized matrix - <code>get_pixel(x, y)</code> - Get RGB values at a pixel location - <code>set_pixel(x, y, r, g, b)</code> - Set RGB values at a pixel location - <code>width()</code>, <code>height()</code>, <code>dimensions()</code> - Get matrix dimensions - <code>data()</code>, <code>data_mut()</code> - Access raw pixel data</p>"},{"location":"#ioread_jpegpath","title":"<code>io::read_jpeg(path)</code>","text":"<p>Reads a JPEG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB24 (24-bit color) - L8 (8-bit grayscale, converted to RGB) - CMYK32 (CMYK color space, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#ioread_pngpath","title":"<code>io::read_png(path)</code>","text":"<p>Reads a PNG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB (24-bit color) - RGBA (32-bit color with alpha, alpha channel stripped) - Grayscale (8-bit, converted to RGB) - Grayscale+Alpha (16-bit, alpha channel stripped, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#iowrite_jpegmatrix-path-quality","title":"<code>io::write_jpeg(matrix, path, quality)</code>","text":"<p>Writes a <code>Matrix3</code> as a JPEG image file.</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the JPEG file should be written - <code>quality</code> - JPEG quality (1-100, where 100 is best quality)</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_jpeg(&amp;image, \"output.jpg\", 90)?;\n</code></pre></p>"},{"location":"#iowrite_pngmatrix-path","title":"<code>io::write_png(matrix, path)</code>","text":"<p>Writes a <code>Matrix3</code> as a PNG image file (lossless compression).</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the PNG file should be written</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#embedded-systems","title":"Embedded Systems","text":"<ul> <li>Camera processing on microcontrollers</li> <li>Real-time video processing on FPGA/ASIC</li> <li>LCD/OLED display controllers</li> <li>Industrial vision systems</li> </ul>"},{"location":"#high-performance-applications","title":"High-Performance Applications","text":"<ul> <li>Real-time computer vision</li> <li>Video processing pipelines</li> <li>Live streaming applications</li> <li>Robotics and automation</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> <code>no_std</code> support</li> <li> JPEG image reading (with <code>std</code> feature)</li> <li> PNG image reading (with <code>std</code> feature)</li> <li> JPEG image writing (with <code>std</code> feature)</li> <li> PNG image writing (with <code>std</code> feature)</li> <li> Color space conversions (RGB \u2194 HSV, YUV)</li> <li> Basic image operations (resize, crop, rotate)</li> <li> Filtering and convolution</li> <li> Edge detection</li> <li> Feature detection</li> <li> SIMD optimizations</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is open source and available under the MIT License.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"quick-reference/","title":"CV Rusty Quick Reference","text":""},{"location":"quick-reference/#installation","title":"Installation","text":""},{"location":"quick-reference/#with-standard-library-default","title":"With Standard Library (default)","text":"<pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"quick-reference/#for-embeddedno_std","title":"For Embedded/no_std","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"quick-reference/#feature-flags","title":"Feature Flags","text":"Feature Description Default <code>std</code> Standard library support + file I/O \u2713 <code>alloc</code> Heap allocation (required for core) -"},{"location":"quick-reference/#basic-operations","title":"Basic Operations","text":""},{"location":"quick-reference/#creating-images","title":"Creating Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// Create zero-filled image\nlet image = Matrix3::zeros(640, 480);\n\n// Create from raw RGB data\nlet data = vec![0u8; 640 * 480 * 3];\nlet image = Matrix3::new(640, 480, data);\n</code></pre>"},{"location":"quick-reference/#reading-images-requires-std","title":"Reading Images (requires <code>std</code>)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png};\n\n// Read JPEG\nlet image = read_jpeg(\"photo.jpg\")?;\n\n// Read PNG\nlet image = read_png(\"photo.png\")?;\n</code></pre>"},{"location":"quick-reference/#accessing-image-properties","title":"Accessing Image Properties","text":"<pre><code>let width = image.width();\nlet height = image.height();\nlet (w, h) = image.dimensions();\nlet raw_data = image.data();\n</code></pre>"},{"location":"quick-reference/#pixel-operations","title":"Pixel Operations","text":"<pre><code>// Get pixel\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Set pixel\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel\n</code></pre>"},{"location":"quick-reference/#direct-data-access","title":"Direct Data Access","text":"<pre><code>// Read-only access\nlet data = image.data();\nfor chunk in data.chunks_exact(3) {\n    let (r, g, b) = (chunk[0], chunk[1], chunk[2]);\n    // Process pixel...\n}\n\n// Mutable access\nlet data = image.data_mut();\nfor pixel in data.iter_mut() {\n    *pixel = (*pixel as u16 * 2).min(255) as u8;\n}\n</code></pre>"},{"location":"quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-reference/#brightness-adjustment","title":"Brightness Adjustment","text":"<pre><code>fn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    for pixel in image.data_mut().iter_mut() {\n        *pixel = (*pixel as f32 * factor).min(255.0) as u8;\n    }\n}\n</code></pre>"},{"location":"quick-reference/#grayscale-conversion","title":"Grayscale Conversion","text":"<pre><code>fn to_grayscale(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut gray = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let gray_val = (0.299 * r as f32 + \n                               0.587 * g as f32 + \n                               0.114 * b as f32) as u8;\n                gray.set_pixel(x, y, gray_val, gray_val, gray_val);\n            }\n        }\n    }\n    gray\n}\n</code></pre>"},{"location":"quick-reference/#region-of-interest-roi","title":"Region of Interest (ROI)","text":"<pre><code>fn extract_roi(src: &amp;Matrix3, x: usize, y: usize, \n               w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"quick-reference/#color-channel-operations","title":"Color Channel Operations","text":"<pre><code>// Extract red channel\nfn extract_red_channel(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut red = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, _, _)) = image.get_pixel(x, y) {\n                red.set_pixel(x, y, r, 0, 0);\n            }\n        }\n    }\n    red\n}\n</code></pre>"},{"location":"quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"quick-reference/#with-match","title":"With Match","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; println!(\"Loaded {}x{}\", image.width(), image.height()),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegDecode(e)) =&gt; eprintln!(\"JPEG error: {}\", e),\n    Err(ImageError::PngDecode(e)) =&gt; eprintln!(\"PNG error: {}\", e),\n    Err(ImageError::UnsupportedFormat(e)) =&gt; eprintln!(\"Format error: {}\", e),\n}\n</code></pre>"},{"location":"quick-reference/#with-operator","title":"With ? Operator","text":"<pre><code>fn process() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let jpeg_image = read_jpeg(\"photo.jpg\")?;\n    let png_image = read_png(\"photo.png\")?;\n    // Process images...\n    Ok(())\n}\n</code></pre>"},{"location":"quick-reference/#embeddedno_std-usage","title":"Embedded/no_std Usage","text":""},{"location":"quick-reference/#setup","title":"Setup","text":"<pre><code>#![no_std]\nextern crate alloc;\n\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"quick-reference/#create-small-images","title":"Create Small Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// 80x60 image = ~14 KB\nlet image = Matrix3::zeros(80, 60);\n</code></pre>"},{"location":"quick-reference/#process-in-chunks","title":"Process in Chunks","text":"<pre><code>const CHUNK_HEIGHT: usize = 10;\n\nfor start_y in (0..height).step_by(CHUNK_HEIGHT) {\n    let h = CHUNK_HEIGHT.min(height - start_y);\n    let chunk = Matrix3::zeros(width, h);\n    // Process chunk...\n}\n</code></pre>"},{"location":"quick-reference/#memory-requirements","title":"Memory Requirements","text":"Resolution Memory 80\u00d760 ~14 KB 160\u00d7120 ~57 KB 320\u00d7240 ~230 KB 640\u00d7480 ~921 KB <p>Formula: <code>width \u00d7 height \u00d7 3 bytes + 24 bytes overhead</code></p>"},{"location":"quick-reference/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use direct data access for bulk operations</li> <li>Process in row-major order for cache efficiency</li> <li>Reuse buffers instead of creating new images</li> <li>Modify in-place when possible</li> <li>Batch pixel operations to reduce overhead</li> </ol>"},{"location":"quick-reference/#build-commands","title":"Build Commands","text":"<pre><code># Build with std (default)\ncargo build\n\n# Build for no_std\ncargo build --no-default-features\n\n# Run tests\ncargo test\n\n# Run examples\ncargo run --example read_jpeg_example image.jpg\ncargo run --example read_png_example image.png\ncargo run --example no_std_example\n</code></pre>"},{"location":"quick-reference/#documentation","title":"Documentation","text":"<pre><code># Generate and open docs\ncargo doc --open\n</code></pre>"},{"location":"quick-reference/#support","title":"Support","text":"<ul> <li>GitHub: [Repository URL]</li> <li>Documentation: Run <code>cargo doc --open</code></li> <li>Examples: See <code>examples/</code> directory</li> <li>Architecture: See <code>ARCHITECTURE.md</code></li> <li>Embedded Guide: See <code>EMBEDDED.md</code></li> </ul>"},{"location":"architecture/architecture/","title":"CV Rusty Architecture","text":""},{"location":"architecture/architecture/#overview","title":"Overview","text":"<p>CV Rusty is a <code>no_std</code> compatible computer vision library written in Rust with a focus on performance, safety, and embedded systems support. The library is designed for live computations, real-time image processing applications, and resource-constrained environments.</p>"},{"location":"architecture/architecture/#project-structure","title":"Project Structure","text":"<pre><code>cv-rusty/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs          # Main library entry point\n\u2502   \u251c\u2500\u2500 matrix.rs       # Matrix data structures\n\u2502   \u2514\u2500\u2500 io.rs           # Image I/O operations\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 read_jpeg_example.rs\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"architecture/architecture/#module-design","title":"Module Design","text":""},{"location":"architecture/architecture/#librs","title":"<code>lib.rs</code>","text":"<p>The main library entry point configured for <code>no_std</code> compatibility. It uses feature flags to conditionally compile std-dependent code.</p> <p>Key Attributes: - <code>#![cfg_attr(not(feature = \"std\"), no_std)]</code> - Enables <code>no_std</code> when std feature is disabled - <code>extern crate alloc</code> - Required for heap allocations in <code>no_std</code> environments</p> <p>Public API: - <code>Matrix3</code> - Three-channel image matrix (always available) - <code>read_jpeg</code> - JPEG file reading function (only with <code>std</code> feature)</p>"},{"location":"architecture/architecture/#matrixrs","title":"<code>matrix.rs</code>","text":"<p>Contains the core data structure for representing multi-channel image data. This module is fully <code>no_std</code> compatible and only requires the <code>alloc</code> crate.</p> <p><code>no_std</code> Compatibility: - Uses <code>core::fmt</code> instead of <code>std::fmt</code> - Imports <code>Vec</code> from <code>alloc::vec::Vec</code> when <code>std</code> is not available - Imports <code>vec!</code> macro from <code>alloc::vec</code> for <code>no_std</code> environments</p>"},{"location":"architecture/architecture/#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix specifically designed for RGB image representation.</p> <p>Design Decisions: - Contiguous Memory Layout: Data is stored in a single <code>Vec&lt;u8&gt;</code> for cache efficiency - Interleaved Channels: RGB values are stored as <code>[R, G, B, R, G, B, ...]</code> for better spatial locality - Row-Major Order: Standard image representation order (y * width + x) - Bounds Checking: All pixel access methods return <code>Option</code> or <code>bool</code> to prevent panics</p> <p>Memory Layout: <pre><code>Pixel (0,0): [R, G, B] | Pixel (1,0): [R, G, B] | ... | Pixel (W-1,0): [R, G, B]\nPixel (0,1): [R, G, B] | Pixel (1,1): [R, G, B] | ... | Pixel (W-1,1): [R, G, B]\n...\nPixel (0,H-1): [R, G, B] | ... | Pixel (W-1,H-1): [R, G, B]\n</code></pre></p> <p>Index Calculation: <pre><code>let pixel_index = (y * width + x) * 3;\nlet r = data[pixel_index];\nlet g = data[pixel_index + 1];\nlet b = data[pixel_index + 2];\n</code></pre></p>"},{"location":"architecture/architecture/#iors","title":"<code>io.rs</code>","text":"<p>Handles image file I/O operations, currently supporting JPEG format. This module is only compiled when the <code>std</code> feature is enabled, as it requires file system access.</p> <p>Compilation Guard: - Only included when <code>#[cfg(feature = \"std\")]</code> is true - Requires <code>std::fs</code>, <code>std::io</code>, and <code>std::path</code></p>"},{"location":"architecture/architecture/#imageerror","title":"<code>ImageError</code>","text":"<p>Custom error type for image operations with variants: - <code>Io(io::Error)</code> - File system errors - <code>JpegDecode(String)</code> - JPEG decoding errors - <code>UnsupportedFormat(String)</code> - Unsupported pixel format errors</p>"},{"location":"architecture/architecture/#read_jpegpath","title":"<code>read_jpeg(path)</code>","text":"<p>Reads JPEG files and converts them to RGB <code>Matrix3</code>.</p> <p>Supported Input Formats: 1. RGB24 - Direct passthrough (most common) 2. L8 (Grayscale) - Converted by duplicating channel: <code>[G] -&gt; [G, G, G]</code> 3. CMYK32 - Converted using formula:    <pre><code>R = (1 - C) * (1 - K) * 255\nG = (1 - M) * (1 - K) * 255\nB = (1 - Y) * (1 - K) * 255\n</code></pre></p> <p>Processing Pipeline: 1. Open file with buffered reader 2. Create JPEG decoder 3. Decode image to raw pixels 4. Extract metadata (width, height, pixel format) 5. Convert to RGB if necessary 6. Construct <code>Matrix3</code> with RGB data</p>"},{"location":"architecture/architecture/#dependencies","title":"Dependencies","text":""},{"location":"architecture/architecture/#jpeg-decoder-v03","title":"<code>jpeg-decoder</code> (v0.3)","text":"<ul> <li>Purpose: JPEG image decoding</li> <li>Features: Supports multiple pixel formats, hardware acceleration</li> <li>License: MIT/Apache-2.0</li> <li>Availability: Optional, only included with <code>std</code> feature</li> <li>Note: This dependency requires <code>std</code>, so JPEG reading is not available in <code>no_std</code> environments</li> </ul>"},{"location":"architecture/architecture/#feature-flags","title":"Feature Flags","text":""},{"location":"architecture/architecture/#std-default","title":"<code>std</code> (default)","text":"<p>Enables standard library support, including: - File I/O operations (<code>io</code> module) - JPEG reading functionality - <code>std::error::Error</code> trait implementations</p>"},{"location":"architecture/architecture/#alloc","title":"<code>alloc</code>","text":"<p>Enables heap allocation support (required for core functionality): - <code>Vec&lt;u8&gt;</code> for storing pixel data - Dynamic memory allocation</p> <p>Feature Dependencies: <pre><code>[features]\ndefault = [\"std\"]\nstd = [\"jpeg-decoder\"]\nalloc = []\n</code></pre></p>"},{"location":"architecture/architecture/#design-principles","title":"Design Principles","text":"<ol> <li><code>no_std</code> First: Core functionality works without standard library</li> <li>Zero-Copy When Possible: Minimize data copying during operations</li> <li>Memory Safety: Use Rust's type system to prevent buffer overflows</li> <li>Ergonomic API: Simple, intuitive interfaces for common operations</li> <li>Performance: Design for real-time processing applications</li> <li>Extensibility: Modular design allows easy addition of new formats and operations</li> <li>Embedded Ready: Suitable for microcontrollers and resource-constrained systems</li> </ol>"},{"location":"architecture/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/architecture/#memory-layout","title":"Memory Layout","text":"<ul> <li>Contiguous allocation reduces cache misses</li> <li>Interleaved channels improve spatial locality for pixel operations</li> <li>Single allocation per image minimizes heap fragmentation</li> </ul>"},{"location":"architecture/architecture/#bounds-checking","title":"Bounds Checking","text":"<ul> <li>All pixel access is bounds-checked at compile time or returns <code>Option</code></li> <li>No unsafe code in current implementation</li> <li>Trade-off: slight overhead for safety guarantees</li> </ul>"},{"location":"architecture/architecture/#future-optimizations","title":"Future Optimizations","text":"<ul> <li>SIMD operations for bulk pixel processing</li> <li>Parallel processing with rayon for large images (with <code>std</code> feature)</li> <li>Memory pooling for repeated allocations</li> <li>Optional unsafe fast paths for performance-critical code</li> <li>Hardware accelerator support for embedded systems</li> <li>Zero-allocation operations where possible</li> </ul>"},{"location":"architecture/architecture/#no_std-support","title":"<code>no_std</code> Support","text":""},{"location":"architecture/architecture/#requirements","title":"Requirements","text":"<p>The core library (<code>Matrix3</code> and related operations) only requires: - <code>core</code> - Rust's core library (always available) - <code>alloc</code> - For heap allocations (<code>Vec</code>)</p>"},{"location":"architecture/architecture/#limitations-in-no_std","title":"Limitations in <code>no_std</code>","text":"<p>Without the <code>std</code> feature, the following are not available: - File I/O operations (<code>read_jpeg</code>, future <code>write_jpeg</code>) - <code>std::error::Error</code> trait (we use custom error types) - Threading/parallelization</p>"},{"location":"architecture/architecture/#embedded-use-cases","title":"Embedded Use Cases","text":"<p>The <code>no_std</code> design enables use in: - Microcontrollers (ARM Cortex-M, RISC-V) - Real-time Operating Systems (RTOS) - Bare-metal environments - FPGA/ASIC soft processors - Bootloaders and firmware</p>"},{"location":"architecture/architecture/#memory-considerations","title":"Memory Considerations","text":"<p>In <code>no_std</code> environments: - Heap allocation requires a global allocator to be configured - Large images may exceed available RAM on constrained devices - Consider using smaller images or streaming processing - Future: Support for static allocation and external memory</p>"},{"location":"architecture/architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/architecture/#unit-tests","title":"Unit Tests","text":"<ul> <li>Located inline with source code using <code>#[cfg(test)]</code></li> <li>Test coverage includes:</li> <li>Matrix creation and initialization</li> <li>Pixel access (get/set)</li> <li>Boundary conditions</li> <li>Error handling</li> </ul>"},{"location":"architecture/architecture/#doc-tests","title":"Doc Tests","text":"<ul> <li>Embedded in documentation comments</li> <li>Ensures examples in docs remain valid</li> <li>Run automatically with <code>cargo test</code></li> </ul>"},{"location":"architecture/architecture/#integration-tests","title":"Integration Tests","text":"<ul> <li>Examples serve as integration tests</li> <li>Real-world usage patterns</li> </ul>"},{"location":"architecture/architecture/#future-architecture-plans","title":"Future Architecture Plans","text":""},{"location":"architecture/architecture/#planned-modules","title":"Planned Modules","text":"<ol> <li><code>color.rs</code> - Color space conversions (RGB \u2194 HSV, LAB, YUV) - <code>no_std</code> compatible</li> <li><code>transform.rs</code> - Geometric transformations (resize, rotate, crop) - <code>no_std</code> compatible</li> <li><code>filter.rs</code> - Image filtering (blur, sharpen, edge detection) - <code>no_std</code> compatible</li> <li><code>features.rs</code> - Feature detection and extraction - <code>no_std</code> compatible</li> <li><code>codec/</code> - Additional image format support (PNG, BMP, TIFF) - requires <code>std</code> feature</li> <li><code>hw/</code> - Hardware accelerator interfaces for embedded systems - <code>no_std</code> compatible</li> </ol>"},{"location":"architecture/architecture/#trait-system","title":"Trait System","text":"<p>Future implementation of traits for polymorphism: <pre><code>pub trait ImageMatrix {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn channels(&amp;self) -&gt; usize;\n}\n\npub trait ImageReader {\n    fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Matrix3, ImageError&gt;;\n}\n\npub trait ImageWriter {\n    fn write&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;(), ImageError&gt;;\n}\n</code></pre></p>"},{"location":"architecture/architecture/#generic-matrix-types","title":"Generic Matrix Types","text":"<p>Potential expansion to support different channel counts and data types: - <code>Matrix&lt;T, C&gt;</code> - Generic over data type and channel count - <code>Matrix1&lt;T&gt;</code> - Single channel (grayscale) - <code>Matrix3&lt;T&gt;</code> - Three channels (RGB) - <code>Matrix4&lt;T&gt;</code> - Four channels (RGBA)</p>"},{"location":"architecture/architecture/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>When adding new features: 1. Follow existing module organization patterns 2. Design for <code>no_std</code> first - use <code>core</code> and <code>alloc</code> when possible 3. Add comprehensive tests (test with and without <code>std</code> feature) 4. Document all public APIs with examples 5. Consider performance implications, especially for embedded systems 6. Maintain memory safety without unsafe code (unless absolutely necessary) 7. Use feature flags appropriately (<code>std</code> for I/O, keep core logic <code>no_std</code>) 8. Update this architecture document</p>"},{"location":"architecture/architecture/#testing-strategy-for-no_std","title":"Testing Strategy for <code>no_std</code>","text":"<p>When testing <code>no_std</code> compatibility: <pre><code># Build without std\ncargo build --no-default-features\n\n# Build with std\ncargo build --features std\n\n# Run tests (requires std for test framework)\ncargo test\n</code></pre></p>"},{"location":"architecture/architecture/#version-history","title":"Version History","text":"<ul> <li>v0.1.0 - Initial release with <code>no_std</code> support, JPEG reading (with <code>std</code> feature), and Matrix3 support</li> </ul>"},{"location":"architecture/embedded/","title":"Embedded Systems Guide for CV Rusty","text":"<p>This guide explains how to use CV Rusty in embedded and <code>no_std</code> environments.</p>"},{"location":"architecture/embedded/#overview","title":"Overview","text":"<p>CV Rusty is designed to work in resource-constrained environments without the Rust standard library. The core functionality only requires the <code>alloc</code> crate for heap allocations.</p>"},{"location":"architecture/embedded/#requirements","title":"Requirements","text":""},{"location":"architecture/embedded/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Rust Edition: 2021 or later</li> <li>Memory: Heap allocator (<code>alloc</code> crate)</li> <li>No standard library: Works with <code>#![no_std]</code></li> </ul>"},{"location":"architecture/embedded/#memory-usage","title":"Memory Usage","text":"<p>For a <code>Matrix3</code> image, the memory requirements are: <pre><code>Memory = width \u00d7 height \u00d7 3 bytes + struct overhead (~24 bytes)\n</code></pre></p> <p>Examples: - 320\u00d7240 image: ~230 KB - 640\u00d7480 image: ~921 KB - 160\u00d7120 image: ~57 KB - 80\u00d760 image: ~14 KB</p>"},{"location":"architecture/embedded/#setup","title":"Setup","text":""},{"location":"architecture/embedded/#1-configure-cargotoml","title":"1. Configure Cargo.toml","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n\n# You'll need a global allocator for embedded systems\n# Choose one appropriate for your platform:\nembedded-alloc = \"0.5\"  # For simple embedded allocators\n</code></pre>"},{"location":"architecture/embedded/#2-configure-your-main-file","title":"2. Configure Your Main File","text":"<pre><code>#![no_std]\n#![no_main]\n\n// Import alloc for heap allocations\nextern crate alloc;\n\n// Set up a global allocator (example using embedded-alloc)\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n// Initialize the heap in your main/init function\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024; // 64 KB heap\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"architecture/embedded/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/embedded/#1-creating-images-from-sensor-data","title":"1. Creating Images from Sensor Data","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn capture_from_camera(width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n\n    // Read from camera sensor (pseudo-code)\n    for y in 0..height {\n        for x in 0..width {\n            let (r, g, b) = read_pixel_from_sensor(x, y);\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    image\n}\n</code></pre>"},{"location":"architecture/embedded/#2-processing-images-in-place","title":"2. Processing Images In-Place","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    let data = image.data_mut();\n\n    for pixel in data.iter_mut() {\n        let new_val = (*pixel as f32 * factor).min(255.0) as u8;\n        *pixel = new_val;\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#3-sending-to-display-via-spi","title":"3. Sending to Display via SPI","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn send_to_display(image: &amp;Matrix3, spi: &amp;mut SpiInterface) {\n    // Get raw RGB data\n    let data = image.data();\n\n    // Send to display in chunks to avoid large stack usage\n    const CHUNK_SIZE: usize = 256;\n    for chunk in data.chunks(CHUNK_SIZE) {\n        spi.write(chunk).ok();\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#4-low-memory-streaming-processing","title":"4. Low-Memory Streaming Processing","text":"<p>For very constrained systems, process images in chunks:</p> <pre><code>use cv_rusty::Matrix3;\n\nfn process_image_rows(width: usize, total_height: usize) {\n    // Process 10 rows at a time\n    const ROWS_PER_BATCH: usize = 10;\n\n    for start_row in (0..total_height).step_by(ROWS_PER_BATCH) {\n        let rows = ROWS_PER_BATCH.min(total_height - start_row);\n        let mut batch = Matrix3::zeros(width, rows);\n\n        // Fill batch from sensor\n        for y in 0..rows {\n            for x in 0..width {\n                let (r, g, b) = read_pixel_from_sensor(x, start_row + y);\n                batch.set_pixel(x, y, r, g, b);\n            }\n        }\n\n        // Process this batch\n        process_batch(&amp;mut batch);\n\n        // Send to output\n        output_batch(&amp;batch);\n    }\n}\n\nfn process_batch(batch: &amp;mut Matrix3) {\n    // Apply your image processing here\n}\n\nfn output_batch(batch: &amp;Matrix3) {\n    // Send to display or storage\n}\n</code></pre>"},{"location":"architecture/embedded/#platform-specific-examples","title":"Platform-Specific Examples","text":""},{"location":"architecture/embedded/#arm-cortex-m-stm32-nrf52-etc","title":"ARM Cortex-M (STM32, nRF52, etc.)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 32 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Initialize peripherals (camera, display, etc.)\n    let mut camera = init_camera();\n    let mut display = init_display();\n\n    loop {\n        // Capture small image (80x60 = ~14KB)\n        let image = capture_image(&amp;mut camera, 80, 60);\n\n        // Process image\n        let processed = apply_filters(&amp;image);\n\n        // Display result\n        send_to_display(&amp;processed, &amp;mut display);\n    }\n}\n\nfn capture_image(camera: &amp;mut Camera, width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n    // Capture logic...\n    image\n}\n\nfn apply_filters(image: &amp;Matrix3) -&gt; Matrix3 {\n    // Clone and process\n    let mut result = image.clone();\n    // Apply your filters...\n    result\n}\n</code></pre>"},{"location":"architecture/embedded/#esp32-embedded-rust","title":"ESP32 (Embedded Rust)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse esp_backtrace as _;\nuse esp_println::println;\nuse esp_alloc as _;\nuse cv_rusty::Matrix3;\n\n#[entry]\nfn main() -&gt; ! {\n    // ESP32 provides its own allocator\n    esp_alloc::heap_allocator!(72 * 1024); // 72 KB heap\n\n    println!(\"CV Rusty on ESP32\");\n\n    // ESP32-CAM can handle larger images (up to 640x480 on ESP32-S3)\n    let image = Matrix3::zeros(320, 240);\n    println!(\"Created {}x{} image\", image.width(), image.height());\n\n    loop {\n        // Process images from ESP32-CAM\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#risc-v","title":"RISC-V","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse riscv_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Your RISC-V application\n    let image = Matrix3::zeros(160, 120);\n\n    loop {\n        // Process images\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"architecture/embedded/#1-stack-overflow","title":"1. Stack Overflow","text":"<p>Problem: Creating large images on the stack <pre><code>// DON'T: This might overflow the stack\nlet image = Matrix3::zeros(640, 480); // ~921 KB allocated\n</code></pre></p> <p>Solution: This is already safe! <code>Matrix3</code> uses <code>Vec</code> internally, which allocates on the heap.</p>"},{"location":"architecture/embedded/#2-heap-exhaustion","title":"2. Heap Exhaustion","text":"<p>Problem: Not enough heap space <pre><code>// Might fail if heap is too small\nlet image = Matrix3::zeros(640, 480); // Needs ~921 KB\n</code></pre></p> <p>Solution: Either increase heap size or use smaller images <pre><code>// Use smaller images for constrained devices\nlet image = Matrix3::zeros(160, 120); // Only ~57 KB\n\n// Or process in chunks (see streaming example above)\n</code></pre></p>"},{"location":"architecture/embedded/#3-missing-allocator","title":"3. Missing Allocator","text":"<p>Problem: Linker error about missing <code>__rust_alloc</code></p> <p>Solution: Always configure a global allocator: <pre><code>use embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n</code></pre></p>"},{"location":"architecture/embedded/#4-debug-formatting","title":"4. Debug Formatting","text":"<p>Problem: Using <code>println!</code> or <code>format!</code> in <code>no_std</code></p> <p>Solution: Use platform-specific printing (e.g., <code>defmt</code>, <code>esp_println</code>, or semihosting) <pre><code>// Instead of println!, use platform-specific macros\nuse defmt::info;\ninfo!(\"Image size: {}x{}\", image.width(), image.height());\n</code></pre></p>"},{"location":"architecture/embedded/#memory-optimization-tips","title":"Memory Optimization Tips","text":""},{"location":"architecture/embedded/#1-reuse-image-buffers","title":"1. Reuse Image Buffers","text":"<pre><code>// Keep one image buffer and reuse it\nstatic mut IMAGE_BUFFER: Option&lt;Matrix3&gt; = None;\n\nfn get_image_buffer(width: usize, height: usize) -&gt; &amp;'static mut Matrix3 {\n    unsafe {\n        if IMAGE_BUFFER.is_none() {\n            IMAGE_BUFFER = Some(Matrix3::zeros(width, height));\n        }\n        IMAGE_BUFFER.as_mut().unwrap()\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#2-in-place-operations","title":"2. In-Place Operations","text":"<pre><code>// Modify the image data directly instead of creating new images\nfn process_inplace(image: &amp;mut Matrix3) {\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                // Process and write back\n                let new_r = (r as u16 * 2).min(255) as u8;\n                image.set_pixel(x, y, new_r, g, b);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#3-use-smaller-color-depths","title":"3. Use Smaller Color Depths","text":"<p>For very constrained systems, consider: - Downsampling images before processing - Using grayscale by keeping only one channel - Processing regions of interest (ROI) instead of full images</p> <pre><code>// Extract a region of interest\nfn extract_roi(src: &amp;Matrix3, x: usize, y: usize, w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"architecture/embedded/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/embedded/#typical-performance-arm-cortex-m4-80-mhz","title":"Typical Performance (ARM Cortex-M4 @ 80 MHz)","text":"<ul> <li>Creating 160\u00d7120 image: ~1 ms</li> <li>Pixel access: ~10 ns per pixel</li> <li>Full image iteration: ~5-10 ms for 160\u00d7120</li> </ul>"},{"location":"architecture/embedded/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Batch Operations: Process multiple pixels at once</li> <li>Cache Locality: Access pixels in row-major order</li> <li>Minimize Allocations: Reuse buffers when possible</li> <li>Direct Data Access: Use <code>data()</code> and <code>data_mut()</code> for bulk operations</li> </ol>"},{"location":"architecture/embedded/#testing-on-host-system","title":"Testing on Host System","text":"<p>You can test your embedded code on your development machine:</p> <pre><code># Build for embedded target\ncargo build --target thumbv7em-none-eabihf --no-default-features\n\n# Test on host (with std for test framework)\ncargo test\n</code></pre>"},{"location":"architecture/embedded/#integration-with-hardware-accelerators","title":"Integration with Hardware Accelerators","text":"<p>Many embedded systems have hardware acceleration for image processing:</p> <pre><code>// Example: Offload operations to DMA or GPU\nfn hardware_accelerated_copy(image: &amp;Matrix3, hw_buffer: &amp;mut [u8]) {\n    let data = image.data();\n\n    // Use DMA to copy data\n    dma_transfer(data, hw_buffer);\n\n    // Trigger hardware processor\n    trigger_hw_processor();\n}\n</code></pre>"},{"location":"architecture/embedded/#additional-resources","title":"Additional Resources","text":"<ul> <li>Embedded Rust Book</li> <li>rust-embedded/awesome-embedded-rust</li> <li>Allocators for embedded systems</li> </ul>"},{"location":"architecture/embedded/#support","title":"Support","text":"<p>For questions about using CV Rusty in embedded systems, please: 1. Check the examples in <code>examples/no_std_example.rs</code> 2. Review this guide 3. Open an issue on GitHub with your platform details</p>"},{"location":"architecture/embedded/#license","title":"License","text":"<p>Same as the main CV Rusty library (MIT).</p>"},{"location":"changelogs/changelog-color-features/","title":"Color Space Conversion Features - Change Log","text":""},{"location":"changelogs/changelog-color-features/#new-features-added","title":"New Features Added","text":""},{"location":"changelogs/changelog-color-features/#1-single-channel-matrix-matrix1","title":"1. Single-Channel Matrix (Matrix1)","text":"<p>Added a new <code>Matrix1</code> struct for representing grayscale/single-channel images:</p> <ul> <li>Struct: <code>Matrix1</code> - Single-channel matrix for grayscale image data</li> <li>Methods:</li> <li><code>new(width, height, data)</code> - Create from raw grayscale data</li> <li><code>zeros(width, height)</code> - Create zero-initialized matrix</li> <li><code>get_pixel(x, y)</code> - Get pixel value at location</li> <li><code>set_pixel(x, y, value)</code> - Set pixel value at location</li> <li><code>width()</code>, <code>height()</code>, <code>dimensions()</code> - Get matrix dimensions</li> <li><code>data()</code>, <code>data_mut()</code> - Access raw pixel data</li> <li><code>into_raw()</code> - Consume matrix and return raw data</li> </ul>"},{"location":"changelogs/changelog-color-features/#2-rgb-to-grayscale-conversion","title":"2. RGB to Grayscale Conversion","text":"<p>Added multiple methods for converting RGB images to grayscale:</p> <p>Methods on Matrix3: - <code>to_grayscale()</code> - Default luminosity method (recommended) - <code>to_grayscale_average()</code> - Simple average method - <code>to_grayscale_lightness()</code> - Lightness (midpoint) method - <code>to_grayscale_with_method(GrayscaleMethod)</code> - Specify conversion method</p> <p>Conversion Algorithms: - Luminosity: <code>0.299*R + 0.587*G + 0.114*B</code> - Accounts for human perception - Average: <code>(R + G + B) / 3</code> - Simple arithmetic mean - Lightness: <code>(max(R,G,B) + min(R,G,B)) / 2</code> - Midpoint of range</p> <p>Enum: <code>GrayscaleMethod</code> with variants: - <code>Luminosity</code> - <code>Average</code> - <code>Lightness</code></p>"},{"location":"changelogs/changelog-color-features/#3-rgb-hsv-color-space-conversion","title":"3. RGB \u2194 HSV Color Space Conversion","text":"<p>Added functions for converting between RGB and HSV color spaces:</p> <ul> <li><code>rgb_to_hsv(r: u8, g: u8, b: u8) -&gt; (f32, f32, f32)</code></li> <li>Input: RGB values (0-255)</li> <li> <p>Output: (hue in degrees 0-360\u00b0, saturation 0.0-1.0, value 0.0-1.0)</p> </li> <li> <p><code>hsv_to_rgb(h: f32, s: f32, v: f32) -&gt; (u8, u8, u8)</code></p> </li> <li>Input: HSV (hue 0-360\u00b0, saturation 0.0-1.0, value 0.0-1.0)</li> <li>Output: RGB values (0-255)</li> </ul>"},{"location":"changelogs/changelog-color-features/#4-rgb-hsl-color-space-conversion","title":"4. RGB \u2194 HSL Color Space Conversion","text":"<p>Added functions for converting between RGB and HSL color spaces:</p> <ul> <li><code>rgb_to_hsl(r: u8, g: u8, b: u8) -&gt; (f32, f32, f32)</code></li> <li>Input: RGB values (0-255)</li> <li> <p>Output: (hue in degrees 0-360\u00b0, saturation 0.0-1.0, lightness 0.0-1.0)</p> </li> <li> <p><code>hsl_to_rgb(h: f32, s: f32, l: f32) -&gt; (u8, u8, u8)</code></p> </li> <li>Input: HSL (hue 0-360\u00b0, saturation 0.0-1.0, lightness 0.0-1.0)</li> <li>Output: RGB values (0-255)</li> </ul>"},{"location":"changelogs/changelog-color-features/#new-module","title":"New Module","text":""},{"location":"changelogs/changelog-color-features/#color-module","title":"<code>color</code> Module","text":"<p>Created a new <code>color</code> module (<code>src/color.rs</code>) containing: - Color space conversion functions - Grayscale conversion implementations - Comprehensive test suite for all conversions</p> <p>All color conversion functionality is <code>no_std</code> compatible and only requires the <code>alloc</code> crate.</p>"},{"location":"changelogs/changelog-color-features/#public-api-exports","title":"Public API Exports","text":"<p>Updated <code>lib.rs</code> to export: - <code>Matrix1</code> - Single-channel matrix struct - <code>GrayscaleMethod</code> - Enum for grayscale conversion methods - <code>rgb_to_hsv</code>, <code>hsv_to_rgb</code> - HSV conversion functions - <code>rgb_to_hsl</code>, <code>hsl_to_rgb</code> - HSL conversion functions</p>"},{"location":"changelogs/changelog-color-features/#examples","title":"Examples","text":"<p>Added new example: <code>color_conversion_example.rs</code></p> <p>Demonstrates: - RGB to grayscale conversion with all three methods - RGB \u2194 HSV conversions - RGB \u2194 HSL conversions - Working with Matrix1 (grayscale images) - Roundtrip conversion tests</p> <p>Run with: <pre><code>cargo run --example color_conversion_example\n</code></pre></p>"},{"location":"changelogs/changelog-color-features/#tests","title":"Tests","text":"<p>Added comprehensive test coverage: - Matrix1 creation and pixel access tests - Grayscale conversion tests for all three methods - RGB \u2194 HSV roundtrip conversion tests - RGB \u2194 HSL roundtrip conversion tests - Pure color conversion accuracy tests - Edge case handling</p> <p>All 20 unit tests pass successfully.</p>"},{"location":"changelogs/changelog-color-features/#documentation","title":"Documentation","text":"<p>Updated documentation: - Added inline documentation for all new functions and methods - Updated README.md with usage examples - Added doc tests that verify code examples compile and run correctly - Documented all color space conversion formulas</p>"},{"location":"changelogs/changelog-color-features/#backward-compatibility","title":"Backward Compatibility","text":"<p>All changes are fully backward compatible: - No breaking changes to existing API - Matrix3 functionality unchanged - All existing tests continue to pass</p>"},{"location":"changelogs/changelog-color-features/#performance-notes","title":"Performance Notes","text":"<ul> <li>Color conversions use <code>f32</code> for intermediate calculations</li> <li>Grayscale conversions are optimized for performance</li> <li>No unnecessary allocations in conversion functions</li> <li>All operations are <code>no_std</code> compatible</li> </ul>"},{"location":"changelogs/changelog-color-features/#use-cases","title":"Use Cases","text":"<p>These features enable: 1. Image preprocessing - Convert color images to grayscale for algorithms 2. Color manipulation - Adjust hue, saturation, brightness in HSV/HSL space 3. Computer vision - Many CV algorithms work on grayscale images 4. Embedded systems - Reduce memory usage with single-channel images 5. Display applications - Convert between color spaces for different displays 6. Image analysis - Separate color components for analysis</p>"},{"location":"changelogs/changelog-color-features/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions: - YUV/YCbCr color space conversions - LAB color space support - Batch conversion operations for performance - SIMD-optimized conversions</p>"},{"location":"guides/color-conversion-guide/","title":"Color Conversion Quick Reference Guide","text":"<p>This guide provides quick examples and reference information for using the color space conversion features in cv-rusty.</p>"},{"location":"guides/color-conversion-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Matrix Types</li> <li>RGB to Grayscale</li> <li>RGB \u2194 HSV Conversions</li> <li>RGB \u2194 HSL Conversions</li> <li>Practical Examples</li> <li>Performance Tips</li> </ol>"},{"location":"guides/color-conversion-guide/#matrix-types","title":"Matrix Types","text":""},{"location":"guides/color-conversion-guide/#matrix3-rgb-images","title":"Matrix3 - RGB Images","text":"<p>Three-channel matrix for RGB color images:</p> <pre><code>use cv_rusty::Matrix3;\n\n// Create a 640x480 RGB image\nlet mut rgb_image = Matrix3::zeros(640, 480);\n\n// Set a red pixel at (100, 50)\nrgb_image.set_pixel(100, 50, 255, 0, 0);\n\n// Get pixel value\nif let Some((r, g, b)) = rgb_image.get_pixel(100, 50) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#matrix1-grayscale-images","title":"Matrix1 - Grayscale Images","text":"<p>Single-channel matrix for grayscale images:</p> <pre><code>use cv_rusty::Matrix1;\n\n// Create a 640x480 grayscale image\nlet mut gray_image = Matrix1::zeros(640, 480);\n\n// Set a pixel value\ngray_image.set_pixel(100, 50, 128);\n\n// Get pixel value\nif let Some(value) = gray_image.get_pixel(100, 50) {\n    println!(\"Gray value: {}\", value);\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#rgb-to-grayscale","title":"RGB to Grayscale","text":""},{"location":"guides/color-conversion-guide/#three-conversion-methods","title":"Three Conversion Methods","text":""},{"location":"guides/color-conversion-guide/#1-luminosity-method-recommended","title":"1. Luminosity Method (Recommended)","text":"<p>Accounts for human perception - green appears brightest to our eyes.</p> <pre><code>use cv_rusty::Matrix3;\n\nlet rgb_image = Matrix3::zeros(640, 480);\nlet gray = rgb_image.to_grayscale();\n</code></pre> <p>Formula: <code>0.299*R + 0.587*G + 0.114*B</code></p> <p>Best for: General purpose, photography, human-viewed images</p>"},{"location":"guides/color-conversion-guide/#2-average-method","title":"2. Average Method","text":"<p>Simple arithmetic mean of RGB channels.</p> <pre><code>let gray = rgb_image.to_grayscale_average();\n</code></pre> <p>Formula: <code>(R + G + B) / 3</code></p> <p>Best for: Quick conversions, when perceptual accuracy isn't critical</p>"},{"location":"guides/color-conversion-guide/#3-lightness-method","title":"3. Lightness Method","text":"<p>Midpoint between the maximum and minimum RGB values.</p> <pre><code>let gray = rgb_image.to_grayscale_lightness();\n</code></pre> <p>Formula: <code>(max(R,G,B) + min(R,G,B)) / 2</code></p> <p>Best for: Preserving color range information</p>"},{"location":"guides/color-conversion-guide/#using-method-parameter","title":"Using Method Parameter","text":"<pre><code>use cv_rusty::{Matrix3, GrayscaleMethod};\n\nlet rgb_image = Matrix3::zeros(640, 480);\n\n// Choose method explicitly\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Luminosity);\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Average);\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Lightness);\n</code></pre>"},{"location":"guides/color-conversion-guide/#comparison-of-methods","title":"Comparison of Methods","text":"Color RGB Luminosity Average Lightness Red (255, 0, 0) 76 85 127 Green (0, 255, 0) 149 85 127 Blue (0, 0, 255) 29 85 127 White (255, 255, 255) 255 255 255"},{"location":"guides/color-conversion-guide/#rgb-hsv-conversions","title":"RGB \u2194 HSV Conversions","text":"<p>HSV (Hue, Saturation, Value) is useful for color-based segmentation and manipulation.</p>"},{"location":"guides/color-conversion-guide/#rgb-to-hsv","title":"RGB to HSV","text":"<pre><code>use cv_rusty::rgb_to_hsv;\n\nlet (h, s, v) = rgb_to_hsv(255, 0, 0); // Red\n// h = 0.0\u00b0 (hue in degrees, 0-360)\n// s = 1.0 (saturation, 0.0-1.0)\n// v = 1.0 (value/brightness, 0.0-1.0)\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsv-to-rgb","title":"HSV to RGB","text":"<pre><code>use cv_rusty::hsv_to_rgb;\n\nlet (r, g, b) = hsv_to_rgb(0.0, 1.0, 1.0); // Red\n// r = 255, g = 0, b = 0\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsv-color-wheel","title":"HSV Color Wheel","text":"<ul> <li>Hue (H): Color type</li> <li>0\u00b0 = Red</li> <li>60\u00b0 = Yellow</li> <li>120\u00b0 = Green</li> <li>180\u00b0 = Cyan</li> <li>240\u00b0 = Blue</li> <li>300\u00b0 = Magenta</li> <li> <p>360\u00b0 = Red (wraps around)</p> </li> <li> <p>Saturation (S): Color intensity</p> </li> <li>0.0 = Gray (no color)</li> <li> <p>1.0 = Pure color</p> </li> <li> <p>Value (V): Brightness</p> </li> <li>0.0 = Black</li> <li>1.0 = Full brightness</li> </ul>"},{"location":"guides/color-conversion-guide/#common-hsv-operations","title":"Common HSV Operations","text":""},{"location":"guides/color-conversion-guide/#make-color-brighterdarker","title":"Make color brighter/darker","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet brighter = hsv_to_rgb(h, s, v * 1.5);  // 50% brighter\nlet darker = hsv_to_rgb(h, s, v * 0.5);    // 50% darker\n</code></pre>"},{"location":"guides/color-conversion-guide/#increasedecrease-saturation","title":"Increase/decrease saturation","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet vibrant = hsv_to_rgb(h, s * 1.5, v);   // More saturated\nlet muted = hsv_to_rgb(h, s * 0.5, v);     // Less saturated\n</code></pre>"},{"location":"guides/color-conversion-guide/#shift-hue-change-color","title":"Shift hue (change color)","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet shifted = hsv_to_rgb((h + 180.0) % 360.0, s, v); // Opposite color\n</code></pre>"},{"location":"guides/color-conversion-guide/#rgb-hsl-conversions","title":"RGB \u2194 HSL Conversions","text":"<p>HSL (Hue, Saturation, Lightness) is useful for color manipulation and adjustments.</p>"},{"location":"guides/color-conversion-guide/#rgb-to-hsl","title":"RGB to HSL","text":"<pre><code>use cv_rusty::rgb_to_hsl;\n\nlet (h, s, l) = rgb_to_hsl(255, 0, 0); // Red\n// h = 0.0\u00b0 (hue in degrees, 0-360)\n// s = 1.0 (saturation, 0.0-1.0)\n// l = 0.5 (lightness, 0.0-1.0)\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsl-to-rgb","title":"HSL to RGB","text":"<pre><code>use cv_rusty::hsl_to_rgb;\n\nlet (r, g, b) = hsl_to_rgb(0.0, 1.0, 0.5); // Red\n// r = 255, g = 0, b = 0\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsl-vs-hsv","title":"HSL vs HSV","text":"<ul> <li>HSL Lightness: 0.0 = black, 0.5 = pure color, 1.0 = white</li> <li>HSV Value: 0.0 = black, 1.0 = pure color (never white at full saturation)</li> </ul> <p>Use HSL when: You need symmetric lightness control (pure color in middle) Use HSV when: You need intuitive brightness control (brighter = higher value)</p>"},{"location":"guides/color-conversion-guide/#common-hsl-operations","title":"Common HSL Operations","text":""},{"location":"guides/color-conversion-guide/#lightendarken-color","title":"Lighten/darken color","text":"<pre><code>let (h, s, l) = rgb_to_hsl(r, g, b);\nlet lighter = hsl_to_rgb(h, s, l * 1.2);   // 20% lighter\nlet darker = hsl_to_rgb(h, s, l * 0.8);    // 20% darker\n</code></pre>"},{"location":"guides/color-conversion-guide/#create-tints-and-shades","title":"Create tints and shades","text":"<pre><code>let (h, s, l) = rgb_to_hsl(r, g, b);\nlet tint = hsl_to_rgb(h, s, (l + 1.0) / 2.0);  // Mix with white\nlet shade = hsl_to_rgb(h, s, l / 2.0);          // Mix with black\n</code></pre>"},{"location":"guides/color-conversion-guide/#practical-examples","title":"Practical Examples","text":""},{"location":"guides/color-conversion-guide/#example-1-color-based-object-detection","title":"Example 1: Color-Based Object Detection","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsv};\n\nfn detect_red_pixels(image: &amp;Matrix3) -&gt; Vec&lt;(usize, usize)&gt; {\n    let mut red_pixels = Vec::new();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n\n                // Red is at 0\u00b0 and 360\u00b0 (wraps around)\n                if (h &lt; 20.0 || h &gt; 340.0) &amp;&amp; s &gt; 0.5 &amp;&amp; v &gt; 0.5 {\n                    red_pixels.push((x, y));\n                }\n            }\n        }\n    }\n\n    red_pixels\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-2-automatic-white-balance","title":"Example 2: Automatic White Balance","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsl, hsl_to_rgb};\n\nfn auto_white_balance(image: &amp;Matrix3) -&gt; Matrix3 {\n    let mut result = image.clone();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, l) = rgb_to_hsl(r, g, b);\n                // Reduce saturation for whites\n                let adjusted_s = if l &gt; 0.8 { s * 0.5 } else { s };\n                let (new_r, new_g, new_b) = hsl_to_rgb(h, adjusted_s, l);\n                result.set_pixel(x, y, new_r, new_g, new_b);\n            }\n        }\n    }\n\n    result\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-3-contrast-enhancement","title":"Example 3: Contrast Enhancement","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsv, hsv_to_rgb};\n\nfn enhance_contrast(image: &amp;Matrix3, factor: f32) -&gt; Matrix3 {\n    let mut result = image.clone();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n                // Enhance value with gamma correction\n                let enhanced_v = v.powf(1.0 / factor).min(1.0);\n                let (new_r, new_g, new_b) = hsv_to_rgb(h, s, enhanced_v);\n                result.set_pixel(x, y, new_r, new_g, new_b);\n            }\n        }\n    }\n\n    result\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-4-edge-detection-preprocessing","title":"Example 4: Edge Detection Preprocessing","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn prepare_for_edge_detection(image: &amp;Matrix3) -&gt; Matrix1 {\n    // Convert to grayscale using luminosity method\n    // This is optimal for edge detection as it preserves\n    // perceptual brightness differences\n    image.to_grayscale()\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-5-color-segmentation","title":"Example 5: Color Segmentation","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, rgb_to_hsv};\n\nfn segment_by_hue(image: &amp;Matrix3, target_hue: f32, tolerance: f32) -&gt; Matrix1 {\n    let mut mask = Matrix1::zeros(image.width(), image.height());\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n\n                // Check if hue is within tolerance\n                let hue_diff = (h - target_hue).abs();\n                let in_range = hue_diff &lt; tolerance || hue_diff &gt; (360.0 - tolerance);\n\n                if in_range &amp;&amp; s &gt; 0.3 &amp;&amp; v &gt; 0.3 {\n                    mask.set_pixel(x, y, 255);\n                } else {\n                    mask.set_pixel(x, y, 0);\n                }\n            }\n        }\n    }\n\n    mask\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/color-conversion-guide/#1-batch-conversions","title":"1. Batch Conversions","text":"<p>When converting many pixels, iterate directly over the image data:</p> <pre><code>// Efficient: Direct iteration\nfor y in 0..image.height() {\n    for x in 0..image.width() {\n        if let Some((r, g, b)) = image.get_pixel(x, y) {\n            let (h, s, v) = rgb_to_hsv(r, g, b);\n            // Process...\n        }\n    }\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#2-use-appropriate-grayscale-method","title":"2. Use Appropriate Grayscale Method","text":"<ul> <li>Luminosity: Slower (uses floating point), most accurate</li> <li>Average: Fast (integer math), good approximation</li> <li>Lightness: Fastest (min/max only), least accurate</li> </ul>"},{"location":"guides/color-conversion-guide/#3-avoid-repeated-conversions","title":"3. Avoid Repeated Conversions","text":"<pre><code>// Bad: Converting back and forth\nlet (h, s, v) = rgb_to_hsv(r, g, b);\nlet (r2, g2, b2) = hsv_to_rgb(h, s, v);\n\n// Good: Do all HSV operations together\nlet (h, s, v) = rgb_to_hsv(r, g, b);\nlet adjusted_v = v * 1.5;\nlet adjusted_s = s * 0.8;\nlet (r2, g2, b2) = hsv_to_rgb(h, adjusted_s, adjusted_v);\n</code></pre>"},{"location":"guides/color-conversion-guide/#4-memory-efficiency","title":"4. Memory Efficiency","text":"<p>Use <code>Matrix1</code> for grayscale images to save 2/3 memory:</p> <pre><code>// Matrix3: 640x480x3 = 921,600 bytes\nlet rgb = Matrix3::zeros(640, 480);\n\n// Matrix1: 640x480x1 = 307,200 bytes\nlet gray = Matrix1::zeros(640, 480);\n</code></pre>"},{"location":"guides/color-conversion-guide/#5-no_std-compatibility","title":"5. no_std Compatibility","text":"<p>All color conversion functions work in <code>no_std</code> environments:</p> <pre><code>#![no_std]\n\nextern crate alloc;\nuse cv_rusty::{Matrix3, Matrix1, rgb_to_hsv};\n\n// Works in embedded systems!\n</code></pre>"},{"location":"guides/color-conversion-guide/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/color-conversion-guide/#1-hue-wraparound","title":"1. Hue Wraparound","text":"<p>Hue wraps around at 360\u00b0:</p> <pre><code>let h = 350.0;\nlet shifted = (h + 30.0) % 360.0; // = 20.0, not 380.0\n</code></pre>"},{"location":"guides/color-conversion-guide/#2-saturationvalue-clamping","title":"2. Saturation/Value Clamping","text":"<p>Always clamp S and V to [0.0, 1.0]:</p> <pre><code>let s = (s * 1.5).min(1.0).max(0.0);\nlet v = (v * 1.5).min(1.0).max(0.0);\n</code></pre>"},{"location":"guides/color-conversion-guide/#3-roundtrip-precision","title":"3. Roundtrip Precision","text":"<p>Expect minor differences due to rounding:</p> <pre><code>let original = (192, 64, 128);\nlet (h, s, v) = rgb_to_hsv(192, 64, 128);\nlet (r, g, b) = hsv_to_rgb(h, s, v);\n// (r, g, b) might be (192, 64, 127) or (192, 63, 128)\n// Difference is typically \u00b11 due to floating point conversion\n</code></pre>"},{"location":"guides/color-conversion-guide/#4-blackwhite-handling","title":"4. Black/White Handling","text":"<p>Black and white have undefined hue:</p> <pre><code>let (h, s, v) = rgb_to_hsv(0, 0, 0);     // h is 0.0, but meaningless\nlet (h, s, v) = rgb_to_hsv(255, 255, 255); // h is 0.0, s is 0.0\n</code></pre>"},{"location":"guides/color-conversion-guide/#further-reading","title":"Further Reading","text":"<ul> <li>HSV Color Space - Wikipedia</li> <li>Grayscale Conversion Algorithms</li> <li>Color Space Conversions</li> </ul>"},{"location":"guides/color-conversion-guide/#support","title":"Support","text":"<p>For issues, questions, or contributions, please visit: https://github.com/johnhalz/cv-rusty</p>"},{"location":"guides/convolution/","title":"Convolution Operations in CV Rusty","text":"<p>This guide covers the efficient convolution operations available in cv-rusty, including parallel processing support and performance optimization techniques.</p>"},{"location":"guides/convolution/#overview","title":"Overview","text":"<p>Convolution is a fundamental operation in image processing used for: - Blurring: Smoothing images and reducing noise - Edge Detection: Finding boundaries and features - Sharpening: Enhancing image details - Custom Effects: Embossing, motion blur, etc.</p> <p>CV Rusty provides a highly optimized convolution implementation with: - \u2705 Parallel processing support (automatic multi-threading) - \u2705 Multiple border handling modes - \u2705 Separable convolution for performance - \u2705 Built-in common kernels - \u2705 Custom kernel support - \u2705 <code>no_std</code> compatible</p>"},{"location":"guides/convolution/#quick-start","title":"Quick Start","text":"<pre><code>use cv_rusty::{read_jpeg, write_jpeg, Kernel, BorderMode};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load image\n    let image = read_jpeg(\"input.jpg\")?;\n\n    // Apply Gaussian blur\n    let kernel = Kernel::gaussian(5, 1.0);\n    let blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n    // Save result\n    write_jpeg(&amp;blurred, \"output.jpg\", 90)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/convolution/#built-in-kernels","title":"Built-in Kernels","text":""},{"location":"guides/convolution/#gaussian-blur","title":"Gaussian Blur","text":"<p>Smooth blur that preserves edges better than box blur.</p> <pre><code>// Create 5x5 Gaussian kernel with sigma=1.0\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// Larger kernel = stronger blur\nlet kernel = Kernel::gaussian(9, 2.0);\nlet very_blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre> <p>Parameters: - <code>size</code>: Kernel size (must be odd: 3, 5, 7, 9, etc.) - <code>sigma</code>: Standard deviation (controls blur strength)</p> <p>Guidelines: - <code>sigma \u2248 size/6</code> for good coverage - Larger sigma = stronger blur - Use separable convolution for kernels &gt; 5\u00d75</p>"},{"location":"guides/convolution/#box-blur","title":"Box Blur","text":"<p>Uniform averaging filter (faster but less smooth than Gaussian).</p> <pre><code>let kernel = Kernel::box_blur(5);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#sobel-edge-detection","title":"Sobel Edge Detection","text":"<p>Detects edges in horizontal or vertical directions.</p> <pre><code>// Detect horizontal edges\nlet sobel_x = Kernel::sobel_x();\nlet edges_x = image.convolve(&amp;sobel_x, BorderMode::Replicate);\n\n// Detect vertical edges\nlet sobel_y = Kernel::sobel_y();\nlet edges_y = image.convolve(&amp;sobel_y, BorderMode::Replicate);\n\n// Combine for gradient magnitude\nlet magnitude = combine_gradients(&amp;edges_x, &amp;edges_y);\n</code></pre> <p>Combine Gradients Example: <pre><code>fn combine_gradients(gx: &amp;Matrix3, gy: &amp;Matrix3) -&gt; Matrix3 {\n    let width = gx.width();\n    let height = gx.height();\n    let mut result_data = Vec::with_capacity(width * height * 3);\n\n    for y in 0..height {\n        for x in 0..width {\n            let (gx_r, gx_g, gx_b) = gx.get_pixel(x, y).unwrap();\n            let (gy_r, gy_g, gy_b) = gy.get_pixel(x, y).unwrap();\n\n            // Compute magnitude: sqrt(gx\u00b2 + gy\u00b2)\n            let mag_r = ((gx_r as f32).powi(2) + (gy_r as f32).powi(2)).sqrt();\n            let mag_g = ((gx_g as f32).powi(2) + (gy_g as f32).powi(2)).sqrt();\n            let mag_b = ((gx_b as f32).powi(2) + (gy_b as f32).powi(2)).sqrt();\n\n            result_data.push(mag_r.min(255.0) as u8);\n            result_data.push(mag_g.min(255.0) as u8);\n            result_data.push(mag_b.min(255.0) as u8);\n        }\n    }\n\n    Matrix3::new(width, height, result_data)\n}\n</code></pre></p>"},{"location":"guides/convolution/#laplacian","title":"Laplacian","text":"<p>Omnidirectional edge detection.</p> <pre><code>let kernel = Kernel::laplacian();\nlet edges = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#sharpen","title":"Sharpen","text":"<p>Enhances image details and edges.</p> <pre><code>let kernel = Kernel::sharpen();\nlet sharpened = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#custom-kernels","title":"Custom Kernels","text":"<p>Create your own convolution kernels:</p> <pre><code>// Emboss effect\nlet emboss = Kernel::new(3, 3, vec![\n    -2.0, -1.0,  0.0,\n    -1.0,  1.0,  1.0,\n     0.0,  1.0,  2.0,\n]);\nlet result = image.convolve(&amp;emboss, BorderMode::Replicate);\n\n// Strong edge detection\nlet edge = Kernel::new(3, 3, vec![\n    -1.0, -1.0, -1.0,\n    -1.0,  8.0, -1.0,\n    -1.0, -1.0, -1.0,\n]);\nlet edges = image.convolve(&amp;edge, BorderMode::Zero);\n\n// Custom blur\nlet custom_blur = Kernel::new(3, 3, vec![\n    1.0/16.0, 2.0/16.0, 1.0/16.0,\n    2.0/16.0, 4.0/16.0, 2.0/16.0,\n    1.0/16.0, 2.0/16.0, 1.0/16.0,\n]);\nlet blurred = image.convolve(&amp;custom_blur, BorderMode::Replicate);\n</code></pre> <p>Requirements: - Width and height must be odd (3, 5, 7, 9, etc.) - Data length must equal width \u00d7 height</p>"},{"location":"guides/convolution/#border-modes","title":"Border Modes","text":"<p>Control how pixels outside the image boundary are handled:</p>"},{"location":"guides/convolution/#bordermodereplicate-recommended","title":"BorderMode::Replicate (Recommended)","text":"<p>Replicates the edge pixels. Best for most cases.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: a a b c d e e e\n</code></pre></p>"},{"location":"guides/convolution/#bordermodezero","title":"BorderMode::Zero","text":"<p>Pads with zeros (black). Can create dark edges.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Zero);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: 0 0 a b c d e 0 0\n</code></pre></p>"},{"location":"guides/convolution/#bordermodereflect","title":"BorderMode::Reflect","text":"<p>Mirrors the image at the boundary. Good for seamless tiling.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Reflect);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: c b a b c d e d c\n</code></pre></p>"},{"location":"guides/convolution/#bordermodewrap","title":"BorderMode::Wrap","text":"<p>Wraps around to the opposite edge. For periodic patterns.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Wrap);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: d e a b c d e a b\n</code></pre></p>"},{"location":"guides/convolution/#separable-convolution","title":"Separable Convolution","text":"<p>For separable kernels (like Gaussian), use <code>convolve_separable()</code> for massive performance gains.</p>"},{"location":"guides/convolution/#why-separable","title":"Why Separable?","text":"<p>A 2D convolution with an N\u00d7N kernel requires N\u00b2 operations per pixel. A separable kernel can be decomposed into two 1D convolutions, requiring only 2N operations.</p> <p>Performance Gain: - 3\u00d73: 1.5\u00d7 faster - 5\u00d75: 2.5\u00d7 faster - 9\u00d79: 4.5\u00d7 faster - 15\u00d715: 7.5\u00d7 faster - 21\u00d721: 10.5\u00d7 faster</p>"},{"location":"guides/convolution/#usage","title":"Usage","text":"<pre><code>// Create 1D Gaussian kernel\nlet kernel_1d = create_gaussian_1d(9, 2.0);\n\n// Apply separable convolution (much faster!)\nlet blurred = image.convolve_separable(\n    &amp;kernel_1d,\n    &amp;kernel_1d,\n    BorderMode::Replicate\n);\n\n// Helper function to create 1D Gaussian\nfn create_gaussian_1d(size: usize, sigma: f32) -&gt; Vec&lt;f32&gt; {\n    assert!(size % 2 == 1);\n    let half = (size / 2) as i32;\n    let mut kernel = Vec::with_capacity(size);\n    let mut sum = 0.0;\n\n    for i in -half..=half {\n        let coeff = 1.0 / (core::f32::consts::TAU.sqrt() * sigma);\n        let exp = -(i as f32 * i as f32) / (2.0 * sigma * sigma);\n        let value = coeff * exp.exp();\n        kernel.push(value);\n        sum += value;\n    }\n\n    // Normalize\n    for value in &amp;mut kernel {\n        *value /= sum;\n    }\n\n    kernel\n}\n</code></pre>"},{"location":"guides/convolution/#when-to-use-separable-convolution","title":"When to Use Separable Convolution","text":"<p>\u2705 Use separable when: - Gaussian blur (always separable) - Box blur (always separable) - Large kernel sizes (&gt; 5\u00d75) - You care about performance</p> <p>\u274c Don't use separable for: - Sobel (not separable in practice) - Laplacian (not separable) - Custom non-separable kernels - Small kernels (3\u00d73) where overhead may not be worth it</p>"},{"location":"guides/convolution/#parallel-processing","title":"Parallel Processing","text":"<p>By default, convolution uses all available CPU cores via Rayon.</p>"},{"location":"guides/convolution/#enabledisable","title":"Enable/Disable","text":"<pre><code># Cargo.toml\n\n# Enable parallel processing (default)\n[dependencies]\ncv-rusty = \"0.2.0\"\n\n# Disable parallel processing\n[dependencies]\ncv-rusty = { version = \"0.2.0\", default-features = false, features = [\"std\"] }\n</code></pre>"},{"location":"guides/convolution/#performance-impact","title":"Performance Impact","text":"<p>On a 1920\u00d71080 image with a 9\u00d79 kernel: - Single-threaded: ~200ms - Multi-threaded (8 cores): ~30ms - Speedup: ~6.7\u00d7</p> <p>Guidelines: - Parallel is best for large images (&gt; 500\u00d7500) - Parallel is best for large kernels (&gt; 5\u00d75) - Small images may be faster single-threaded due to overhead - Benchmark your specific use case</p>"},{"location":"guides/convolution/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/convolution/#1-always-use-release-mode","title":"1. Always Use Release Mode","text":"<pre><code>cargo build --release\ncargo run --release --example convolution_benchmark\n</code></pre> <p>Debug mode can be 100\u00d7 slower than release mode!</p>"},{"location":"guides/convolution/#2-use-separable-convolution-for-large-kernels","title":"2. Use Separable Convolution for Large Kernels","text":"<pre><code>// \u274c Slow: O(n\u00b2) per pixel\nlet kernel = Kernel::gaussian(15, 3.0);\nlet result = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// \u2705 Fast: O(2n) per pixel\nlet kernel_1d = create_gaussian_1d(15, 3.0);\nlet result = image.convolve_separable(&amp;kernel_1d, &amp;kernel_1d, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#3-choose-appropriate-kernel-sizes","title":"3. Choose Appropriate Kernel Sizes","text":"<p>Larger kernels = stronger effect but slower:</p> Kernel Size Effect Strength Speed (relative) 3\u00d73 Minimal 1\u00d7 (fastest) 5\u00d75 Light 3\u00d7 7\u00d77 Medium 5\u00d7 9\u00d79 Strong 9\u00d7 15\u00d715 Very Strong 25\u00d7"},{"location":"guides/convolution/#4-reuse-kernels","title":"4. Reuse Kernels","text":"<pre><code>// \u274c Recreates kernel each time\nfor image in images {\n    let kernel = Kernel::gaussian(5, 1.0);\n    let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n}\n\n// \u2705 Reuse kernel\nlet kernel = Kernel::gaussian(5, 1.0);\nfor image in images {\n    let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n}\n</code></pre>"},{"location":"guides/convolution/#5-process-in-batches","title":"5. Process in Batches","text":"<p>For many images, use parallel iteration:</p> <pre><code>use rayon::prelude::*;\n\nlet results: Vec&lt;Matrix3&gt; = images\n    .par_iter()\n    .map(|img| img.convolve(&amp;kernel, BorderMode::Replicate))\n    .collect();\n</code></pre>"},{"location":"guides/convolution/#working-with-grayscale-images","title":"Working with Grayscale Images","text":"<p>Convolution works the same for <code>Matrix1</code> (grayscale):</p> <pre><code>use cv_rusty::{Matrix1, Kernel, BorderMode};\n\n// Convert to grayscale first\nlet gray = image.to_grayscale();\n\n// Apply convolution\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = gray.convolve(&amp;kernel, BorderMode::Replicate);\n\n// Grayscale is ~3\u00d7 faster than RGB (single channel)\n</code></pre>"},{"location":"guides/convolution/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/convolution/#blur-then-edge-detection","title":"Blur then Edge Detection","text":"<pre><code>// Reduce noise before edge detection\nlet kernel = Kernel::gaussian(3, 0.5);\nlet smoothed = image.convolve(&amp;kernel, BorderMode::Replicate);\n\nlet sobel_x = Kernel::sobel_x();\nlet edges = smoothed.convolve(&amp;sobel_x, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#unsharp-mask-advanced-sharpening","title":"Unsharp Mask (Advanced Sharpening)","text":"<pre><code>// 1. Create blurred version\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// 2. Subtract blurred from original (implement pixel-wise operations)\n// 3. Add difference back to original with weight\n</code></pre>"},{"location":"guides/convolution/#multi-scale-processing","title":"Multi-scale Processing","text":"<pre><code>// Apply different kernel sizes\nlet blur_small = image.convolve(&amp;Kernel::gaussian(3, 0.5), BorderMode::Replicate);\nlet blur_medium = image.convolve(&amp;Kernel::gaussian(5, 1.0), BorderMode::Replicate);\nlet blur_large = image.convolve(&amp;Kernel::gaussian(9, 2.0), BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#benchmarking","title":"Benchmarking","text":"<p>Run the benchmark example to test performance on your hardware:</p> <pre><code># With parallel processing\ncargo run --release --example convolution_benchmark\n\n# Without parallel processing\ncargo run --release --example convolution_benchmark --no-default-features --features std\n</code></pre> <p>Expected output: <pre><code>=== Convolution Performance Benchmark ===\n\nImage size: 1920x1080 (2073600 pixels)\n\u2713 Parallel processing ENABLED (using rayon)\n\n--- Small Kernel (3x3) ---\nSobel X              3x3:     8.45ms (2204 MOps/sec)\nSharpen              3x3:     8.32ms (2238 MOps/sec)\nLaplacian            3x3:     8.41ms (2214 MOps/sec)\n\n--- Medium Kernel (5x5) ---\nGaussian 5x5         5x5:    18.23ms (2553 MOps/sec)\nBox Blur 5x5         5x5:    17.89ms (2601 MOps/sec)\n\n--- Large Kernel (9x9) ---\nGaussian 9x9         9x9:    52.67ms (2848 MOps/sec)\nBox Blur 9x9         9x9:    51.34ms (2921 MOps/sec)\n\n--- Separable Convolution ---\nGaussian 5x5         5x1 + 1x5:     9.12ms (2281 MOps/sec, 2.5x speedup vs 2D)\nGaussian 9x9         9x1 + 1x9:    16.45ms (2532 MOps/sec, 4.5x speedup vs 2D)\nGaussian 15x15       15x1 + 1x15:   27.89ms (2236 MOps/sec, 7.5x speedup vs 2D)\n\nThroughput: 73.52 Mpixels/sec\n</code></pre></p>"},{"location":"guides/convolution/#no_std-support","title":"no_std Support","text":"<p>Convolution works in <code>no_std</code> environments:</p> <pre><code>#![no_std]\n\nextern crate alloc;\nuse alloc::vec;\nuse cv_rusty::{Matrix3, Kernel, BorderMode};\n\nfn process_camera_frame(frame: &amp;Matrix3) -&gt; Matrix3 {\n    // Edge detection for embedded vision system\n    let kernel = Kernel::sobel_x();\n    frame.convolve(&amp;kernel, BorderMode::Replicate)\n}\n</code></pre> <p>Note: Parallel processing requires <code>std</code> and is automatically disabled in <code>no_std</code> builds.</p>"},{"location":"guides/convolution/#examples","title":"Examples","text":"<p>See the examples directory for complete working examples:</p> <ul> <li><code>convolution_demo.rs</code> - Demonstrates all built-in kernels</li> <li><code>convolution_benchmark.rs</code> - Performance testing</li> <li>Examples in <code>examples/README.md</code></li> </ul>"},{"location":"guides/convolution/#api-reference","title":"API Reference","text":""},{"location":"guides/convolution/#kernel-methods","title":"Kernel Methods","text":"<pre><code>impl Kernel {\n    pub fn new(width: usize, height: usize, data: Vec&lt;f32&gt;) -&gt; Self;\n    pub fn box_blur(size: usize) -&gt; Self;\n    pub fn gaussian(size: usize, sigma: f32) -&gt; Self;\n    pub fn sobel_x() -&gt; Self;\n    pub fn sobel_y() -&gt; Self;\n    pub fn laplacian() -&gt; Self;\n    pub fn sharpen() -&gt; Self;\n    pub fn width(&amp;self) -&gt; usize;\n    pub fn height(&amp;self) -&gt; usize;\n    pub fn data(&amp;self) -&gt; &amp;[f32];\n}\n</code></pre>"},{"location":"guides/convolution/#matrix-methods","title":"Matrix Methods","text":"<pre><code>impl Matrix1 {\n    pub fn convolve(&amp;self, kernel: &amp;Kernel, border_mode: BorderMode) -&gt; Self;\n    pub fn convolve_separable(&amp;self, kernel_x: &amp;[f32], kernel_y: &amp;[f32], border_mode: BorderMode) -&gt; Self;\n}\n\nimpl Matrix3 {\n    pub fn convolve(&amp;self, kernel: &amp;Kernel, border_mode: BorderMode) -&gt; Self;\n    pub fn convolve_separable(&amp;self, kernel_x: &amp;[f32], kernel_y: &amp;[f32], border_mode: BorderMode) -&gt; Self;\n}\n</code></pre>"},{"location":"guides/convolution/#bordermode-enum","title":"BorderMode Enum","text":"<pre><code>pub enum BorderMode {\n    Zero,\n    Replicate,\n    Reflect,\n    Wrap,\n}\n</code></pre>"},{"location":"guides/convolution/#further-reading","title":"Further Reading","text":"<ul> <li>Convolution on Wikipedia</li> <li>Gaussian Blur</li> <li>Sobel Operator</li> <li>Image Filtering Tutorial</li> </ul>"},{"location":"guides/image-writing/","title":"Image Writing Functionality","text":"<p>This document describes the image writing capabilities added to cv-rusty, allowing you to save <code>Matrix3</code> objects as JPEG or PNG files.</p>"},{"location":"guides/image-writing/#overview","title":"Overview","text":"<p>The library now supports writing RGB image data from <code>Matrix3</code> objects to disk in two popular formats: - JPEG - Lossy compression with adjustable quality - PNG - Lossless compression</p>"},{"location":"guides/image-writing/#api-reference","title":"API Reference","text":""},{"location":"guides/image-writing/#writing-jpeg-images","title":"Writing JPEG Images","text":"<pre><code>pub fn write_jpeg&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n    quality: u8,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the JPEG should be saved - <code>quality</code>: Compression quality (1-100)   - <code>1</code>: Lowest quality, smallest file size   - <code>100</code>: Highest quality, largest file size   - <code>90</code>: Recommended for most use cases   - Values outside 1-100 are automatically clamped</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_jpeg};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write high-quality JPEG\nwrite_jpeg(&amp;image, \"output.jpg\", 95)?;\n\n// Write smaller file with lower quality\nwrite_jpeg(&amp;image, \"compressed.jpg\", 60)?;\n</code></pre></p>"},{"location":"guides/image-writing/#writing-png-images","title":"Writing PNG Images","text":"<pre><code>pub fn write_png&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the PNG should be saved</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_png};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write lossless PNG\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"guides/image-writing/#format-comparison","title":"Format Comparison","text":""},{"location":"guides/image-writing/#jpeg","title":"JPEG","text":"<p>Pros: - Smaller file sizes - Adjustable quality/size tradeoff - Widely supported - Good for photographs</p> <p>Cons: - Lossy compression (data loss) - Not suitable for text or sharp edges - No transparency support</p> <p>Typical file sizes (640\u00d7480 image): - Quality 95: ~35 KB - Quality 75: ~11 KB - Quality 50: ~6 KB</p>"},{"location":"guides/image-writing/#png","title":"PNG","text":"<p>Pros: - Lossless compression (no data loss) - Perfect for graphics with sharp edges - Supports transparency (though cv-rusty uses RGB without alpha) - Good for iterative editing</p> <p>Cons: - Larger file sizes than JPEG - Less efficient for photographs</p> <p>Typical file sizes (640\u00d7480 image): - RGB gradient: ~240 KB</p>"},{"location":"guides/image-writing/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>use cv_rusty::{read_jpeg, write_jpeg, write_png, Matrix3};\n\nfn process_and_save() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read an image\n    let mut image = read_jpeg(\"input.jpg\")?;\n\n    // Process the image (example: invert colors)\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                image.set_pixel(x, y, 255 - r, 255 - g, 255 - b);\n            }\n        }\n    }\n\n    // Save in multiple formats\n    write_jpeg(&amp;image, \"output_high_quality.jpg\", 95)?;\n    write_jpeg(&amp;image, \"output_web_quality.jpg\", 80)?;\n    write_png(&amp;image, \"output_lossless.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/image-writing/#error-handling","title":"Error Handling","text":"<p>Both functions return <code>Result&lt;(), ImageError&gt;</code> which can have the following error types:</p> <ul> <li><code>ImageError::Io</code>: File system errors (permissions, disk space, etc.)</li> <li><code>ImageError::JpegEncode</code>: JPEG encoding errors</li> <li><code>ImageError::PngEncode</code>: PNG encoding errors</li> </ul> <pre><code>use cv_rusty::io::{write_jpeg, ImageError};\n\nmatch write_jpeg(&amp;image, \"output.jpg\", 90) {\n    Ok(_) =&gt; println!(\"Image saved successfully\"),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegEncode(e)) =&gt; eprintln!(\"Encoding error: {}\", e),\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre>"},{"location":"guides/image-writing/#quality-guidelines","title":"Quality Guidelines","text":""},{"location":"guides/image-writing/#jpeg-quality-recommendations","title":"JPEG Quality Recommendations","text":"Quality Use Case File Size Visual Quality 90-100 Archival, printing, professional use Large Excellent 80-89 High-quality web images Medium Very Good 60-79 Standard web images, general use Small Good 40-59 Thumbnails, low-bandwidth scenarios Very Small Acceptable 1-39 Extreme compression Minimal Poor"},{"location":"guides/image-writing/#when-to-use-each-format","title":"When to Use Each Format","text":"<p>Use JPEG when: - Working with photographs - File size is a concern - Minor quality loss is acceptable - Sharing on the web</p> <p>Use PNG when: - Preserving exact pixel values is critical - Working with graphics, text, or line art - Need to perform multiple save operations - File size is not a primary concern</p>"},{"location":"guides/image-writing/#dependencies","title":"Dependencies","text":"<p>The image writing functionality requires the <code>std</code> feature (enabled by default) and uses: - <code>jpeg-encoder</code> (v0.6) for JPEG encoding - <code>png</code> (v0.17) for PNG encoding</p> <p>These dependencies are automatically included when using the default <code>std</code> feature.</p>"},{"location":"guides/image-writing/#examples","title":"Examples","text":"<p>Run the included examples to see the functionality in action:</p> <pre><code># Create gradient images in both formats\ncargo run --example write_image_example\n\n# Convert an existing image to different formats\ncargo run --example image_conversion input.jpg\n\n# View all examples\nls examples/\n</code></pre>"},{"location":"guides/image-writing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>JPEG encoding is generally faster than PNG for photographs</li> <li>PNG encoding time increases with image complexity</li> <li>Both encoders are optimized for single-threaded operation</li> <li>Memory usage is proportional to image size: width \u00d7 height \u00d7 3 bytes for RGB data</li> </ul>"},{"location":"guides/image-writing/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for future versions: - Support for writing grayscale images - PNG transparency (RGBA) support - Progressive JPEG encoding - Configurable PNG compression levels - Batch processing utilities - SIMD-optimized encoding</p>"},{"location":"guides/image-writing/#see-also","title":"See Also","text":"<ul> <li>README.md - General library documentation</li> <li>ARCHITECTURE.md - Library architecture</li> <li>API Documentation - Full API reference</li> </ul>"}]}