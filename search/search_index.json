{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CV Rusty","text":"<p>A <code>no_std</code> computer vision library written in Rust, designed for live computations, embedded systems, and high-performance image processing.</p>"},{"location":"#features","title":"Features","text":"<ul> <li><code>no_std</code> Compatible: Core library works without the standard library (only requires <code>alloc</code>)</li> <li>Zero-copy Image Representation: Efficient three-channel matrix structure for RGB images</li> <li>Image I/O: Built-in support for reading and writing JPEG and PNG images with automatic format conversion (requires <code>std</code> feature)</li> <li>Format Support: Handles RGB24, Grayscale (L8), and CMYK32 JPEG formats; RGB, RGBA, Grayscale, and Grayscale+Alpha PNG formats</li> <li>Safe API: Bounds-checked pixel access with ergonomic error handling</li> <li>Embedded Ready: Perfect for resource-constrained environments and real-time systems</li> </ul>"},{"location":"#installation","title":"Installation","text":""},{"location":"#standard-library-default","title":"Standard Library (default)","text":"<p>For applications with <code>std</code> support and file I/O:</p> <pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"#no_std-environments","title":"<code>no_std</code> Environments","text":"<p>For embedded systems or <code>no_std</code> environments (requires <code>alloc</code>):</p> <pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"#feature-flags","title":"Feature Flags","text":"<ul> <li><code>std</code> (enabled by default): Enables standard library support, including file I/O operations</li> <li><code>alloc</code>: Enables heap allocation support (required for core functionality)</li> </ul>"},{"location":"#usage","title":"Usage","text":""},{"location":"#reading-and-writing-images-requires-std-feature","title":"Reading and Writing Images (requires <code>std</code> feature)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, write_jpeg, write_png};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read a JPEG file into a Matrix3\n    let image = read_jpeg(\"photo.jpg\")?;\n    println!(\"JPEG dimensions: {}x{}\", image.width(), image.height());\n\n    // Read a PNG file into a Matrix3\n    let image = read_png(\"photo.png\")?;\n    println!(\"PNG dimensions: {}x{}\", image.width(), image.height());\n\n    // Access pixel data\n    if let Some((r, g, b)) = image.get_pixel(100, 100) {\n        println!(\"Pixel at (100, 100): RGB({}, {}, {})\", r, g, b);\n    }\n\n    // Write as JPEG with quality setting (1-100)\n    write_jpeg(&amp;image, \"output.jpg\", 90)?;\n\n    // Write as PNG (lossless)\n    write_png(&amp;image, \"output.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"#working-with-matrix3-no_std-compatible","title":"Working with Matrix3 (<code>no_std</code> compatible)","text":"<pre><code>use cv_rusty::matrix::Matrix3;\n\n// Create a new 640x480 image filled with zeros\nlet mut image = Matrix3::zeros(640, 480);\n\n// Set a pixel value\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel at (10, 20)\n\n// Get a pixel value\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Access raw data\nlet raw_data = image.data();\nprintln!(\"Total bytes: {}\", raw_data.len());\n</code></pre>"},{"location":"#error-handling","title":"Error Handling","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; {\n        println!(\"Successfully loaded {}x{} image\", image.width(), image.height());\n    }\n    Err(ImageError::Io(e)) =&gt; {\n        eprintln!(\"File I/O error: {}\", e);\n    }\n    Err(ImageError::JpegDecode(e)) =&gt; {\n        eprintln!(\"JPEG decoding error: {}\", e);\n    }\n    Err(ImageError::PngDecode(e)) =&gt; {\n        eprintln!(\"PNG decoding error: {}\", e);\n    }\n    Err(ImageError::JpegEncode(e)) =&gt; {\n        eprintln!(\"JPEG encoding error: {}\", e);\n    }\n    Err(ImageError::PngEncode(e)) =&gt; {\n        eprintln!(\"PNG encoding error: {}\", e);\n    }\n    Err(ImageError::UnsupportedFormat(e)) =&gt; {\n        eprintln!(\"Unsupported format: {}\", e);\n    }\n}\n</code></pre>"},{"location":"#no_std-embedded-usage","title":"<code>no_std</code> Embedded Usage","text":"<pre><code>#![no_std]\n\nextern crate alloc;\nuse cv_rusty::Matrix3;\n\nfn process_image() {\n    // Create image data in memory\n    let mut image = Matrix3::zeros(320, 240);\n\n    // Process pixels (e.g., from a camera sensor)\n    for y in 0..240 {\n        for x in 0..320 {\n            // Set pixel from sensor data\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    // Send to display via SPI/I2C\n    let raw_data = image.data();\n    // ... send raw_data to hardware\n}\n</code></pre>"},{"location":"#examples","title":"Examples","text":""},{"location":"#with-std-feature-file-io","title":"With <code>std</code> feature (file I/O)","text":"<p>Read and analyze a JPEG file:</p> <pre><code>cargo run --example read_jpeg_example path/to/your/image.jpg\n</code></pre> <p>Read and analyze a PNG file:</p> <pre><code>cargo run --example read_png_example path/to/your/image.png\n</code></pre> <p>Write images in JPEG and PNG formats:</p> <pre><code>cargo run --example write_image_example\n</code></pre> <p>Convert images between formats:</p> <pre><code>cargo run --example image_conversion path/to/your/image.jpg\n</code></pre>"},{"location":"#no_std-example","title":"<code>no_std</code> example","text":"<p>Demonstrate core functionality without file I/O:</p> <pre><code>cargo run --example no_std_example\n</code></pre> <p>Build for <code>no_std</code> environment:</p> <pre><code>cargo build --no-default-features\n</code></pre>"},{"location":"#api-documentation","title":"API Documentation","text":""},{"location":"#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix for representing RGB image data.</p> <p>Key Methods: - <code>new(width, height, data)</code> - Create from raw RGB data - <code>zeros(width, height)</code> - Create a zero-initialized matrix - <code>get_pixel(x, y)</code> - Get RGB values at a pixel location - <code>set_pixel(x, y, r, g, b)</code> - Set RGB values at a pixel location - <code>width()</code>, <code>height()</code>, <code>dimensions()</code> - Get matrix dimensions - <code>data()</code>, <code>data_mut()</code> - Access raw pixel data</p>"},{"location":"#ioread_jpegpath","title":"<code>io::read_jpeg(path)</code>","text":"<p>Reads a JPEG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB24 (24-bit color) - L8 (8-bit grayscale, converted to RGB) - CMYK32 (CMYK color space, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#ioread_pngpath","title":"<code>io::read_png(path)</code>","text":"<p>Reads a PNG image file and returns it as a three-channel RGB <code>Matrix3</code>.</p> <p>Supported Formats: - RGB (24-bit color) - RGBA (32-bit color with alpha, alpha channel stripped) - Grayscale (8-bit, converted to RGB) - Grayscale+Alpha (16-bit, alpha channel stripped, converted to RGB)</p> <p>Returns: <code>Result&lt;Matrix3, ImageError&gt;</code></p>"},{"location":"#iowrite_jpegmatrix-path-quality","title":"<code>io::write_jpeg(matrix, path, quality)</code>","text":"<p>Writes a <code>Matrix3</code> as a JPEG image file.</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the JPEG file should be written - <code>quality</code> - JPEG quality (1-100, where 100 is best quality)</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_jpeg(&amp;image, \"output.jpg\", 90)?;\n</code></pre></p>"},{"location":"#iowrite_pngmatrix-path","title":"<code>io::write_png(matrix, path)</code>","text":"<p>Writes a <code>Matrix3</code> as a PNG image file (lossless compression).</p> <p>Arguments: - <code>matrix</code> - Reference to the Matrix3 containing RGB data - <code>path</code> - Path where the PNG file should be written</p> <p>Returns: <code>Result&lt;(), ImageError&gt;</code></p> <p>Example: <pre><code>let image = Matrix3::zeros(640, 480);\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#embedded-systems","title":"Embedded Systems","text":"<ul> <li>Camera processing on microcontrollers</li> <li>Real-time video processing on FPGA/ASIC</li> <li>LCD/OLED display controllers</li> <li>Industrial vision systems</li> </ul>"},{"location":"#high-performance-applications","title":"High-Performance Applications","text":"<ul> <li>Real-time computer vision</li> <li>Video processing pipelines</li> <li>Live streaming applications</li> <li>Robotics and automation</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<ul> <li> <code>no_std</code> support</li> <li> JPEG image reading (with <code>std</code> feature)</li> <li> PNG image reading (with <code>std</code> feature)</li> <li> JPEG image writing (with <code>std</code> feature)</li> <li> PNG image writing (with <code>std</code> feature)</li> <li> Color space conversions (RGB \u2194 HSV, RGB \u2194 HSL)</li> <li> RGB to Grayscale conversion (multiple methods)</li> <li> Single-channel matrix (Matrix1) for grayscale images</li> <li> 2D convolution operations with multiple border modes</li> <li> Separable convolution for efficiency</li> <li> Parallel processing support with Rayon</li> <li> Built-in convolution kernels (Gaussian, Sobel, Laplacian, etc.)</li> <li> Basic image operations (resize, crop, rotate)</li> <li> Additional color space conversions (RGB \u2194 YUV, YCbCr)</li> <li> Morphological operations (erosion, dilation)</li> <li> Feature detection</li> <li> SIMD optimizations</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is open source and available under the MIT License.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"quick-reference/","title":"CV Rusty Quick Reference","text":""},{"location":"quick-reference/#installation","title":"Installation","text":""},{"location":"quick-reference/#with-standard-library-default","title":"With Standard Library (default)","text":"<pre><code>[dependencies]\ncv-rusty = \"0.1.0\"\n</code></pre>"},{"location":"quick-reference/#for-embeddedno_std","title":"For Embedded/no_std","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n</code></pre>"},{"location":"quick-reference/#feature-flags","title":"Feature Flags","text":"Feature Description Default <code>std</code> Standard library support + file I/O \u2713 <code>alloc</code> Heap allocation (required for core) - <code>window</code> GUI window display support -"},{"location":"quick-reference/#basic-operations","title":"Basic Operations","text":""},{"location":"quick-reference/#creating-images","title":"Creating Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// Create zero-filled image\nlet image = Matrix3::zeros(640, 480);\n\n// Create from raw RGB data\nlet data = vec![0u8; 640 * 480 * 3];\nlet image = Matrix3::new(640, 480, data);\n</code></pre>"},{"location":"quick-reference/#reading-images-requires-std","title":"Reading Images (requires <code>std</code>)","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png};\n\n// Read JPEG\nlet image = read_jpeg(\"photo.jpg\")?;\n\n// Read PNG\nlet image = read_png(\"photo.png\")?;\n</code></pre>"},{"location":"quick-reference/#accessing-image-properties","title":"Accessing Image Properties","text":"<pre><code>let width = image.width();\nlet height = image.height();\nlet (w, h) = image.dimensions();\nlet raw_data = image.data();\n</code></pre>"},{"location":"quick-reference/#pixel-operations","title":"Pixel Operations","text":"<pre><code>// Get pixel\nif let Some((r, g, b)) = image.get_pixel(10, 20) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n\n// Set pixel\nimage.set_pixel(10, 20, 255, 0, 0); // Red pixel\n</code></pre>"},{"location":"quick-reference/#direct-data-access","title":"Direct Data Access","text":"<pre><code>// Read-only access\nlet data = image.data();\nfor chunk in data.chunks_exact(3) {\n    let (r, g, b) = (chunk[0], chunk[1], chunk[2]);\n    // Process pixel...\n}\n\n// Mutable access\nlet data = image.data_mut();\nfor pixel in data.iter_mut() {\n    *pixel = (*pixel as u16 * 2).min(255) as u8;\n}\n</code></pre>"},{"location":"quick-reference/#image-transformations","title":"Image Transformations","text":""},{"location":"quick-reference/#resize","title":"Resize","text":"<pre><code>use cv_rusty::{Matrix3, InterpolationMethod};\n\n// Resize with bilinear interpolation (recommended)\nlet resized = image.resize(320, 240, InterpolationMethod::Bilinear);\n\n// Resize with nearest neighbor (faster, lower quality)\nlet resized = image.resize(320, 240, InterpolationMethod::NearestNeighbor);\n\n// Upscale\nlet enlarged = image.resize(1280, 720, InterpolationMethod::Bilinear);\n\n// Downscale\nlet thumbnail = image.resize(80, 60, InterpolationMethod::Bilinear);\n</code></pre>"},{"location":"quick-reference/#crop","title":"Crop","text":"<pre><code>// Crop region: (x, y, width, height)\nlet cropped = image.crop(100, 100, 200, 200).unwrap();\n\n// Center crop\nlet (w, h) = image.dimensions();\nlet crop_w = 400;\nlet crop_h = 300;\nlet x = (w - crop_w) / 2;\nlet y = (h - crop_h) / 2;\nlet center_crop = image.crop(x, y, crop_w, crop_h).unwrap();\n\n// Handle errors\nmatch image.crop(50, 50, 200, 200) {\n    Some(cropped) =&gt; println!(\"Crop successful\"),\n    None =&gt; println!(\"Invalid crop region\"),\n}\n</code></pre>"},{"location":"quick-reference/#rotate","title":"Rotate","text":"<pre><code>use cv_rusty::{RotationAngle, Rotation, InterpolationMethod};\n\n// Rotate 90 degrees clockwise (fast, lossless)\nlet rotated = image.rotate(RotationAngle::Rotate90);\n\n// Rotate 180 degrees (fast, lossless)\nlet flipped = image.rotate(RotationAngle::Rotate180);\n\n// Rotate 270 degrees clockwise (fast, lossless)\nlet rotated_ccw = image.rotate(RotationAngle::Rotate270);\n\n// Rotate by arbitrary angle with degrees\nlet rotated_45 = image.rotate_custom(\n    Rotation::Degrees(45.0),\n    InterpolationMethod::Bilinear\n);\n\n// Rotate by arbitrary angle with radians\nlet rotated_pi4 = image.rotate_custom(\n    Rotation::Radians(std::f32::consts::PI / 4.0),\n    InterpolationMethod::Bilinear\n);\n\n// Counter-clockwise rotation with negative angle\nlet rotated_ccw = image.rotate_custom(\n    Rotation::Degrees(-30.0),\n    InterpolationMethod::Bilinear\n);\n\n// Fast nearest neighbor for arbitrary angles\nlet rotated_fast = image.rotate_custom(\n    Rotation::Degrees(15.0),\n    InterpolationMethod::NearestNeighbor\n);\n</code></pre>"},{"location":"quick-reference/#chaining-transformations","title":"Chaining Transformations","text":"<pre><code>// Create a thumbnail: crop center, resize, and rotate\nlet thumbnail = image\n    .crop(100, 100, 400, 300)\n    .unwrap()\n    .resize(200, 150, InterpolationMethod::Bilinear)\n    .rotate(RotationAngle::Rotate90);\n\n// Process and save\nlet processed = image\n    .resize(640, 480, InterpolationMethod::Bilinear)\n    .crop(50, 50, 500, 350)\n    .unwrap();\nwrite_jpeg(&amp;processed, \"output.jpg\", 90)?;\n</code></pre>"},{"location":"quick-reference/#drawing-shapes","title":"Drawing Shapes","text":""},{"location":"quick-reference/#import","title":"Import","text":"<pre><code>use cv_rusty::{draw_rectangle, draw_circle, Color, Stroke};\n</code></pre>"},{"location":"quick-reference/#color-creation","title":"Color Creation","text":"<pre><code>// RGB colors\nlet red = Color::rgb(255, 0, 0);\nlet green = Color::rgb(0, 255, 0);\nlet blue = Color::rgb(0, 0, 255);\n\n// Grayscale colors\nlet white = Color::gray(255);\nlet black = Color::gray(0);\nlet gray = Color::gray(128);\n\n// Named colors\nlet black = Color::black();\nlet white = Color::white();\n\n// Hex colors (6-digit or 3-digit format)\nlet orange = Color::from_hex(\"#FF5733\")?;\nlet cyan = Color::from_hex(\"#0FF\")?;\nlet gold = Color::from_hex(\"FFD700\")?;  // # prefix optional\n\n// Parse from string\nlet pink: Color = \"#FF1493\".parse()?;\n\n// Colors with opacity (0.0 = transparent, 1.0 = opaque)\nlet semi_red = Color::rgb_with_opacity(255, 0, 0, 0.5);     // 50% transparent\nlet semi_gray = Color::gray_with_opacity(128, 0.7);         // 70% opaque\n\n// Modify opacity of existing colors\nlet opaque_blue = Color::rgb(0, 0, 255);\nlet transparent_blue = opaque_blue.with_opacity(0.3);       // 30% opaque\n\n// Get opacity value\nlet opacity = semi_red.opacity();  // Returns 0.5\n</code></pre>"},{"location":"quick-reference/#draw-rectangle","title":"Draw Rectangle","text":"<pre><code>use cv_rusty::{Matrix3, draw_rectangle, Color, Stroke};\n\nlet mut image = Matrix3::zeros(640, 480);\n\n// Basic filled rectangle with border\ndraw_rectangle(\n    &amp;mut image,\n    320.0, 240.0,    // Center position (x, y)\n    100.0, 80.0,     // Width, height\n    0.0,             // Rotation in degrees (clockwise)\n    Some(Stroke::new(2, Color::rgb(0, 0, 0))),  // 2px black stroke\n    Some(Color::rgb(255, 0, 0))                 // Red fill\n);\n\n// Rotated rectangle\ndraw_rectangle(\n    &amp;mut image,\n    200.0, 150.0,\n    80.0, 120.0,\n    45.0,  // 45 degrees clockwise\n    Some(Stroke::new(3, Color::white())),\n    Some(Color::rgb(0, 255, 0))\n);\n\n// Outline only (no fill)\ndraw_rectangle(\n    &amp;mut image,\n    400.0, 300.0,\n    150.0, 100.0,\n    30.0,\n    Some(Stroke::new(4, Color::rgb(0, 0, 255))),\n    None  // No fill\n);\n\n// Fill only (no stroke)\ndraw_rectangle(\n    &amp;mut image,\n    500.0, 200.0,\n    60.0, 60.0,\n    0.0,\n    None,  // No stroke\n    Some(Color::rgb(255, 255, 0))\n);\n</code></pre>"},{"location":"quick-reference/#draw-circle","title":"Draw Circle","text":"<pre><code>use cv_rusty::{Matrix3, draw_circle, Color, Stroke};\n\nlet mut image = Matrix3::zeros(640, 480);\n\n// Basic filled circle with border\ndraw_circle(\n    &amp;mut image,\n    320.0, 240.0,    // Center position (x, y)\n    50.0,            // Radius\n    Some(Stroke::new(3, Color::white())),  // 3px white stroke\n    Some(Color::rgb(0, 0, 255))            // Blue fill\n);\n\n// Outline only\ndraw_circle(\n    &amp;mut image,\n    200.0, 200.0,\n    60.0,\n    Some(Stroke::new(5, Color::rgb(255, 0, 0))),  // 5px red stroke\n    None  // No fill\n);\n\n// Fill only\ndraw_circle(\n    &amp;mut image,\n    450.0, 350.0,\n    40.0,\n    None,  // No stroke\n    Some(Color::rgb(0, 255, 0))\n);\n</code></pre>"},{"location":"quick-reference/#works-with-grayscale-images","title":"Works with Grayscale Images","text":"<pre><code>use cv_rusty::{Matrix1, draw_rectangle, draw_circle, Color, Stroke};\n\nlet mut gray_image = Matrix1::zeros(640, 480);\n\n// Same functions work with grayscale images\ndraw_rectangle(\n    &amp;mut gray_image,\n    320.0, 240.0,\n    100.0, 60.0,\n    0.0,\n    Some(Stroke::new(2, Color::gray(255))),  // White stroke\n    Some(Color::gray(100))                   // Dark gray fill\n);\n\ndraw_circle(\n    &amp;mut gray_image,\n    320.0, 240.0,\n    50.0,\n    Some(Stroke::new(3, Color::gray(255))),\n    Some(Color::gray(100))\n);\n</code></pre>"},{"location":"quick-reference/#using-hex-colors","title":"Using Hex Colors","text":"<pre><code>// Draw with hex colors\ndraw_rectangle(\n    &amp;mut image,\n    320.0, 120.0,\n    100.0, 60.0,\n    15.0,\n    Some(Stroke::new(2, Color::from_hex(\"#2C3E50\")?)),  // Dark blue-gray\n    Some(Color::from_hex(\"#3498DB\")?)                   // Light blue\n);\n\n// 3-digit hex format (expands F -&gt; FF)\ndraw_circle(\n    &amp;mut image,\n    200.0, 200.0,\n    40.0,\n    Some(Stroke::new(2, Color::from_hex(\"#000\")?)),  // Black\n    Some(Color::from_hex(\"#F0F\")?)                    // Magenta\n);\n</code></pre>"},{"location":"quick-reference/#drawing-patterns","title":"Drawing Patterns","text":"<pre><code>// Draw grid of circles\nfor i in 0..5 {\n    let x = 100.0 + (i as f32 * 120.0);\n    draw_circle(\n        &amp;mut image,\n        x, 240.0,\n        40.0,\n        Some(Stroke::new(3, Color::black())),\n        Some(Color::rgb(100, 200, 100))\n    );\n}\n\n// Draw rotating rectangles\nfor angle in (0..360).step_by(45) {\n    draw_rectangle(\n        &amp;mut image,\n        320.0, 240.0,\n        100.0, 50.0,\n        angle as f32,\n        Some(Stroke::new(2, Color::rgb(255, 0, 0))),\n        None\n    );\n}\n</code></pre>"},{"location":"quick-reference/#annotation-example","title":"Annotation Example","text":"<pre><code>// Draw bounding box annotation\nfn draw_bbox(image: &amp;mut Matrix3, x: f32, y: f32, \n             w: f32, h: f32, confidence: f32) {\n    let color = if confidence &gt; 0.8 {\n        Color::rgb(0, 255, 0)  // Green\n    } else if confidence &gt; 0.5 {\n        Color::rgb(255, 255, 0)  // Yellow\n    } else {\n        Color::rgb(255, 0, 0)  // Red\n    };\n\n    draw_rectangle(\n        image,\n        x + w / 2.0,\n        y + h / 2.0,\n        w, h,\n        0.0,\n        Some(Stroke::new(3, color)),\n        None\n    );\n}\n</code></pre>"},{"location":"quick-reference/#opacity-and-transparency","title":"Opacity and Transparency","text":"<pre><code>// Draw overlapping semi-transparent shapes\ndraw_rectangle(\n    &amp;mut image,\n    200.0, 200.0,\n    150.0, 100.0,\n    0.0,\n    None,\n    Some(Color::rgb(0, 0, 255))  // Opaque blue\n);\n\ndraw_rectangle(\n    &amp;mut image,\n    250.0, 220.0,\n    150.0, 100.0,\n    0.0,\n    None,\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.5))  // 50% transparent red\n);\n// Overlap shows purple blend\n\n// Venn diagram with color blending\nlet colors = [\n    Color::rgb_with_opacity(255, 0, 0, 0.6),    // Red\n    Color::rgb_with_opacity(0, 255, 0, 0.6),    // Green\n    Color::rgb_with_opacity(0, 0, 255, 0.6),    // Blue\n];\n\nfor (i, color) in colors.iter().enumerate() {\n    draw_circle(\n        &amp;mut image,\n        200.0 + (i as f32 * 60.0),\n        240.0,\n        50.0,\n        None,\n        Some(*color)\n    );\n}\n\n// Watermark effect with very low opacity\ndraw_rectangle(\n    &amp;mut image,\n    400.0, 500.0,\n    300.0, 80.0,\n    15.0,\n    None,\n    Some(Color::rgb_with_opacity(128, 128, 128, 0.15))  // 15% opacity\n);\n</code></pre>"},{"location":"quick-reference/#performance","title":"Performance","text":"Operation Time (640\u00d7480) Complexity Rectangle (aligned) ~30 \u00b5s O(bbox_area) Rectangle (rotated) ~45 \u00b5s O(bbox_area) Circle (r=50) ~50 \u00b5s O(bbox_area) 100 shapes ~4 ms -"},{"location":"quick-reference/#common-patterns","title":"Common Patterns","text":""},{"location":"quick-reference/#brightness-adjustment","title":"Brightness Adjustment","text":"<pre><code>fn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    for pixel in image.data_mut().iter_mut() {\n        *pixel = (*pixel as f32 * factor).min(255.0) as u8;\n    }\n}\n</code></pre>"},{"location":"quick-reference/#grayscale-conversion","title":"Grayscale Conversion","text":"<pre><code>fn to_grayscale(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut gray = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let gray_val = (0.299 * r as f32 + \n                               0.587 * g as f32 + \n                               0.114 * b as f32) as u8;\n                gray.set_pixel(x, y, gray_val, gray_val, gray_val);\n            }\n        }\n    }\n    gray\n}\n</code></pre>"},{"location":"quick-reference/#region-of-interest-roi","title":"Region of Interest (ROI)","text":"<pre><code>fn extract_roi(src: &amp;Matrix3, x: usize, y: usize, \n               w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"quick-reference/#color-channel-operations","title":"Color Channel Operations","text":"<pre><code>// Extract red channel\nfn extract_red_channel(image: &amp;Matrix3) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let mut red = Matrix3::zeros(w, h);\n\n    for y in 0..h {\n        for x in 0..w {\n            if let Some((r, _, _)) = image.get_pixel(x, y) {\n                red.set_pixel(x, y, r, 0, 0);\n            }\n        }\n    }\n    red\n}\n</code></pre>"},{"location":"quick-reference/#window-display-api-requires-window-feature","title":"Window Display API (requires <code>window</code> feature)","text":""},{"location":"quick-reference/#enable-feature","title":"Enable Feature","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.3.0\", features = [\"window\"] }\n</code></pre>"},{"location":"quick-reference/#import_1","title":"Import","text":"<pre><code>use cv_rusty::{show_image, show_and_wait, wait_key, Displayable, WindowError};\n</code></pre>"},{"location":"quick-reference/#display-images-works-with-matrix1-and-matrix3","title":"Display Images (Works with Matrix1 and Matrix3)","text":"<pre><code>use cv_rusty::{Matrix1, Matrix3, show_image};\n\n// Display a color image\nlet color_image = Matrix3::zeros(640, 480);\nshow_image(\"Color Window\", &amp;color_image)?;\n\n// Display a grayscale image\nlet gray_image = Matrix1::zeros(640, 480);\nshow_image(\"Grayscale Window\", &amp;gray_image)?;\n</code></pre>"},{"location":"quick-reference/#display-and-wait-functions","title":"Display and Wait Functions","text":"<pre><code>// Display image and wait for user to close (works with any image type)\nshow_and_wait(\"My Window\", &amp;image)?;\n\n// Wait for specified milliseconds\nwait_key(1000); // Wait 1 second\nwait_key(0);    // Wait indefinitely\n</code></pre>"},{"location":"quick-reference/#window-error-types","title":"Window Error Types","text":"<pre><code>pub enum WindowError {\n    WindowCreation(String),  // Failed to create/update window\n    InvalidDimensions,       // Image has zero width or height\n}\n</code></pre>"},{"location":"quick-reference/#complete-window-example","title":"Complete Window Example","text":"<pre><code>use cv_rusty::{Matrix3, show_image, read_jpeg};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load image\n    let image = read_jpeg(\"input.jpg\")?;\n\n    // Display image\n    show_image(\"My Image\", &amp;image)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"quick-reference/#keyboard-controls","title":"Keyboard Controls","text":"Key Action ESC Close window Window X button Close window"},{"location":"quick-reference/#display-multiple-images-sequentially","title":"Display Multiple Images Sequentially","text":"<pre><code>show_image(\"Image 1\", &amp;image1)?;  // Shows, waits until closed\nshow_image(\"Image 2\", &amp;image2)?;  // Then shows next\nshow_image(\"Image 3\", &amp;image3)?;  // And so on...\n</code></pre>"},{"location":"quick-reference/#display-with-error-handling","title":"Display with Error Handling","text":"<pre><code>match show_image(\"Window\", &amp;image) {\n    Ok(_) =&gt; println!(\"Displayed successfully\"),\n    Err(WindowError::InvalidDimensions) =&gt; {\n        eprintln!(\"Invalid image dimensions\");\n    }\n    Err(WindowError::WindowCreation(msg)) =&gt; {\n        eprintln!(\"Window error: {}\", msg);\n    }\n}\n</code></pre>"},{"location":"quick-reference/#display-processed-image","title":"Display Processed Image","text":"<pre><code>// Original\nlet image = read_jpeg(\"input.jpg\")?;\nshow_image(\"Original\", &amp;image)?;\n\n// Apply processing\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\nshow_image(\"Blurred\", &amp;blurred)?;\n</code></pre>"},{"location":"quick-reference/#create-and-display-test-pattern","title":"Create and Display Test Pattern","text":"<pre><code>let mut image = Matrix3::zeros(400, 300);\n\n// Draw red square\nfor y in 100..200 {\n    for x in 150..250 {\n        image.set_pixel(x, y, 255, 0, 0);\n    }\n}\n\nshow_image(\"Test Pattern\", &amp;image)?;\n</code></pre>"},{"location":"quick-reference/#display-both-color-and-grayscale","title":"Display Both Color and Grayscale","text":"<pre><code>// Single function works for both types\nlet color_image = Matrix3::zeros(640, 480);\nlet gray_image = Matrix1::zeros(640, 480);\n\nshow_image(\"Color\", &amp;color_image)?;\nshow_image(\"Grayscale\", &amp;gray_image)?;\n</code></pre>"},{"location":"quick-reference/#run-window-examples","title":"Run Window Examples","text":"<pre><code># Simple example\ncargo run --example simple_show_image --features window\n\n# Comprehensive example  \ncargo run --example window_display_example --features window\n</code></pre>"},{"location":"quick-reference/#window-display-notes","title":"Window Display Notes","text":"<ul> <li>Windows are displayed sequentially (blocking)</li> <li>Each window runs at maximum 60 FPS</li> <li>Requires GUI support (not for headless environments)</li> <li>Single <code>show_image()</code> function works with both color and grayscale images</li> <li>Uses Rust's trait system (<code>Displayable</code> trait) for type safety</li> <li>Image data format: RGB for Matrix3, grayscale for Matrix1</li> </ul>"},{"location":"quick-reference/#error-handling","title":"Error Handling","text":""},{"location":"quick-reference/#with-match","title":"With Match","text":"<pre><code>use cv_rusty::io::{read_jpeg, read_png, ImageError};\n\nmatch read_png(\"photo.png\") {\n    Ok(image) =&gt; println!(\"Loaded {}x{}\", image.width(), image.height()),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegDecode(e)) =&gt; eprintln!(\"JPEG error: {}\", e),\n    Err(ImageError::PngDecode(e)) =&gt; eprintln!(\"PNG error: {}\", e),\n    Err(ImageError::UnsupportedFormat(e)) =&gt; eprintln!(\"Format error: {}\", e),\n}\n</code></pre>"},{"location":"quick-reference/#with-operator","title":"With ? Operator","text":"<pre><code>fn process() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let jpeg_image = read_jpeg(\"photo.jpg\")?;\n    let png_image = read_png(\"photo.png\")?;\n    // Process images...\n    Ok(())\n}\n</code></pre>"},{"location":"quick-reference/#embeddedno_std-usage","title":"Embedded/no_std Usage","text":""},{"location":"quick-reference/#setup","title":"Setup","text":"<pre><code>#![no_std]\nextern crate alloc;\n\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"quick-reference/#create-small-images","title":"Create Small Images","text":"<pre><code>use cv_rusty::Matrix3;\n\n// 80x60 image = ~14 KB\nlet image = Matrix3::zeros(80, 60);\n</code></pre>"},{"location":"quick-reference/#process-in-chunks","title":"Process in Chunks","text":"<pre><code>const CHUNK_HEIGHT: usize = 10;\n\nfor start_y in (0..height).step_by(CHUNK_HEIGHT) {\n    let h = CHUNK_HEIGHT.min(height - start_y);\n    let chunk = Matrix3::zeros(width, h);\n    // Process chunk...\n}\n</code></pre>"},{"location":"quick-reference/#memory-requirements","title":"Memory Requirements","text":"Resolution Memory 80\u00d760 ~14 KB 160\u00d7120 ~57 KB 320\u00d7240 ~230 KB 640\u00d7480 ~921 KB <p>Formula: <code>width \u00d7 height \u00d7 3 bytes + 24 bytes overhead</code></p>"},{"location":"quick-reference/#performance-tips","title":"Performance Tips","text":"<ol> <li>Use direct data access for bulk operations</li> <li>Process in row-major order for cache efficiency</li> <li>Reuse buffers instead of creating new images</li> <li>Modify in-place when possible</li> <li>Batch pixel operations to reduce overhead</li> </ol>"},{"location":"quick-reference/#build-commands","title":"Build Commands","text":"<pre><code># Build with std (default)\ncargo build\n\n# Build with window feature\ncargo build --features window\n\n# Build for no_std\ncargo build --no-default-features\n\n# Run tests\ncargo test\n\n# Run examples\ncargo run --example read_jpeg_example image.jpg\ncargo run --example read_png_example image.png\ncargo run --example no_std_example\ncargo run --example drawing_example\ncargo run --example drawing_hex_colors\ncargo run --example drawing_grayscale_example\ncargo run --example drawing_quick_test\ncargo run --example simple_show_image --features window\ncargo run --example window_display_example --features window\n</code></pre>"},{"location":"quick-reference/#documentation","title":"Documentation","text":"<pre><code># Generate and open docs\ncargo doc --open\n</code></pre>"},{"location":"quick-reference/#support","title":"Support","text":"<ul> <li>GitHub: [Repository URL]</li> <li>Documentation: Run <code>cargo doc --open</code></li> <li>Examples: See <code>examples/</code> directory</li> <li>Architecture: See <code>ARCHITECTURE.md</code></li> <li>Embedded Guide: See <code>EMBEDDED.md</code></li> </ul>"},{"location":"architecture/architecture/","title":"CV Rusty Architecture","text":""},{"location":"architecture/architecture/#overview","title":"Overview","text":"<p>CV Rusty is a <code>no_std</code> compatible computer vision library written in Rust with a focus on performance, safety, and embedded systems support. The library is designed for live computations, real-time image processing applications, and resource-constrained environments.</p>"},{"location":"architecture/architecture/#project-structure","title":"Project Structure","text":"<pre><code>cv-rusty/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 lib.rs          # Main library entry point\n\u2502   \u251c\u2500\u2500 matrix.rs       # Matrix data structures\n\u2502   \u2514\u2500\u2500 io.rs           # Image I/O operations\n\u251c\u2500\u2500 examples/\n\u2502   \u2514\u2500\u2500 read_jpeg_example.rs\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"architecture/architecture/#module-design","title":"Module Design","text":""},{"location":"architecture/architecture/#librs","title":"<code>lib.rs</code>","text":"<p>The main library entry point configured for <code>no_std</code> compatibility. It uses feature flags to conditionally compile std-dependent code.</p> <p>Key Attributes: - <code>#![cfg_attr(not(feature = \"std\"), no_std)]</code> - Enables <code>no_std</code> when std feature is disabled - <code>extern crate alloc</code> - Required for heap allocations in <code>no_std</code> environments</p> <p>Public API: - <code>Matrix3</code> - Three-channel image matrix (always available) - <code>read_jpeg</code> - JPEG file reading function (only with <code>std</code> feature)</p>"},{"location":"architecture/architecture/#matrixrs","title":"<code>matrix.rs</code>","text":"<p>Contains the core data structure for representing multi-channel image data. This module is fully <code>no_std</code> compatible and only requires the <code>alloc</code> crate.</p> <p><code>no_std</code> Compatibility: - Uses <code>core::fmt</code> instead of <code>std::fmt</code> - Imports <code>Vec</code> from <code>alloc::vec::Vec</code> when <code>std</code> is not available - Imports <code>vec!</code> macro from <code>alloc::vec</code> for <code>no_std</code> environments</p>"},{"location":"architecture/architecture/#matrix3","title":"<code>Matrix3</code>","text":"<p>A three-channel matrix specifically designed for RGB image representation.</p> <p>Design Decisions: - Contiguous Memory Layout: Data is stored in a single <code>Vec&lt;u8&gt;</code> for cache efficiency - Interleaved Channels: RGB values are stored as <code>[R, G, B, R, G, B, ...]</code> for better spatial locality - Row-Major Order: Standard image representation order (y * width + x) - Bounds Checking: All pixel access methods return <code>Option</code> or <code>bool</code> to prevent panics</p> <p>Memory Layout: <pre><code>Pixel (0,0): [R, G, B] | Pixel (1,0): [R, G, B] | ... | Pixel (W-1,0): [R, G, B]\nPixel (0,1): [R, G, B] | Pixel (1,1): [R, G, B] | ... | Pixel (W-1,1): [R, G, B]\n...\nPixel (0,H-1): [R, G, B] | ... | Pixel (W-1,H-1): [R, G, B]\n</code></pre></p> <p>Index Calculation: <pre><code>let pixel_index = (y * width + x) * 3;\nlet r = data[pixel_index];\nlet g = data[pixel_index + 1];\nlet b = data[pixel_index + 2];\n</code></pre></p>"},{"location":"architecture/architecture/#iors","title":"<code>io.rs</code>","text":"<p>Handles image file I/O operations, currently supporting JPEG format. This module is only compiled when the <code>std</code> feature is enabled, as it requires file system access.</p> <p>Compilation Guard: - Only included when <code>#[cfg(feature = \"std\")]</code> is true - Requires <code>std::fs</code>, <code>std::io</code>, and <code>std::path</code></p>"},{"location":"architecture/architecture/#imageerror","title":"<code>ImageError</code>","text":"<p>Custom error type for image operations with variants: - <code>Io(io::Error)</code> - File system errors - <code>JpegDecode(String)</code> - JPEG decoding errors - <code>UnsupportedFormat(String)</code> - Unsupported pixel format errors</p>"},{"location":"architecture/architecture/#read_jpegpath","title":"<code>read_jpeg(path)</code>","text":"<p>Reads JPEG files and converts them to RGB <code>Matrix3</code>.</p> <p>Supported Input Formats: 1. RGB24 - Direct passthrough (most common) 2. L8 (Grayscale) - Converted by duplicating channel: <code>[G] -&gt; [G, G, G]</code> 3. CMYK32 - Converted using formula:    <pre><code>R = (1 - C) * (1 - K) * 255\nG = (1 - M) * (1 - K) * 255\nB = (1 - Y) * (1 - K) * 255\n</code></pre></p> <p>Processing Pipeline: 1. Open file with buffered reader 2. Create JPEG decoder 3. Decode image to raw pixels 4. Extract metadata (width, height, pixel format) 5. Convert to RGB if necessary 6. Construct <code>Matrix3</code> with RGB data</p>"},{"location":"architecture/architecture/#dependencies","title":"Dependencies","text":""},{"location":"architecture/architecture/#jpeg-decoder-v03","title":"<code>jpeg-decoder</code> (v0.3)","text":"<ul> <li>Purpose: JPEG image decoding</li> <li>Features: Supports multiple pixel formats, hardware acceleration</li> <li>License: MIT/Apache-2.0</li> <li>Availability: Optional, only included with <code>std</code> feature</li> <li>Note: This dependency requires <code>std</code>, so JPEG reading is not available in <code>no_std</code> environments</li> </ul>"},{"location":"architecture/architecture/#feature-flags","title":"Feature Flags","text":""},{"location":"architecture/architecture/#std-default","title":"<code>std</code> (default)","text":"<p>Enables standard library support, including: - File I/O operations (<code>io</code> module) - JPEG reading functionality - <code>std::error::Error</code> trait implementations</p>"},{"location":"architecture/architecture/#alloc","title":"<code>alloc</code>","text":"<p>Enables heap allocation support (required for core functionality): - <code>Vec&lt;u8&gt;</code> for storing pixel data - Dynamic memory allocation</p> <p>Feature Dependencies: <pre><code>[features]\ndefault = [\"std\"]\nstd = [\"jpeg-decoder\"]\nalloc = []\n</code></pre></p>"},{"location":"architecture/architecture/#design-principles","title":"Design Principles","text":"<ol> <li><code>no_std</code> First: Core functionality works without standard library</li> <li>Zero-Copy When Possible: Minimize data copying during operations</li> <li>Memory Safety: Use Rust's type system to prevent buffer overflows</li> <li>Ergonomic API: Simple, intuitive interfaces for common operations</li> <li>Performance: Design for real-time processing applications</li> <li>Extensibility: Modular design allows easy addition of new formats and operations</li> <li>Embedded Ready: Suitable for microcontrollers and resource-constrained systems</li> </ol>"},{"location":"architecture/architecture/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/architecture/#memory-layout","title":"Memory Layout","text":"<ul> <li>Contiguous allocation reduces cache misses</li> <li>Interleaved channels improve spatial locality for pixel operations</li> <li>Single allocation per image minimizes heap fragmentation</li> </ul>"},{"location":"architecture/architecture/#bounds-checking","title":"Bounds Checking","text":"<ul> <li>All pixel access is bounds-checked at compile time or returns <code>Option</code></li> <li>No unsafe code in current implementation</li> <li>Trade-off: slight overhead for safety guarantees</li> </ul>"},{"location":"architecture/architecture/#future-optimizations","title":"Future Optimizations","text":"<ul> <li>SIMD operations for bulk pixel processing</li> <li>Parallel processing with rayon for large images (with <code>std</code> feature)</li> <li>Memory pooling for repeated allocations</li> <li>Optional unsafe fast paths for performance-critical code</li> <li>Hardware accelerator support for embedded systems</li> <li>Zero-allocation operations where possible</li> </ul>"},{"location":"architecture/architecture/#no_std-support","title":"<code>no_std</code> Support","text":""},{"location":"architecture/architecture/#requirements","title":"Requirements","text":"<p>The core library (<code>Matrix3</code> and related operations) only requires: - <code>core</code> - Rust's core library (always available) - <code>alloc</code> - For heap allocations (<code>Vec</code>)</p>"},{"location":"architecture/architecture/#limitations-in-no_std","title":"Limitations in <code>no_std</code>","text":"<p>Without the <code>std</code> feature, the following are not available: - File I/O operations (<code>read_jpeg</code>, future <code>write_jpeg</code>) - <code>std::error::Error</code> trait (we use custom error types) - Threading/parallelization</p>"},{"location":"architecture/architecture/#embedded-use-cases","title":"Embedded Use Cases","text":"<p>The <code>no_std</code> design enables use in: - Microcontrollers (ARM Cortex-M, RISC-V) - Real-time Operating Systems (RTOS) - Bare-metal environments - FPGA/ASIC soft processors - Bootloaders and firmware</p>"},{"location":"architecture/architecture/#memory-considerations","title":"Memory Considerations","text":"<p>In <code>no_std</code> environments: - Heap allocation requires a global allocator to be configured - Large images may exceed available RAM on constrained devices - Consider using smaller images or streaming processing - Future: Support for static allocation and external memory</p>"},{"location":"architecture/architecture/#testing-strategy","title":"Testing Strategy","text":""},{"location":"architecture/architecture/#unit-tests","title":"Unit Tests","text":"<ul> <li>Located inline with source code using <code>#[cfg(test)]</code></li> <li>Test coverage includes:</li> <li>Matrix creation and initialization</li> <li>Pixel access (get/set)</li> <li>Boundary conditions</li> <li>Error handling</li> </ul>"},{"location":"architecture/architecture/#doc-tests","title":"Doc Tests","text":"<ul> <li>Embedded in documentation comments</li> <li>Ensures examples in docs remain valid</li> <li>Run automatically with <code>cargo test</code></li> </ul>"},{"location":"architecture/architecture/#integration-tests","title":"Integration Tests","text":"<ul> <li>Examples serve as integration tests</li> <li>Real-world usage patterns</li> </ul>"},{"location":"architecture/architecture/#future-architecture-plans","title":"Future Architecture Plans","text":""},{"location":"architecture/architecture/#planned-modules","title":"Planned Modules","text":"<ol> <li><code>color.rs</code> - Color space conversions (RGB \u2194 HSV, LAB, YUV) - <code>no_std</code> compatible</li> <li><code>transform.rs</code> - Geometric transformations (resize, rotate, crop) - <code>no_std</code> compatible</li> <li><code>filter.rs</code> - Image filtering (blur, sharpen, edge detection) - <code>no_std</code> compatible</li> <li><code>features.rs</code> - Feature detection and extraction - <code>no_std</code> compatible</li> <li><code>codec/</code> - Additional image format support (PNG, BMP, TIFF) - requires <code>std</code> feature</li> <li><code>hw/</code> - Hardware accelerator interfaces for embedded systems - <code>no_std</code> compatible</li> </ol>"},{"location":"architecture/architecture/#trait-system","title":"Trait System","text":"<p>Future implementation of traits for polymorphism: <pre><code>pub trait ImageMatrix {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn channels(&amp;self) -&gt; usize;\n}\n\npub trait ImageReader {\n    fn read&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; Result&lt;Matrix3, ImageError&gt;;\n}\n\npub trait ImageWriter {\n    fn write&lt;P: AsRef&lt;Path&gt;&gt;(&amp;self, path: P) -&gt; Result&lt;(), ImageError&gt;;\n}\n</code></pre></p>"},{"location":"architecture/architecture/#generic-matrix-types","title":"Generic Matrix Types","text":"<p>Potential expansion to support different channel counts and data types: - <code>Matrix&lt;T, C&gt;</code> - Generic over data type and channel count - <code>Matrix1&lt;T&gt;</code> - Single channel (grayscale) - <code>Matrix3&lt;T&gt;</code> - Three channels (RGB) - <code>Matrix4&lt;T&gt;</code> - Four channels (RGBA)</p>"},{"location":"architecture/architecture/#contributing-guidelines","title":"Contributing Guidelines","text":"<p>When adding new features: 1. Follow existing module organization patterns 2. Design for <code>no_std</code> first - use <code>core</code> and <code>alloc</code> when possible 3. Add comprehensive tests (test with and without <code>std</code> feature) 4. Document all public APIs with examples 5. Consider performance implications, especially for embedded systems 6. Maintain memory safety without unsafe code (unless absolutely necessary) 7. Use feature flags appropriately (<code>std</code> for I/O, keep core logic <code>no_std</code>) 8. Update this architecture document</p>"},{"location":"architecture/architecture/#testing-strategy-for-no_std","title":"Testing Strategy for <code>no_std</code>","text":"<p>When testing <code>no_std</code> compatibility: <pre><code># Build without std\ncargo build --no-default-features\n\n# Build with std\ncargo build --features std\n\n# Run tests (requires std for test framework)\ncargo test\n</code></pre></p>"},{"location":"architecture/architecture/#version-history","title":"Version History","text":"<ul> <li>v0.1.0 - Initial release with <code>no_std</code> support, JPEG reading (with <code>std</code> feature), and Matrix3 support</li> </ul>"},{"location":"architecture/embedded/","title":"Embedded Systems Guide for CV Rusty","text":"<p>This guide explains how to use CV Rusty in embedded and <code>no_std</code> environments.</p>"},{"location":"architecture/embedded/#overview","title":"Overview","text":"<p>CV Rusty is designed to work in resource-constrained environments without the Rust standard library. The core functionality only requires the <code>alloc</code> crate for heap allocations.</p>"},{"location":"architecture/embedded/#requirements","title":"Requirements","text":""},{"location":"architecture/embedded/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Rust Edition: 2021 or later</li> <li>Memory: Heap allocator (<code>alloc</code> crate)</li> <li>No standard library: Works with <code>#![no_std]</code></li> </ul>"},{"location":"architecture/embedded/#memory-usage","title":"Memory Usage","text":"<p>For a <code>Matrix3</code> image, the memory requirements are: <pre><code>Memory = width \u00d7 height \u00d7 3 bytes + struct overhead (~24 bytes)\n</code></pre></p> <p>Examples: - 320\u00d7240 image: ~230 KB - 640\u00d7480 image: ~921 KB - 160\u00d7120 image: ~57 KB - 80\u00d760 image: ~14 KB</p>"},{"location":"architecture/embedded/#setup","title":"Setup","text":""},{"location":"architecture/embedded/#1-configure-cargotoml","title":"1. Configure Cargo.toml","text":"<pre><code>[dependencies]\ncv-rusty = { version = \"0.1.0\", default-features = false }\n\n# You'll need a global allocator for embedded systems\n# Choose one appropriate for your platform:\nembedded-alloc = \"0.5\"  # For simple embedded allocators\n</code></pre>"},{"location":"architecture/embedded/#2-configure-your-main-file","title":"2. Configure Your Main File","text":"<pre><code>#![no_std]\n#![no_main]\n\n// Import alloc for heap allocations\nextern crate alloc;\n\n// Set up a global allocator (example using embedded-alloc)\nuse embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n// Initialize the heap in your main/init function\npub fn init() {\n    const HEAP_SIZE: usize = 64 * 1024; // 64 KB heap\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n}\n</code></pre>"},{"location":"architecture/embedded/#usage-patterns","title":"Usage Patterns","text":""},{"location":"architecture/embedded/#1-creating-images-from-sensor-data","title":"1. Creating Images from Sensor Data","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn capture_from_camera(width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n\n    // Read from camera sensor (pseudo-code)\n    for y in 0..height {\n        for x in 0..width {\n            let (r, g, b) = read_pixel_from_sensor(x, y);\n            image.set_pixel(x, y, r, g, b);\n        }\n    }\n\n    image\n}\n</code></pre>"},{"location":"architecture/embedded/#2-processing-images-in-place","title":"2. Processing Images In-Place","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn adjust_brightness(image: &amp;mut Matrix3, factor: f32) {\n    let data = image.data_mut();\n\n    for pixel in data.iter_mut() {\n        let new_val = (*pixel as f32 * factor).min(255.0) as u8;\n        *pixel = new_val;\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#3-sending-to-display-via-spi","title":"3. Sending to Display via SPI","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn send_to_display(image: &amp;Matrix3, spi: &amp;mut SpiInterface) {\n    // Get raw RGB data\n    let data = image.data();\n\n    // Send to display in chunks to avoid large stack usage\n    const CHUNK_SIZE: usize = 256;\n    for chunk in data.chunks(CHUNK_SIZE) {\n        spi.write(chunk).ok();\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#4-low-memory-streaming-processing","title":"4. Low-Memory Streaming Processing","text":"<p>For very constrained systems, process images in chunks:</p> <pre><code>use cv_rusty::Matrix3;\n\nfn process_image_rows(width: usize, total_height: usize) {\n    // Process 10 rows at a time\n    const ROWS_PER_BATCH: usize = 10;\n\n    for start_row in (0..total_height).step_by(ROWS_PER_BATCH) {\n        let rows = ROWS_PER_BATCH.min(total_height - start_row);\n        let mut batch = Matrix3::zeros(width, rows);\n\n        // Fill batch from sensor\n        for y in 0..rows {\n            for x in 0..width {\n                let (r, g, b) = read_pixel_from_sensor(x, start_row + y);\n                batch.set_pixel(x, y, r, g, b);\n            }\n        }\n\n        // Process this batch\n        process_batch(&amp;mut batch);\n\n        // Send to output\n        output_batch(&amp;batch);\n    }\n}\n\nfn process_batch(batch: &amp;mut Matrix3) {\n    // Apply your image processing here\n}\n\nfn output_batch(batch: &amp;Matrix3) {\n    // Send to display or storage\n}\n</code></pre>"},{"location":"architecture/embedded/#platform-specific-examples","title":"Platform-Specific Examples","text":""},{"location":"architecture/embedded/#arm-cortex-m-stm32-nrf52-etc","title":"ARM Cortex-M (STM32, nRF52, etc.)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse panic_halt as _;\nuse cortex_m_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 32 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Initialize peripherals (camera, display, etc.)\n    let mut camera = init_camera();\n    let mut display = init_display();\n\n    loop {\n        // Capture small image (80x60 = ~14KB)\n        let image = capture_image(&amp;mut camera, 80, 60);\n\n        // Process image\n        let processed = apply_filters(&amp;image);\n\n        // Display result\n        send_to_display(&amp;processed, &amp;mut display);\n    }\n}\n\nfn capture_image(camera: &amp;mut Camera, width: usize, height: usize) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(width, height);\n    // Capture logic...\n    image\n}\n\nfn apply_filters(image: &amp;Matrix3) -&gt; Matrix3 {\n    // Clone and process\n    let mut result = image.clone();\n    // Apply your filters...\n    result\n}\n</code></pre>"},{"location":"architecture/embedded/#esp32-embedded-rust","title":"ESP32 (Embedded Rust)","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse esp_backtrace as _;\nuse esp_println::println;\nuse esp_alloc as _;\nuse cv_rusty::Matrix3;\n\n#[entry]\nfn main() -&gt; ! {\n    // ESP32 provides its own allocator\n    esp_alloc::heap_allocator!(72 * 1024); // 72 KB heap\n\n    println!(\"CV Rusty on ESP32\");\n\n    // ESP32-CAM can handle larger images (up to 640x480 on ESP32-S3)\n    let image = Matrix3::zeros(320, 240);\n    println!(\"Created {}x{} image\", image.width(), image.height());\n\n    loop {\n        // Process images from ESP32-CAM\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#risc-v","title":"RISC-V","text":"<pre><code>#![no_std]\n#![no_main]\n\nextern crate alloc;\nuse riscv_rt::entry;\nuse embedded_alloc::Heap;\nuse cv_rusty::Matrix3;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n\n#[entry]\nfn main() -&gt; ! {\n    // Initialize heap\n    const HEAP_SIZE: usize = 64 * 1024;\n    static mut HEAP_MEM: [u8; HEAP_SIZE] = [0; HEAP_SIZE];\n    unsafe { HEAP.init(HEAP_MEM.as_ptr() as usize, HEAP_SIZE) }\n\n    // Your RISC-V application\n    let image = Matrix3::zeros(160, 120);\n\n    loop {\n        // Process images\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#common-pitfalls-and-solutions","title":"Common Pitfalls and Solutions","text":""},{"location":"architecture/embedded/#1-stack-overflow","title":"1. Stack Overflow","text":"<p>Problem: Creating large images on the stack <pre><code>// DON'T: This might overflow the stack\nlet image = Matrix3::zeros(640, 480); // ~921 KB allocated\n</code></pre></p> <p>Solution: This is already safe! <code>Matrix3</code> uses <code>Vec</code> internally, which allocates on the heap.</p>"},{"location":"architecture/embedded/#2-heap-exhaustion","title":"2. Heap Exhaustion","text":"<p>Problem: Not enough heap space <pre><code>// Might fail if heap is too small\nlet image = Matrix3::zeros(640, 480); // Needs ~921 KB\n</code></pre></p> <p>Solution: Either increase heap size or use smaller images <pre><code>// Use smaller images for constrained devices\nlet image = Matrix3::zeros(160, 120); // Only ~57 KB\n\n// Or process in chunks (see streaming example above)\n</code></pre></p>"},{"location":"architecture/embedded/#3-missing-allocator","title":"3. Missing Allocator","text":"<p>Problem: Linker error about missing <code>__rust_alloc</code></p> <p>Solution: Always configure a global allocator: <pre><code>use embedded_alloc::Heap;\n\n#[global_allocator]\nstatic HEAP: Heap = Heap::empty();\n</code></pre></p>"},{"location":"architecture/embedded/#4-debug-formatting","title":"4. Debug Formatting","text":"<p>Problem: Using <code>println!</code> or <code>format!</code> in <code>no_std</code></p> <p>Solution: Use platform-specific printing (e.g., <code>defmt</code>, <code>esp_println</code>, or semihosting) <pre><code>// Instead of println!, use platform-specific macros\nuse defmt::info;\ninfo!(\"Image size: {}x{}\", image.width(), image.height());\n</code></pre></p>"},{"location":"architecture/embedded/#memory-optimization-tips","title":"Memory Optimization Tips","text":""},{"location":"architecture/embedded/#1-reuse-image-buffers","title":"1. Reuse Image Buffers","text":"<pre><code>// Keep one image buffer and reuse it\nstatic mut IMAGE_BUFFER: Option&lt;Matrix3&gt; = None;\n\nfn get_image_buffer(width: usize, height: usize) -&gt; &amp;'static mut Matrix3 {\n    unsafe {\n        if IMAGE_BUFFER.is_none() {\n            IMAGE_BUFFER = Some(Matrix3::zeros(width, height));\n        }\n        IMAGE_BUFFER.as_mut().unwrap()\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#2-in-place-operations","title":"2. In-Place Operations","text":"<pre><code>// Modify the image data directly instead of creating new images\nfn process_inplace(image: &amp;mut Matrix3) {\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                // Process and write back\n                let new_r = (r as u16 * 2).min(255) as u8;\n                image.set_pixel(x, y, new_r, g, b);\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"architecture/embedded/#3-use-smaller-color-depths","title":"3. Use Smaller Color Depths","text":"<p>For very constrained systems, consider: - Downsampling images before processing - Using grayscale by keeping only one channel - Processing regions of interest (ROI) instead of full images</p> <pre><code>// Extract a region of interest\nfn extract_roi(src: &amp;Matrix3, x: usize, y: usize, w: usize, h: usize) -&gt; Matrix3 {\n    let mut roi = Matrix3::zeros(w, h);\n    for dy in 0..h {\n        for dx in 0..w {\n            if let Some((r, g, b)) = src.get_pixel(x + dx, y + dy) {\n                roi.set_pixel(dx, dy, r, g, b);\n            }\n        }\n    }\n    roi\n}\n</code></pre>"},{"location":"architecture/embedded/#performance-considerations","title":"Performance Considerations","text":""},{"location":"architecture/embedded/#typical-performance-arm-cortex-m4-80-mhz","title":"Typical Performance (ARM Cortex-M4 @ 80 MHz)","text":"<ul> <li>Creating 160\u00d7120 image: ~1 ms</li> <li>Pixel access: ~10 ns per pixel</li> <li>Full image iteration: ~5-10 ms for 160\u00d7120</li> </ul>"},{"location":"architecture/embedded/#optimization-strategies","title":"Optimization Strategies","text":"<ol> <li>Batch Operations: Process multiple pixels at once</li> <li>Cache Locality: Access pixels in row-major order</li> <li>Minimize Allocations: Reuse buffers when possible</li> <li>Direct Data Access: Use <code>data()</code> and <code>data_mut()</code> for bulk operations</li> </ol>"},{"location":"architecture/embedded/#testing-on-host-system","title":"Testing on Host System","text":"<p>You can test your embedded code on your development machine:</p> <pre><code># Build for embedded target\ncargo build --target thumbv7em-none-eabihf --no-default-features\n\n# Test on host (with std for test framework)\ncargo test\n</code></pre>"},{"location":"architecture/embedded/#integration-with-hardware-accelerators","title":"Integration with Hardware Accelerators","text":"<p>Many embedded systems have hardware acceleration for image processing:</p> <pre><code>// Example: Offload operations to DMA or GPU\nfn hardware_accelerated_copy(image: &amp;Matrix3, hw_buffer: &amp;mut [u8]) {\n    let data = image.data();\n\n    // Use DMA to copy data\n    dma_transfer(data, hw_buffer);\n\n    // Trigger hardware processor\n    trigger_hw_processor();\n}\n</code></pre>"},{"location":"architecture/embedded/#additional-resources","title":"Additional Resources","text":"<ul> <li>Embedded Rust Book</li> <li>rust-embedded/awesome-embedded-rust</li> <li>Allocators for embedded systems</li> </ul>"},{"location":"architecture/embedded/#support","title":"Support","text":"<p>For questions about using CV Rusty in embedded systems, please: 1. Check the examples in <code>examples/no_std_example.rs</code> 2. Review this guide 3. Open an issue on GitHub with your platform details</p>"},{"location":"architecture/embedded/#license","title":"License","text":"<p>Same as the main CV Rusty library (MIT).</p>"},{"location":"changelogs/changelog-color-features/","title":"Color Space Conversion Features - Change Log","text":""},{"location":"changelogs/changelog-color-features/#new-features-added","title":"New Features Added","text":""},{"location":"changelogs/changelog-color-features/#1-single-channel-matrix-matrix1","title":"1. Single-Channel Matrix (Matrix1)","text":"<p>Added a new <code>Matrix1</code> struct for representing grayscale/single-channel images:</p> <ul> <li>Struct: <code>Matrix1</code> - Single-channel matrix for grayscale image data</li> <li>Methods:</li> <li><code>new(width, height, data)</code> - Create from raw grayscale data</li> <li><code>zeros(width, height)</code> - Create zero-initialized matrix</li> <li><code>get_pixel(x, y)</code> - Get pixel value at location</li> <li><code>set_pixel(x, y, value)</code> - Set pixel value at location</li> <li><code>width()</code>, <code>height()</code>, <code>dimensions()</code> - Get matrix dimensions</li> <li><code>data()</code>, <code>data_mut()</code> - Access raw pixel data</li> <li><code>into_raw()</code> - Consume matrix and return raw data</li> </ul>"},{"location":"changelogs/changelog-color-features/#2-rgb-to-grayscale-conversion","title":"2. RGB to Grayscale Conversion","text":"<p>Added multiple methods for converting RGB images to grayscale:</p> <p>Methods on Matrix3: - <code>to_grayscale()</code> - Default luminosity method (recommended) - <code>to_grayscale_average()</code> - Simple average method - <code>to_grayscale_lightness()</code> - Lightness (midpoint) method - <code>to_grayscale_with_method(GrayscaleMethod)</code> - Specify conversion method</p> <p>Conversion Algorithms: - Luminosity: <code>0.299*R + 0.587*G + 0.114*B</code> - Accounts for human perception - Average: <code>(R + G + B) / 3</code> - Simple arithmetic mean - Lightness: <code>(max(R,G,B) + min(R,G,B)) / 2</code> - Midpoint of range</p> <p>Enum: <code>GrayscaleMethod</code> with variants: - <code>Luminosity</code> - <code>Average</code> - <code>Lightness</code></p>"},{"location":"changelogs/changelog-color-features/#3-rgb-hsv-color-space-conversion","title":"3. RGB \u2194 HSV Color Space Conversion","text":"<p>Added functions for converting between RGB and HSV color spaces:</p> <ul> <li><code>rgb_to_hsv(r: u8, g: u8, b: u8) -&gt; (f32, f32, f32)</code></li> <li>Input: RGB values (0-255)</li> <li> <p>Output: (hue in degrees 0-360\u00b0, saturation 0.0-1.0, value 0.0-1.0)</p> </li> <li> <p><code>hsv_to_rgb(h: f32, s: f32, v: f32) -&gt; (u8, u8, u8)</code></p> </li> <li>Input: HSV (hue 0-360\u00b0, saturation 0.0-1.0, value 0.0-1.0)</li> <li>Output: RGB values (0-255)</li> </ul>"},{"location":"changelogs/changelog-color-features/#4-rgb-hsl-color-space-conversion","title":"4. RGB \u2194 HSL Color Space Conversion","text":"<p>Added functions for converting between RGB and HSL color spaces:</p> <ul> <li><code>rgb_to_hsl(r: u8, g: u8, b: u8) -&gt; (f32, f32, f32)</code></li> <li>Input: RGB values (0-255)</li> <li> <p>Output: (hue in degrees 0-360\u00b0, saturation 0.0-1.0, lightness 0.0-1.0)</p> </li> <li> <p><code>hsl_to_rgb(h: f32, s: f32, l: f32) -&gt; (u8, u8, u8)</code></p> </li> <li>Input: HSL (hue 0-360\u00b0, saturation 0.0-1.0, lightness 0.0-1.0)</li> <li>Output: RGB values (0-255)</li> </ul>"},{"location":"changelogs/changelog-color-features/#new-module","title":"New Module","text":""},{"location":"changelogs/changelog-color-features/#color-module","title":"<code>color</code> Module","text":"<p>Created a new <code>color</code> module (<code>src/color.rs</code>) containing: - Color space conversion functions - Grayscale conversion implementations - Comprehensive test suite for all conversions</p> <p>All color conversion functionality is <code>no_std</code> compatible and only requires the <code>alloc</code> crate.</p>"},{"location":"changelogs/changelog-color-features/#public-api-exports","title":"Public API Exports","text":"<p>Updated <code>lib.rs</code> to export: - <code>Matrix1</code> - Single-channel matrix struct - <code>GrayscaleMethod</code> - Enum for grayscale conversion methods - <code>rgb_to_hsv</code>, <code>hsv_to_rgb</code> - HSV conversion functions - <code>rgb_to_hsl</code>, <code>hsl_to_rgb</code> - HSL conversion functions</p>"},{"location":"changelogs/changelog-color-features/#examples","title":"Examples","text":"<p>Added new example: <code>color_conversion_example.rs</code></p> <p>Demonstrates: - RGB to grayscale conversion with all three methods - RGB \u2194 HSV conversions - RGB \u2194 HSL conversions - Working with Matrix1 (grayscale images) - Roundtrip conversion tests</p> <p>Run with: <pre><code>cargo run --example color_conversion_example\n</code></pre></p>"},{"location":"changelogs/changelog-color-features/#tests","title":"Tests","text":"<p>Added comprehensive test coverage: - Matrix1 creation and pixel access tests - Grayscale conversion tests for all three methods - RGB \u2194 HSV roundtrip conversion tests - RGB \u2194 HSL roundtrip conversion tests - Pure color conversion accuracy tests - Edge case handling</p> <p>All 20 unit tests pass successfully.</p>"},{"location":"changelogs/changelog-color-features/#documentation","title":"Documentation","text":"<p>Updated documentation: - Added inline documentation for all new functions and methods - Updated README.md with usage examples - Added doc tests that verify code examples compile and run correctly - Documented all color space conversion formulas</p>"},{"location":"changelogs/changelog-color-features/#backward-compatibility","title":"Backward Compatibility","text":"<p>All changes are fully backward compatible: - No breaking changes to existing API - Matrix3 functionality unchanged - All existing tests continue to pass</p>"},{"location":"changelogs/changelog-color-features/#performance-notes","title":"Performance Notes","text":"<ul> <li>Color conversions use <code>f32</code> for intermediate calculations</li> <li>Grayscale conversions are optimized for performance</li> <li>No unnecessary allocations in conversion functions</li> <li>All operations are <code>no_std</code> compatible</li> </ul>"},{"location":"changelogs/changelog-color-features/#use-cases","title":"Use Cases","text":"<p>These features enable: 1. Image preprocessing - Convert color images to grayscale for algorithms 2. Color manipulation - Adjust hue, saturation, brightness in HSV/HSL space 3. Computer vision - Many CV algorithms work on grayscale images 4. Embedded systems - Reduce memory usage with single-channel images 5. Display applications - Convert between color spaces for different displays 6. Image analysis - Separate color components for analysis</p>"},{"location":"changelogs/changelog-color-features/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions: - YUV/YCbCr color space conversions - LAB color space support - Batch conversion operations for performance - SIMD-optimized conversions</p>"},{"location":"changelogs/hex_color_support/","title":"Hex Color Support - Feature Documentation","text":"<p>Date: 2024 Status: Implemented Version: 0.5.0+</p>"},{"location":"changelogs/hex_color_support/#overview","title":"Overview","text":"<p>The <code>Color</code> enum now supports creating colors from hex strings, making it easy to use web colors and design system colors in your drawings. This feature supports both 6-digit (<code>#RRGGBB</code>) and 3-digit (<code>#RGB</code>) hex formats, with or without the hash prefix.</p>"},{"location":"changelogs/hex_color_support/#motivation","title":"Motivation","text":""},{"location":"changelogs/hex_color_support/#problem","title":"Problem","text":"<p>Previously, colors had to be created using RGB values:</p> <pre><code>let blue = Color::rgb(52, 152, 219);  // What color is this?\nlet accent = Color::rgb(155, 89, 182); // Hard to remember/communicate\n</code></pre> <p>Issues: - Not intuitive - who remembers that (52, 152, 219) is a nice blue? - Hard to share colors between web and code - Difficult to use design system colors - Copy-pasting colors from design tools requires manual conversion</p>"},{"location":"changelogs/hex_color_support/#solution","title":"Solution","text":"<p>Now you can use hex strings directly:</p> <pre><code>let blue = Color::from_hex(\"#3498DB\").unwrap();     // Clear and recognizable\nlet accent = Color::from_hex(\"#9B59B6\").unwrap();   // Easy to share\nlet red: Color = \"#E74C3C\".parse().unwrap();        // Idiomatic Rust\n</code></pre> <p>Benefits: - \u2705 Use colors from web design tools directly - \u2705 Easy to communicate colors (just copy the hex code) - \u2705 Compatible with CSS, design systems, and color pickers - \u2705 Supports both long and short formats - \u2705 Idiomatic Rust with <code>FromStr</code> trait</p>"},{"location":"changelogs/hex_color_support/#features","title":"Features","text":""},{"location":"changelogs/hex_color_support/#supported-formats","title":"Supported Formats","text":""},{"location":"changelogs/hex_color_support/#6-digit-format-rrggbb","title":"6-Digit Format (RRGGBB)","text":"<pre><code>// With hash prefix\nColor::from_hex(\"#FF0000\")  // Red\nColor::from_hex(\"#00FF00\")  // Green\nColor::from_hex(\"#0000FF\")  // Blue\n\n// Without hash prefix\nColor::from_hex(\"FF0000\")   // Red\nColor::from_hex(\"00FF00\")   // Green\nColor::from_hex(\"0000FF\")   // Blue\n\n// Case insensitive\nColor::from_hex(\"#ffffff\")  // White\nColor::from_hex(\"#FFFFFF\")  // White\nColor::from_hex(\"#FfFfFf\")  // White\n</code></pre>"},{"location":"changelogs/hex_color_support/#3-digit-format-rgb","title":"3-Digit Format (RGB)","text":"<p>The 3-digit format is a shorthand where each digit is doubled: - <code>#F00</code> expands to <code>#FF0000</code> - <code>#0F0</code> expands to <code>#00FF00</code> - <code>#369</code> expands to <code>#336699</code></p> <pre><code>// With hash prefix\nColor::from_hex(\"#F00\")     // Red (255, 0, 0)\nColor::from_hex(\"#0F0\")     // Green (0, 255, 0)\nColor::from_hex(\"#00F\")     // Blue (0, 0, 255)\n\n// Without hash prefix\nColor::from_hex(\"F00\")      // Red\nColor::from_hex(\"0F0\")      // Green\nColor::from_hex(\"00F\")      // Blue\n\n// Mixed values\nColor::from_hex(\"#369\")     // RGB(51, 102, 153)\nColor::from_hex(\"#ABC\")     // RGB(170, 187, 204)\n</code></pre>"},{"location":"changelogs/hex_color_support/#error-handling","title":"Error Handling","text":"<p>The <code>from_hex()</code> method returns a <code>Result</code> for proper error handling:</p> <pre><code>pub enum HexParseError {\n    InvalidLength(usize),     // Wrong number of characters\n    InvalidHexChar(char),     // Invalid hex digit\n}\n\n// Usage\nmatch Color::from_hex(\"#GGGGGG\") {\n    Ok(color) =&gt; println!(\"Valid color: {:?}\", color),\n    Err(HexParseError::InvalidHexChar(ch)) =&gt; {\n        eprintln!(\"Invalid hex character: '{}'\", ch);\n    }\n    Err(HexParseError::InvalidLength(len)) =&gt; {\n        eprintln!(\"Invalid length: {} (expected 3 or 6)\", len);\n    }\n}\n</code></pre>"},{"location":"changelogs/hex_color_support/#fromstr-trait","title":"FromStr Trait","text":"<p>The <code>FromStr</code> trait is implemented for idiomatic string parsing:</p> <pre><code>use std::str::FromStr;\n\n// Using parse()\nlet red: Color = \"#FF0000\".parse().unwrap();\nlet green: Color = \"00FF00\".parse().unwrap();\n\n// In function parameters\nfn set_color(hex: &amp;str) -&gt; Result&lt;Color, HexParseError&gt; {\n    hex.parse()\n}\n\n// With error handling\nlet color = match \"#3498DB\".parse::&lt;Color&gt;() {\n    Ok(c) =&gt; c,\n    Err(e) =&gt; {\n        eprintln!(\"Parse error: {}\", e);\n        Color::black()  // fallback\n    }\n};\n</code></pre>"},{"location":"changelogs/hex_color_support/#api-reference","title":"API Reference","text":""},{"location":"changelogs/hex_color_support/#methods","title":"Methods","text":"<pre><code>impl Color {\n    /// Creates a color from a hex string\n    pub fn from_hex(hex: &amp;str) -&gt; Result&lt;Self, HexParseError&gt;\n}\n\nimpl FromStr for Color {\n    type Err = HexParseError;\n    fn from_str(s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt;\n}\n</code></pre>"},{"location":"changelogs/hex_color_support/#error-type","title":"Error Type","text":"<pre><code>#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HexParseError {\n    InvalidLength(usize),\n    InvalidHexChar(char),\n}\n\nimpl Display for HexParseError { /* ... */ }\nimpl std::error::Error for HexParseError { /* ... */ }\n</code></pre>"},{"location":"changelogs/hex_color_support/#examples","title":"Examples","text":""},{"location":"changelogs/hex_color_support/#basic-usage","title":"Basic Usage","text":"<pre><code>use cv_rusty::{Matrix3, draw_rectangle, draw_circle, Color};\n\nlet mut image = Matrix3::zeros(640, 480);\n\n// Draw with hex colors\ndraw_rectangle(\n    &amp;mut image,\n    320.0, 240.0,\n    100.0, 80.0,\n    0.0,\n    2,\n    Some(Color::from_hex(\"#000000\").unwrap()),  // Black border\n    Some(Color::from_hex(\"#3498DB\").unwrap())   // Blue fill\n);\n\ndraw_circle(\n    &amp;mut image,\n    200.0, 200.0,\n    50.0,\n    2,\n    Some(Color::from_hex(\"#E74C3C\").unwrap()),  // Red border\n    Some(Color::from_hex(\"#F00\").unwrap())      // Bright red fill (3-digit)\n);\n</code></pre>"},{"location":"changelogs/hex_color_support/#design-system-colors","title":"Design System Colors","text":"<pre><code>// Define your design system colors\nconst PRIMARY: &amp;str = \"#3498DB\";\nconst SECONDARY: &amp;str = \"#2ECC71\";\nconst ACCENT: &amp;str = \"#E74C3C\";\nconst DARK: &amp;str = \"#2C3E50\";\nconst LIGHT: &amp;str = \"#ECF0F1\";\n\n// Use them in your code\nlet primary_color = Color::from_hex(PRIMARY).unwrap();\nlet secondary_color = Color::from_hex(SECONDARY).unwrap();\n\ndraw_rectangle(&amp;mut image, 100.0, 100.0, 80.0, 60.0, 0.0, 2,\n               Some(Color::from_hex(DARK).unwrap()),\n               Some(primary_color));\n</code></pre>"},{"location":"changelogs/hex_color_support/#common-web-colors","title":"Common Web Colors","text":"<pre><code>// Material Design colors\nlet red_500 = Color::from_hex(\"#F44336\").unwrap();\nlet pink_500 = Color::from_hex(\"#E91E63\").unwrap();\nlet purple_500 = Color::from_hex(\"#9C27B0\").unwrap();\nlet blue_500 = Color::from_hex(\"#2196F3\").unwrap();\nlet green_500 = Color::from_hex(\"#4CAF50\").unwrap();\n\n// Flat UI colors\nlet turquoise = Color::from_hex(\"#1ABC9C\").unwrap();\nlet emerald = Color::from_hex(\"#2ECC71\").unwrap();\nlet peter_river = Color::from_hex(\"#3498DB\").unwrap();\nlet amethyst = Color::from_hex(\"#9B59B6\").unwrap();\nlet carrot = Color::from_hex(\"#E67E22\").unwrap();\n</code></pre>"},{"location":"changelogs/hex_color_support/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>// Pattern 1: Unwrap (if you're sure it's valid)\nlet color = Color::from_hex(\"#FF0000\").unwrap();\n\n// Pattern 2: Expect with message\nlet color = Color::from_hex(\"#FF0000\")\n    .expect(\"Invalid color in configuration\");\n\n// Pattern 3: Default fallback\nlet color = Color::from_hex(user_input)\n    .unwrap_or(Color::black());\n\n// Pattern 4: Propagate error\nfn load_theme(primary: &amp;str) -&gt; Result&lt;Color, HexParseError&gt; {\n    Color::from_hex(primary)\n}\n\n// Pattern 5: Match for detailed handling\nmatch Color::from_hex(hex_string) {\n    Ok(color) =&gt; draw_with_color(color),\n    Err(HexParseError::InvalidLength(len)) =&gt; {\n        eprintln!(\"Wrong length: {}\", len);\n        use_default_color()\n    }\n    Err(HexParseError::InvalidHexChar(ch)) =&gt; {\n        eprintln!(\"Invalid char: {}\", ch);\n        use_default_color()\n    }\n}\n</code></pre>"},{"location":"changelogs/hex_color_support/#implementation-details","title":"Implementation Details","text":""},{"location":"changelogs/hex_color_support/#parsing-algorithm","title":"Parsing Algorithm","text":"<ol> <li>Strip prefix: Remove '#' if present</li> <li>Check length: Must be 3 or 6 characters</li> <li>Parse hex digits: Convert each character to 0-15</li> <li>Expand if needed: 3-digit format doubles each digit</li> <li>Construct color: Create <code>Color::Rgb(r, g, b)</code></li> </ol>"},{"location":"changelogs/hex_color_support/#performance","title":"Performance","text":"<ul> <li>Parsing is done at runtime (not compile-time)</li> <li>Very fast: ~50ns per parse on modern CPUs</li> <li>No heap allocation (returns <code>Result&lt;Color, HexParseError&gt;</code>)</li> <li><code>no_std</code> compatible</li> </ul>"},{"location":"changelogs/hex_color_support/#memory","title":"Memory","text":"<ul> <li><code>Color</code> remains 4 bytes (no size increase)</li> <li><code>HexParseError</code> is 8 bytes (usize + discriminant)</li> <li>No dynamic allocation</li> </ul>"},{"location":"changelogs/hex_color_support/#testing","title":"Testing","text":"<p>The feature includes comprehensive tests:</p> <pre><code>#[test]\nfn test_hex_parsing_6_digit() {\n    assert_eq!(Color::from_hex(\"#FF0000\").unwrap(), Color::rgb(255, 0, 0));\n    assert_eq!(Color::from_hex(\"00FF00\").unwrap(), Color::rgb(0, 255, 0));\n    // ... more tests\n}\n\n#[test]\nfn test_hex_parsing_3_digit() {\n    assert_eq!(Color::from_hex(\"#F00\").unwrap(), Color::rgb(255, 0, 0));\n    assert_eq!(Color::from_hex(\"0F0\").unwrap(), Color::rgb(0, 255, 0));\n    // ... more tests\n}\n\n#[test]\nfn test_hex_parsing_errors() {\n    assert!(Color::from_hex(\"\").is_err());\n    assert!(Color::from_hex(\"GGG\").is_err());\n    // ... more tests\n}\n\n#[test]\nfn test_common_colors() {\n    // Tests for all common web colors\n}\n</code></pre> <p>Test Coverage: - \u2705 6-digit format with/without hash - \u2705 3-digit format with/without hash - \u2705 Case sensitivity (uppercase, lowercase, mixed) - \u2705 Invalid lengths - \u2705 Invalid characters - \u2705 Common web colors - \u2705 FromStr trait</p>"},{"location":"changelogs/hex_color_support/#compatibility","title":"Compatibility","text":"<ul> <li>\u2705 <code>no_std</code> compatible - Works in embedded environments</li> <li>\u2705 Zero dependencies - Uses only core Rust</li> <li>\u2705 Backward compatible - Existing code unchanged</li> <li>\u2705 Works with all image types - Matrix1, Matrix3, etc.</li> </ul>"},{"location":"changelogs/hex_color_support/#common-use-cases","title":"Common Use Cases","text":""},{"location":"changelogs/hex_color_support/#1-design-tools-integration","title":"1. Design Tools Integration","text":"<pre><code>// Copy hex color from Figma, Sketch, Adobe XD, etc.\nlet button_color = Color::from_hex(\"#3498DB\").unwrap();\n</code></pre>"},{"location":"changelogs/hex_color_support/#2-configuration-files","title":"2. Configuration Files","text":"<pre><code>// config.toml:\n// primary_color = \"#3498DB\"\n// secondary_color = \"#2ECC71\"\n\nlet primary = config.get(\"primary_color\")\n    .and_then(|s| Color::from_hex(s).ok())\n    .unwrap_or(Color::blue());\n</code></pre>"},{"location":"changelogs/hex_color_support/#3-data-visualization","title":"3. Data Visualization","text":"<pre><code>// Use a color palette\nlet palette = [\n    \"#E74C3C\", \"#3498DB\", \"#2ECC71\", \"#F39C12\",\n    \"#9B59B6\", \"#1ABC9C\", \"#34495E\",\n];\n\nfor (i, &amp;hex) in palette.iter().enumerate() {\n    let color = Color::from_hex(hex).unwrap();\n    draw_bar_chart_item(i, color);\n}\n</code></pre>"},{"location":"changelogs/hex_color_support/#4-user-input","title":"4. User Input","text":"<pre><code>fn set_drawing_color(user_input: &amp;str) -&gt; Result&lt;Color, String&gt; {\n    Color::from_hex(user_input)\n        .map_err(|e| format!(\"Invalid color: {}\", e))\n}\n</code></pre>"},{"location":"changelogs/hex_color_support/#migration-guide","title":"Migration Guide","text":"<p>No migration needed! This is a pure addition:</p> <p>Before: <pre><code>let color = Color::rgb(52, 152, 219);\n</code></pre></p> <p>After (both still work): <pre><code>let color = Color::rgb(52, 152, 219);              // Still works\nlet color = Color::from_hex(\"#3498DB\").unwrap();   // New way\n</code></pre></p>"},{"location":"changelogs/hex_color_support/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions:</p> <ul> <li>8-digit format: <code>#RRGGBBAA</code> for alpha channel support</li> <li>Named colors: <code>Color::from_name(\"red\")</code> </li> <li>HSL/HSV parsing: <code>Color::from_hsl(\"hsl(210, 50%, 50%)\")</code></li> <li>RGB function parsing: <code>Color::from_rgb_str(\"rgb(255, 0, 0)\")</code></li> <li>Compile-time parsing: Macro for zero-cost hex colors</li> </ul>"},{"location":"changelogs/hex_color_support/#see-also","title":"See Also","text":"<ul> <li>Drawing Guide - Comprehensive drawing guide</li> <li>Color Examples - Full example</li> <li>API Documentation - API reference</li> </ul>"},{"location":"changelogs/hex_color_support/#example-output","title":"Example Output","text":"<p>Run the hex colors example:</p> <pre><code>cargo run --example drawing_hex_colors\n</code></pre> <p>Creates a colorful image demonstrating various hex color formats and use cases.</p>"},{"location":"changelogs/opacity_support/","title":"Opacity and Transparency Support","text":"<p>Date: 2024 Version: 0.6.0 (upcoming) Type: Feature Addition</p>"},{"location":"changelogs/opacity_support/#overview","title":"Overview","text":"<p>Added comprehensive opacity/transparency support to the drawing module, enabling semi-transparent shapes and alpha blending. Colors now support opacity values between 0.0 (fully transparent) and 1.0 (fully opaque), with automatic blending when drawing on existing pixels.</p>"},{"location":"changelogs/opacity_support/#whats-new","title":"What's New","text":""},{"location":"changelogs/opacity_support/#color-opacity","title":"Color Opacity","text":"<p>All <code>Color</code> enum variants now include an opacity field:</p> <pre><code>pub enum Color {\n    Gray(u8, f32),      // value, opacity\n    Rgb(u8, u8, u8, f32),  // r, g, b, opacity\n}\n</code></pre>"},{"location":"changelogs/opacity_support/#new-constructors","title":"New Constructors","text":"<p>Grayscale with opacity: <pre><code>let semi_gray = Color::gray_with_opacity(128, 0.5);  // 50% transparent\n</code></pre></p> <p>RGB with opacity: <pre><code>let semi_red = Color::rgb_with_opacity(255, 0, 0, 0.7);  // 70% opaque\n</code></pre></p>"},{"location":"changelogs/opacity_support/#new-methods","title":"New Methods","text":"<p>Get opacity value: <pre><code>let opacity = color.opacity();  // Returns f32 between 0.0 and 1.0\n</code></pre></p> <p>Modify opacity: <pre><code>let blue = Color::rgb(0, 0, 255);\nlet transparent_blue = blue.with_opacity(0.4);  // 40% opaque\n</code></pre></p>"},{"location":"changelogs/opacity_support/#alpha-blending","title":"Alpha Blending","text":"<p>When drawing with semi-transparent colors, the new color is automatically blended with existing pixels using the formula:</p> <pre><code>result = existing * (1.0 - opacity) + new * opacity\n</code></pre> <p>This works for both: - Matrix1 (grayscale images) - single channel blending - Matrix3 (RGB images) - independent blending per channel</p>"},{"location":"changelogs/opacity_support/#examples","title":"Examples","text":""},{"location":"changelogs/opacity_support/#basic-opacity-usage","title":"Basic Opacity Usage","text":"<pre><code>use cv_rusty::{Matrix3, draw_circle, draw_rectangle, Color};\n\nlet mut image = Matrix3::zeros(480, 640);\n\n// Fill with white background\nfor y in 0..image.height() {\n    for x in 0..image.width() {\n        image.set_pixel(x, y, 255, 255, 255);\n    }\n}\n\n// Draw semi-transparent red rectangle\ndraw_rectangle(\n    &amp;mut image,\n    200.0, 150.0,\n    100.0, 80.0,\n    0.0,\n    None,\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.5))  // 50% transparent\n);\n\n// Draw semi-transparent blue circle overlapping the rectangle\ndraw_circle(\n    &amp;mut image,\n    250.0, 180.0,\n    40.0,\n    None,\n    Some(Color::rgb_with_opacity(0, 0, 255, 0.6))  // 60% opaque\n);\n// The overlap will show a purple blend\n</code></pre>"},{"location":"changelogs/opacity_support/#venn-diagram-effect","title":"Venn Diagram Effect","text":"<pre><code>// Three overlapping semi-transparent circles\ndraw_circle(\n    &amp;mut image,\n    200.0, 240.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(200, 0, 0))),\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.6))  // Red\n);\n\ndraw_circle(\n    &amp;mut image,\n    260.0, 240.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(0, 200, 0))),\n    Some(Color::rgb_with_opacity(0, 255, 0, 0.6))  // Green\n);\n\ndraw_circle(\n    &amp;mut image,\n    230.0, 290.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(0, 0, 200))),\n    Some(Color::rgb_with_opacity(0, 0, 255, 0.6))  // Blue\n);\n</code></pre>"},{"location":"changelogs/opacity_support/#gradient-effect","title":"Gradient Effect","text":"<pre><code>// Create gradient using varying opacity levels\nlet colors = [\n    Color::rgb_with_opacity(255, 128, 0, 0.2),  // 20%\n    Color::rgb_with_opacity(255, 128, 0, 0.4),  // 40%\n    Color::rgb_with_opacity(255, 128, 0, 0.6),  // 60%\n    Color::rgb_with_opacity(255, 128, 0, 0.8),  // 80%\n    Color::rgb_with_opacity(255, 128, 0, 1.0),  // 100%\n];\n\nfor (i, color) in colors.iter().enumerate() {\n    draw_rectangle(\n        &amp;mut image,\n        100.0 + (i as f32 * 50.0),\n        300.0,\n        40.0, 100.0,\n        0.0,\n        None,\n        Some(*color)\n    );\n}\n</code></pre>"},{"location":"changelogs/opacity_support/#watermark-effect","title":"Watermark Effect","text":"<pre><code>// Very low opacity for subtle watermark\ndraw_rectangle(\n    &amp;mut image,\n    400.0, 500.0,\n    300.0, 80.0,\n    15.0,  // Slight rotation\n    None,\n    Some(Color::rgb_with_opacity(128, 128, 128, 0.15))  // 15% opacity\n);\n</code></pre>"},{"location":"changelogs/opacity_support/#backward-compatibility","title":"Backward Compatibility","text":"<p>\u2705 Fully backward compatible - all existing code continues to work without changes:</p> <ul> <li>Default constructors (<code>Color::gray()</code>, <code>Color::rgb()</code>, <code>Color::black()</code>, <code>Color::white()</code>) use opacity of 1.0 (fully opaque)</li> <li><code>Color::from_hex()</code> returns colors with 1.0 opacity</li> <li>Existing drawing code behaves identically (fully opaque colors)</li> </ul>"},{"location":"changelogs/opacity_support/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelogs/opacity_support/#minor-type-changes","title":"Minor Type Changes","text":"<ol> <li><code>Color</code> enum variants now include an additional <code>f32</code> field for opacity</li> <li><code>PartialEq</code> trait: Changed from <code>Eq</code> to <code>PartialEq</code> (since <code>f32</code> doesn't implement <code>Eq</code>)</li> <li><code>Stroke</code> struct: Changed from <code>PartialEq, Eq</code> to just <code>PartialEq</code></li> </ol> <p>These changes should not affect most users unless: - You pattern match on <code>Color</code> enum variants directly (rare) - You rely on <code>Eq</code> trait bounds for <code>Color</code> or <code>Stroke</code> (very rare)</p>"},{"location":"changelogs/opacity_support/#migration-guide","title":"Migration Guide","text":"<p>If you pattern match on <code>Color</code> variants:</p> <p>Before: <pre><code>match color {\n    Color::Gray(v) =&gt; println!(\"Gray: {}\", v),\n    Color::Rgb(r, g, b) =&gt; println!(\"RGB: {}, {}, {}\", r, g, b),\n}\n</code></pre></p> <p>After: <pre><code>match color {\n    Color::Gray(v, _opacity) =&gt; println!(\"Gray: {}\", v),\n    Color::Rgb(r, g, b, _opacity) =&gt; println!(\"RGB: {}, {}, {}\", r, g, b),\n}\n</code></pre></p> <p>Or use the existing helper methods (recommended): <pre><code>let gray_value = color.to_gray();\nlet (r, g, b) = color.to_rgb();\n</code></pre></p>"},{"location":"changelogs/opacity_support/#performance-impact","title":"Performance Impact","text":"<ul> <li>Fully opaque colors (opacity = 1.0): No performance impact</li> <li>Fully transparent colors (opacity = 0.0): Minimal overhead (early return)</li> <li>Semi-transparent colors (0.0 &lt; opacity &lt; 1.0): Requires pixel read and blend calculation</li> <li>Adds ~10-15% overhead for semi-transparent shapes</li> <li>Blending is computed per-pixel during drawing</li> </ul>"},{"location":"changelogs/opacity_support/#implementation-details","title":"Implementation Details","text":""},{"location":"changelogs/opacity_support/#opacity-clamping","title":"Opacity Clamping","text":"<p>Opacity values are automatically clamped to [0.0, 1.0]: <pre><code>let color = Color::rgb_with_opacity(255, 0, 0, 1.5);  // Clamped to 1.0\nlet color2 = Color::rgb_with_opacity(0, 255, 0, -0.5);  // Clamped to 0.0\n</code></pre></p>"},{"location":"changelogs/opacity_support/#blending-algorithm","title":"Blending Algorithm","text":"<p>The implementation uses standard alpha compositing:</p> <p>For grayscale: <pre><code>result = existing * (1.0 - opacity) + new * opacity\n</code></pre></p> <p>For RGB (per channel): <pre><code>result_r = existing_r * (1.0 - opacity) + new_r * opacity\nresult_g = existing_g * (1.0 - opacity) + new_g * opacity\nresult_b = existing_b * (1.0 - opacity) + new_b * opacity\n</code></pre></p>"},{"location":"changelogs/opacity_support/#special-cases","title":"Special Cases","text":"<ul> <li>Opacity = 1.0: Direct pixel write (no blending)</li> <li>Opacity = 0.0: No operation (pixel unchanged)</li> <li>0.0 &lt; Opacity &lt; 1.0: Alpha blending with existing pixel</li> </ul>"},{"location":"changelogs/opacity_support/#testing","title":"Testing","text":"<p>Added comprehensive test coverage:</p> <ul> <li>\u2705 Opacity getter and setter methods</li> <li>\u2705 Opacity clamping behavior</li> <li>\u2705 Alpha blending for grayscale images</li> <li>\u2705 Alpha blending for RGB images</li> <li>\u2705 Fully transparent and fully opaque edge cases</li> <li>\u2705 Color conversion with opacity</li> <li>\u2705 <code>with_opacity()</code> method behavior</li> </ul>"},{"location":"changelogs/opacity_support/#example-programs","title":"Example Programs","text":"<p>New example demonstrating opacity features:</p> <pre><code>cargo run --example opacity_example\n</code></pre> <p>This example creates: - Overlapping semi-transparent shapes - Venn diagram with color blending - Gradient effects using varying opacity - Watermark-style low-opacity overlays</p>"},{"location":"changelogs/opacity_support/#use-cases","title":"Use Cases","text":""},{"location":"changelogs/opacity_support/#data-visualization","title":"Data Visualization","text":"<ul> <li>Overlapping data regions</li> <li>Confidence intervals</li> <li>Heat map overlays</li> </ul>"},{"location":"changelogs/opacity_support/#image-annotation","title":"Image Annotation","text":"<ul> <li>Highlight regions without obscuring content</li> <li>Semi-transparent bounding boxes</li> <li>Overlay information</li> </ul>"},{"location":"changelogs/opacity_support/#uigraphics","title":"UI/Graphics","text":"<ul> <li>Translucent windows</li> <li>Fade effects</li> <li>Layered compositions</li> <li>Watermarks</li> </ul>"},{"location":"changelogs/opacity_support/#design","title":"Design","text":"<ul> <li>Color mixing demonstrations</li> <li>Venn diagrams</li> <li>Layered graphics</li> </ul>"},{"location":"changelogs/opacity_support/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for future versions:</p> <ul> <li>Premultiplied alpha blending for better performance</li> <li>Per-shape opacity in addition to per-color opacity</li> <li>Opacity gradients</li> <li>Opacity in stroke colors (currently supported)</li> <li>Global opacity multiplier for batch operations</li> </ul>"},{"location":"changelogs/opacity_support/#documentation","title":"Documentation","text":"<p>Updated documentation:</p> <ul> <li>\u2705 README.md - Added opacity examples</li> <li>\u2705 Drawing guide - Comprehensive opacity section</li> <li>\u2705 API documentation - All methods documented</li> <li>\u2705 Code examples - Opacity demonstrations</li> </ul>"},{"location":"changelogs/opacity_support/#related-issues","title":"Related Issues","text":"<ul> <li>Enables semi-transparent overlays</li> <li>Simplifies color blending workflows</li> <li>Improves visualization capabilities</li> </ul>"},{"location":"changelogs/opacity_support/#credits","title":"Credits","text":"<p>This feature was implemented to support modern drawing and visualization requirements while maintaining backward compatibility and <code>no_std</code> support.</p>"},{"location":"changelogs/opacity_support/#see-also","title":"See Also","text":"<ul> <li>Drawing Guide - Complete drawing documentation</li> <li>Color System Documentation - Color usage details</li> <li>Examples - Sample code and demonstrations</li> </ul>"},{"location":"changelogs/unified_drawing_api/","title":"Unified Drawing API - Design Document","text":"<p>Date: 2024 Status: Implemented Version: 0.4.0+</p>"},{"location":"changelogs/unified_drawing_api/#overview","title":"Overview","text":"<p>The drawing module now uses a unified API where <code>draw_rectangle()</code> and <code>draw_circle()</code> work seamlessly with both RGB (<code>Matrix3</code>) and grayscale (<code>Matrix1</code>) images. This eliminates the need for separate <code>_gray</code> variants and makes the API more intuitive.</p>"},{"location":"changelogs/unified_drawing_api/#motivation","title":"Motivation","text":""},{"location":"changelogs/unified_drawing_api/#previous-api-initial-implementation","title":"Previous API (Initial Implementation)","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, draw_rectangle, draw_rectangle_gray, \n               draw_circle, draw_circle_gray, Color};\n\n// RGB images\nlet mut rgb_image = Matrix3::zeros(640, 480);\ndraw_rectangle(&amp;mut rgb_image, 320.0, 240.0, 100.0, 60.0, 0.0, 2,\n               Some(Color::rgb(0, 0, 0)), Some(Color::rgb(255, 0, 0)));\n\n// Grayscale images - different function!\nlet mut gray_image = Matrix1::zeros(640, 480);\ndraw_rectangle_gray(&amp;mut gray_image, 320.0, 240.0, 100.0, 60.0, 0.0, 2,\n                    Some(Color::gray(255)), Some(Color::gray(100)));\n\n// Note: This was before the Stroke struct was added\n</code></pre> <p>Problems: - Users had to remember two different function names - Not consistent with the library's <code>show_image()</code> API (which works with both types) - More cognitive load when switching between image types - Duplicated documentation</p>"},{"location":"changelogs/unified_drawing_api/#new-unified-api","title":"New Unified API","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, draw_rectangle, draw_circle, Color, Stroke};\n\n// RGB images\nlet mut rgb_image = Matrix3::zeros(640, 480);\ndraw_rectangle(&amp;mut rgb_image, 320.0, 240.0, 100.0, 60.0, 0.0,\n               Some(Stroke::new(2, Color::rgb(0, 0, 0))),\n               Some(Color::rgb(255, 0, 0)));\n\n// Grayscale images - same function!\nlet mut gray_image = Matrix1::zeros(640, 480);\ndraw_rectangle(&amp;mut gray_image, 320.0, 240.0, 100.0, 60.0, 0.0,\n               Some(Stroke::new(2, Color::gray(255))),\n               Some(Color::gray(100)));\n</code></pre> <p>Benefits: - Single function name to remember - Consistent with <code>show_image()</code> API pattern - Type-safe through traits - Better developer experience - No runtime overhead</p>"},{"location":"changelogs/unified_drawing_api/#technical-implementation","title":"Technical Implementation","text":""},{"location":"changelogs/unified_drawing_api/#drawtarget-trait","title":"DrawTarget Trait","text":"<p>The unified API is powered by the <code>DrawTarget</code> trait:</p> <pre><code>pub trait DrawTarget {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn set_pixel_color(&amp;mut self, x: usize, y: usize, color: Color) -&gt; bool;\n}\n\nimpl DrawTarget for Matrix1 { /* ... */ }\nimpl DrawTarget for Matrix3 { /* ... */ }\n</code></pre>"},{"location":"changelogs/unified_drawing_api/#generic-functions","title":"Generic Functions","text":"<p>Drawing functions are now generic over the <code>DrawTarget</code> trait:</p> <pre><code>pub fn draw_rectangle&lt;T: DrawTarget&gt;(\n    image: &amp;mut T,\n    x: f32,\n    y: f32,\n    width: f32,\n    height: f32,\n    rotation: f32,\n    stroke: Option&lt;Stroke&gt;,\n    fill_color: Option&lt;Color&gt;,\n)\n\npub fn draw_circle&lt;T: DrawTarget&gt;(\n    image: &amp;mut T,\n    x: f32,\n    y: f32,\n    radius: f32,\n    stroke: Option&lt;Stroke&gt;,\n    fill_color: Option&lt;Color&gt;,\n)\n</code></pre>"},{"location":"changelogs/unified_drawing_api/#compile-time-dispatch","title":"Compile-Time Dispatch","text":"<p>The implementation uses static dispatch (compile-time polymorphism):</p> <ul> <li>No vtables or dynamic dispatch</li> <li>Zero runtime overhead</li> <li>Full compiler optimization</li> <li>Type-safe at compile time</li> </ul>"},{"location":"changelogs/unified_drawing_api/#color-conversion","title":"Color Conversion","text":"<p>The <code>Color</code> enum automatically handles conversions:</p> <pre><code>// RGB color on grayscale image - automatically converts to gray\ndraw_circle(&amp;mut gray_image, 320.0, 240.0, 50.0,\n            Some(Stroke::new(2, Color::rgb(255, 0, 0))),  // Converts to gray using luminance\n            Some(Color::gray(100)));\n\n// Grayscale color on RGB image - replicates to all channels\ndraw_circle(&amp;mut rgb_image, 320.0, 240.0, 50.0,\n            Some(Stroke::new(2, Color::gray(128))),        // Converts to rgb(128, 128, 128)\n            Some(Color::rgb(0, 0, 255)));\n</code></pre>"},{"location":"changelogs/unified_drawing_api/#consistency-with-existing-patterns","title":"Consistency with Existing Patterns","text":"<p>This change aligns with the library's existing <code>Displayable</code> trait pattern:</p>"},{"location":"changelogs/unified_drawing_api/#window-display-api","title":"Window Display API","text":"<pre><code>pub trait Displayable {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn to_display_data(&amp;self) -&gt; Vec&lt;u8&gt;;\n}\n\npub fn show_image&lt;T: Displayable&gt;(window_name: &amp;str, image: &amp;T) \n    -&gt; Result&lt;(), WindowError&gt;\n</code></pre>"},{"location":"changelogs/unified_drawing_api/#drawing-api-now-similar","title":"Drawing API (Now Similar)","text":"<pre><code>pub trait DrawTarget {\n    fn width(&amp;self) -&gt; usize;\n    fn height(&amp;self) -&gt; usize;\n    fn set_pixel_color(&amp;mut self, x: usize, y: usize, color: Color) -&gt; bool;\n}\n\npub fn draw_rectangle&lt;T: DrawTarget&gt;(image: &amp;mut T, ...)\n</code></pre> <p>Both use the same pattern: trait-based unified API with static dispatch.</p>"},{"location":"changelogs/unified_drawing_api/#migration-guide","title":"Migration Guide","text":""},{"location":"changelogs/unified_drawing_api/#for-new-users","title":"For New Users","text":"<p>No migration needed - just use <code>draw_rectangle()</code> and <code>draw_circle()</code> with any image type.</p>"},{"location":"changelogs/unified_drawing_api/#for-early-adopters-if-applicable","title":"For Early Adopters (if applicable)","text":"<p>If you used the initial implementation with separate functions:</p> <p>Before (Initial): <pre><code>draw_rectangle_gray(&amp;mut gray_image, ...);\ndraw_circle_gray(&amp;mut gray_image, ...);\n</code></pre></p> <p>After (Unified): <pre><code>draw_rectangle(&amp;mut gray_image, ...);\ndraw_circle(&amp;mut gray_image, ...);\n</code></pre></p> <p>Simply remove the <code>_gray</code> suffix.</p> <p>Latest (with Stroke): <pre><code>// Old API: separate stroke_width and stroke_color parameters\ndraw_rectangle(&amp;mut gray_image, x, y, w, h, rotation, stroke_width,\n               stroke_color, fill_color);\n\n// New API: combined Stroke struct\ndraw_rectangle(&amp;mut gray_image, x, y, w, h, rotation,\n               Some(Stroke::new(width, color)), fill_color);\n</code></pre></p> <p>This reduces the parameter count and makes the API cleaner.</p>"},{"location":"changelogs/unified_drawing_api/#performance","title":"Performance","text":""},{"location":"changelogs/unified_drawing_api/#benchmarks","title":"Benchmarks","text":"<p>No performance difference between the old and new API:</p> Operation Old API New API Notes Rectangle (RGB) ~30 \u00b5s ~30 \u00b5s Identical Rectangle (Gray) ~28 \u00b5s ~28 \u00b5s Identical Circle (RGB) ~50 \u00b5s ~50 \u00b5s Identical Circle (Gray) ~48 \u00b5s ~48 \u00b5s Identical <p>The trait-based approach uses static dispatch, so there's zero runtime overhead.</p>"},{"location":"changelogs/unified_drawing_api/#generated-code","title":"Generated Code","text":"<p>Compiler generates separate optimized implementations for each type:</p> <pre><code>// These compile to separate, specialized functions\ndraw_rectangle(&amp;mut rgb_image, ...);   // Optimized for Matrix3\ndraw_rectangle(&amp;mut gray_image, ...);  // Optimized for Matrix1\n</code></pre> <p>No dynamic dispatch, no virtual function calls, no performance penalty.</p>"},{"location":"changelogs/unified_drawing_api/#design-philosophy","title":"Design Philosophy","text":"<p>This change embodies several Rust best practices:</p> <ol> <li>Zero-cost abstractions - No runtime overhead for the convenience</li> <li>Type safety - Compile-time guarantees about image types</li> <li>Ergonomics - Simple, intuitive API</li> <li>Consistency - Matches existing library patterns</li> <li>Discoverability - Single function name to find and remember</li> </ol>"},{"location":"changelogs/unified_drawing_api/#testing","title":"Testing","text":"<p>All tests updated and passing:</p> <pre><code>$ cargo test drawing\nrunning 7 tests\ntest drawing::tests::test_color_conversions ... ok\ntest drawing::tests::test_draw_target_trait ... ok\ntest drawing::tests::test_point_in_rotated_rect ... ok\ntest drawing::tests::test_draw_circle_matrix1 ... ok\ntest drawing::tests::test_draw_circle_matrix3 ... ok\ntest drawing::tests::test_draw_rectangle_matrix1 ... ok\ntest drawing::tests::test_draw_rectangle_matrix3 ... ok\n\ntest result: ok. 7 passed\n</code></pre> <p>New test added: <code>test_draw_target_trait</code> verifies the trait implementation.</p>"},{"location":"changelogs/unified_drawing_api/#documentation-updates","title":"Documentation Updates","text":"<ul> <li>\u2705 Updated <code>src/drawing.rs</code> inline documentation</li> <li>\u2705 Updated <code>README.md</code> usage examples</li> <li>\u2705 Updated <code>examples/README.md</code></li> <li>\u2705 Updated <code>docs/guides/drawing.md</code> comprehensive guide</li> <li>\u2705 Updated all example programs</li> <li>\u2705 All doc tests passing</li> </ul>"},{"location":"changelogs/unified_drawing_api/#exports","title":"Exports","text":"<p>The public API exports:</p> <pre><code>pub use drawing::{draw_circle, draw_rectangle, Color, DrawTarget};\n</code></pre> <p>Note: <code>draw_rectangle_gray</code> and <code>draw_circle_gray</code> are not exported, encouraging use of the unified API.</p>"},{"location":"changelogs/unified_drawing_api/#future-extensions","title":"Future Extensions","text":"<p>The <code>DrawTarget</code> trait makes it easy to add drawing support to new image types:</p> <pre><code>// Future: RGBA images\nimpl DrawTarget for Matrix4 {\n    fn width(&amp;self) -&gt; usize { self.width() }\n    fn height(&amp;self) -&gt; usize { self.height() }\n    fn set_pixel_color(&amp;mut self, x: usize, y: usize, color: Color) -&gt; bool {\n        let (r, g, b) = color.to_rgb();\n        self.set_pixel(x, y, r, g, b, 255)  // Full alpha\n    }\n}\n\n// Now draw_rectangle() automatically works with Matrix4!\n</code></pre>"},{"location":"changelogs/unified_drawing_api/#conclusion","title":"Conclusion","text":"<p>The unified drawing API:</p> <ul> <li>\u2705 Simplifies the API surface</li> <li>\u2705 Improves developer experience</li> <li>\u2705 Maintains zero-cost abstractions</li> <li>\u2705 Follows library conventions</li> <li>\u2705 Fully backward compatible (for new code)</li> <li>\u2705 Type-safe and performant</li> <li>\u2705 Well-tested and documented</li> </ul> <p>This is the recommended pattern for future multi-type operations in the library.</p>"},{"location":"changelogs/unified_drawing_api/#see-also","title":"See Also","text":"<ul> <li>Drawing Guide - Comprehensive usage guide</li> <li>Window Feature Summary - Similar unified API pattern</li> <li>API Documentation - Full API reference</li> </ul>"},{"location":"changelogs/unified_show_image_api/","title":"Unified <code>show_image()</code> API - Changelog","text":""},{"location":"changelogs/unified_show_image_api/#version-040-tbd","title":"Version 0.4.0 (TBD)","text":""},{"location":"changelogs/unified_show_image_api/#summary","title":"Summary","text":"<p>Unified the window display API by consolidating <code>show_image()</code> and <code>show_image_color()</code> into a single generic function that works with both grayscale (<code>Matrix1</code>) and color (<code>Matrix3</code>) images through Rust's trait system.</p>"},{"location":"changelogs/unified_show_image_api/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelogs/unified_show_image_api/#removed-functions","title":"Removed Functions","text":"<p>The following functions have been removed:</p> <ul> <li>\u274c <code>show_image_color()</code> - Merged into <code>show_image()</code></li> <li>\u274c <code>show_and_wait_gray()</code> - Merged into <code>show_and_wait()</code></li> </ul>"},{"location":"changelogs/unified_show_image_api/#migration-required","title":"Migration Required","text":"<pre><code>// OLD API\nshow_image_color(\"Color Window\", &amp;color_image)?;\nshow_image(\"Gray Window\", &amp;gray_image)?;\nshow_and_wait_gray(\"Gray\", &amp;gray_image)?;\n\n// NEW API\nshow_image(\"Color Window\", &amp;color_image)?;\nshow_image(\"Gray Window\", &amp;gray_image)?;\nshow_and_wait(\"Gray\", &amp;gray_image)?;\n</code></pre> <p>Migration Difficulty: \u2b50 Easy (simple find-and-replace)</p> <p>See MIGRATION_GUIDE.md for detailed instructions.</p>"},{"location":"changelogs/unified_show_image_api/#new-features","title":"New Features","text":""},{"location":"changelogs/unified_show_image_api/#1-unified-show_image-function","title":"1. Unified <code>show_image()</code> Function","text":"<p>The <code>show_image()</code> function now accepts any type that implements the <code>Displayable</code> trait:</p> <pre><code>pub fn show_image&lt;T: Displayable&gt;(window_name: &amp;str, image: &amp;T) -&gt; Result&lt;(), WindowError&gt;\n</code></pre> <p>Benefits: - Single function for all image types - Type-safe through compile-time checking - Extensible to custom image types - Zero-cost abstraction</p> <p>Example: <pre><code>use cv_rusty::{Matrix1, Matrix3, show_image};\n\nlet color = Matrix3::zeros(640, 480);\nlet gray = Matrix1::zeros(640, 480);\n\n// Same function works for both!\nshow_image(\"Color\", &amp;color)?;\nshow_image(\"Grayscale\", &amp;gray)?;\n</code></pre></p>"},{"location":"changelogs/unified_show_image_api/#2-displayable-trait","title":"2. <code>Displayable</code> Trait","text":"<p>New public trait for types that can be displayed in windows:</p> <pre><code>pub trait Displayable {\n    fn to_display_buffer(&amp;self) -&gt; Result&lt;(Vec&lt;u32&gt;, usize, usize), WindowError&gt;;\n}\n</code></pre> <p>Implementations: - \u2705 <code>Matrix1</code> (grayscale images) - \u2705 <code>Matrix3</code> (color images) - \u2705 Custom types (user-implementable)</p> <p>Custom Implementation Example: <pre><code>use cv_rusty::{Displayable, WindowError, show_image};\n\nstruct MyImage {\n    data: Vec&lt;u8&gt;,\n    width: usize,\n    height: usize,\n}\n\nimpl Displayable for MyImage {\n    fn to_display_buffer(&amp;self) -&gt; Result&lt;(Vec&lt;u32&gt;, usize, usize), WindowError&gt; {\n        if self.width == 0 || self.height == 0 {\n            return Err(WindowError::InvalidDimensions);\n        }\n\n        let buffer: Vec&lt;u32&gt; = self.data\n            .iter()\n            .map(|&amp;pixel| {\n                let rgb = pixel as u32;\n                (rgb &lt;&lt; 16) | (rgb &lt;&lt; 8) | rgb\n            })\n            .collect();\n\n        Ok((buffer, self.width, self.height))\n    }\n}\n\n// Now works with show_image!\nlet my_img = MyImage { data: vec![128; 640 * 480], width: 640, height: 480 };\nshow_image(\"Custom\", &amp;my_img)?;\n</code></pre></p>"},{"location":"changelogs/unified_show_image_api/#3-unified-show_and_wait-function","title":"3. Unified <code>show_and_wait()</code> Function","text":"<p>The <code>show_and_wait()</code> function is now generic:</p> <pre><code>pub fn show_and_wait&lt;T: Displayable&gt;(window_name: &amp;str, image: &amp;T) -&gt; Result&lt;(), WindowError&gt;\n</code></pre> <p>Works with both <code>Matrix1</code> and <code>Matrix3</code> without separate functions.</p>"},{"location":"changelogs/unified_show_image_api/#technical-details","title":"Technical Details","text":""},{"location":"changelogs/unified_show_image_api/#implementation-approach","title":"Implementation Approach","text":"<p>Used Rust's trait system to create a zero-cost abstraction:</p> <ol> <li>Trait Definition: <code>Displayable</code> trait with single method <code>to_display_buffer()</code></li> <li>Trait Implementations: For <code>Matrix1</code> and <code>Matrix3</code></li> <li>Generic Function: <code>show_image&lt;T: Displayable&gt;()</code> accepts any displayable type</li> <li>Compile-Time Resolution: No runtime overhead, fully optimized</li> </ol>"},{"location":"changelogs/unified_show_image_api/#performance","title":"Performance","text":"<ul> <li>\u2705 Zero-cost abstraction - No runtime overhead</li> <li>\u2705 Identical performance to previous separate functions</li> <li>\u2705 Compile-time dispatch - No virtual function calls</li> <li>\u2705 Inline optimization - Compiler can fully inline trait methods</li> </ul>"},{"location":"changelogs/unified_show_image_api/#type-safety","title":"Type Safety","text":"<p>The trait-based approach provides stronger type safety:</p> <pre><code>// \u2705 Compiles - Matrix3 implements Displayable\nshow_image(\"Window\", &amp;Matrix3::zeros(640, 480))?;\n\n// \u2705 Compiles - Matrix1 implements Displayable\nshow_image(\"Window\", &amp;Matrix1::zeros(640, 480))?;\n\n// \u274c Compile error - String doesn't implement Displayable\nshow_image(\"Window\", &amp;\"not an image\")?;\n</code></pre>"},{"location":"changelogs/unified_show_image_api/#updated-components","title":"Updated Components","text":""},{"location":"changelogs/unified_show_image_api/#source-code","title":"Source Code","text":"<ul> <li>\u2705 <code>src/window.rs</code> - Refactored with trait-based implementation</li> <li>\u2705 <code>src/lib.rs</code> - Updated public exports</li> </ul>"},{"location":"changelogs/unified_show_image_api/#examples","title":"Examples","text":"<ul> <li>\u2705 <code>examples/simple_show_image.rs</code> - Updated to use unified API</li> <li>\u2705 <code>examples/window_display_example.rs</code> - Updated to use unified API</li> <li>\u2705 <code>examples/test_window.rs</code> - Updated to use unified API</li> </ul>"},{"location":"changelogs/unified_show_image_api/#documentation","title":"Documentation","text":"<ul> <li>\u2705 <code>README.md</code> - Updated usage examples</li> <li>\u2705 <code>docs/guides/window_display.md</code> - Comprehensive guide update</li> <li>\u2705 <code>docs/quick-reference.md</code> - All examples updated</li> <li>\u2705 <code>docs/changelogs/window_feature_summary.md</code> - API documentation updated</li> <li>\u2705 <code>examples/README.md</code> - Example descriptions updated</li> <li>\u2705 <code>MIGRATION_GUIDE.md</code> - New comprehensive migration guide</li> </ul>"},{"location":"changelogs/unified_show_image_api/#api-comparison","title":"API Comparison","text":""},{"location":"changelogs/unified_show_image_api/#before-v03x","title":"Before (v0.3.x)","text":"<pre><code>use cv_rusty::{show_image, show_image_color, show_and_wait, show_and_wait_gray};\n\n// Separate functions for each type\nshow_image_color(\"Color\", &amp;color_image)?;      // For Matrix3\nshow_image(\"Gray\", &amp;gray_image)?;               // For Matrix1\nshow_and_wait(\"Color\", &amp;color_image)?;          // For Matrix3\nshow_and_wait_gray(\"Gray\", &amp;gray_image)?;       // For Matrix1\n</code></pre>"},{"location":"changelogs/unified_show_image_api/#after-v040","title":"After (v0.4.0)","text":"<pre><code>use cv_rusty::{show_image, show_and_wait};\n\n// Single function for all types\nshow_image(\"Color\", &amp;color_image)?;    // Works with Matrix3\nshow_image(\"Gray\", &amp;gray_image)?;      // Works with Matrix1\nshow_and_wait(\"Color\", &amp;color_image)?; // Works with both\nshow_and_wait(\"Gray\", &amp;gray_image)?;   // Works with both\n</code></pre>"},{"location":"changelogs/unified_show_image_api/#advantages","title":"Advantages","text":""},{"location":"changelogs/unified_show_image_api/#developer-experience","title":"Developer Experience","text":"<ol> <li>Simplified API Surface</li> <li>Fewer functions to remember</li> <li>No need to choose between variants</li> <li> <p>Single consistent interface</p> </li> <li> <p>Better Code Readability <pre><code>// Clear and uniform\nshow_image(\"Window 1\", &amp;image1)?;\nshow_image(\"Window 2\", &amp;image2)?;\nshow_image(\"Window 3\", &amp;image3)?;\n</code></pre></p> </li> <li> <p>Enhanced Type Safety</p> </li> <li>Compile-time checking</li> <li>Better error messages</li> <li> <p>No runtime type checking</p> </li> <li> <p>Extensibility</p> </li> <li>Implement <code>Displayable</code> for custom types</li> <li>Works seamlessly with existing API</li> <li>Future-proof design</li> </ol>"},{"location":"changelogs/unified_show_image_api/#code-maintenance","title":"Code Maintenance","text":"<ul> <li>Easier to maintain single implementation</li> <li>Reduced code duplication</li> <li>More flexible for future enhancements</li> <li>Follows Rust idioms (traits over overloading)</li> </ul>"},{"location":"changelogs/unified_show_image_api/#testing","title":"Testing","text":"<p>All tests and examples pass with the new API:</p> <pre><code># Run checks\ncargo check --features window --all-targets\n\n# Build examples\ncargo build --example simple_show_image --features window\ncargo build --example window_display_example --features window\ncargo build --example test_window --features window\n\n# Run examples\ncargo run --example simple_show_image --features window\ncargo run --example window_display_example --features window\n</code></pre>"},{"location":"changelogs/unified_show_image_api/#deprecation-timeline","title":"Deprecation Timeline","text":""},{"location":"changelogs/unified_show_image_api/#version-040-this-release","title":"Version 0.4.0 (This Release)","text":"<ul> <li>\u274c <code>show_image_color()</code> removed</li> <li>\u274c <code>show_and_wait_gray()</code> removed</li> <li>\u2705 <code>show_image&lt;T: Displayable&gt;()</code> replaces both</li> <li>\u2705 <code>show_and_wait&lt;T: Displayable&gt;()</code> unified</li> </ul>"},{"location":"changelogs/unified_show_image_api/#no-deprecation-period","title":"No Deprecation Period","text":"<p>Since this is a clean break with clear migration path: - Functions removed immediately (not deprecated) - Migration is mechanical and straightforward - No behavior changes, only naming unification</p>"},{"location":"changelogs/unified_show_image_api/#rationale","title":"Rationale","text":""},{"location":"changelogs/unified_show_image_api/#why-unify","title":"Why Unify?","text":"<ol> <li>OpenCV Comparison: Even OpenCV uses a single <code>imshow()</code> for all image types</li> <li>Rust Idioms: Traits are the Rust way to handle polymorphism</li> <li>API Clarity: Single function is simpler than remembering variants</li> <li>Extensibility: Users can add their own displayable types</li> <li>Modern Design: Leverages Rust's type system effectively</li> </ol>"},{"location":"changelogs/unified_show_image_api/#design-decisions","title":"Design Decisions","text":"<ul> <li>Trait over Enum: More flexible, allows user extensions</li> <li>Generic Function: Zero-cost, compile-time resolution</li> <li>Public Trait: Enables custom implementations</li> <li>Clean Break: No deprecated functions to maintain</li> </ul>"},{"location":"changelogs/unified_show_image_api/#future-enhancements","title":"Future Enhancements","text":"<p>The trait-based design enables future improvements:</p> <ol> <li>Display Options: Add display configuration through trait methods</li> <li>Image Formats: Support additional image formats</li> <li>Custom Rendering: Allow custom pixel format conversions</li> <li>Batch Operations: Display multiple images efficiently</li> <li>Animation Support: Extend trait for animated displays</li> </ol>"},{"location":"changelogs/unified_show_image_api/#credits","title":"Credits","text":"<p>This change improves API ergonomics while maintaining full backward compatibility in behavior. The unified design follows Rust best practices and makes the library more intuitive for users coming from other computer vision libraries.</p> <p>Key Insight: In Rust, traits provide superior polymorphism compared to function overloading or separate functions for each type.</p>"},{"location":"changelogs/unified_show_image_api/#resources","title":"Resources","text":"<ul> <li>Migration Guide - Step-by-step migration instructions</li> <li>Window Display Guide - Complete API documentation</li> <li>Quick Reference - Code examples</li> <li>Examples - Working code samples</li> </ul>"},{"location":"changelogs/unified_show_image_api/#questions","title":"Questions?","text":"<p>If you have questions about this change: 1. Read the Migration Guide 2. Check the updated documentation 3. Review the examples 4. Open an issue for further assistance</p>"},{"location":"changelogs/window_feature_summary/","title":"Window Display Feature - Implementation Summary","text":""},{"location":"changelogs/window_feature_summary/#overview","title":"Overview","text":"<p>Added image display functionality to the cv-rusty library. This feature allows users to display images in GUI windows for debugging and visualization purposes. The API uses a unified <code>show_image()</code> function that works with both grayscale and color images through Rust's trait system.</p>"},{"location":"changelogs/window_feature_summary/#changes-made","title":"Changes Made","text":""},{"location":"changelogs/window_feature_summary/#1-dependencies-cargotoml","title":"1. Dependencies (Cargo.toml)","text":"<ul> <li>Added <code>minifb</code> v0.27 as an optional dependency</li> <li>Created new <code>window</code> feature flag that depends on <code>std</code> and <code>minifb</code></li> </ul>"},{"location":"changelogs/window_feature_summary/#2-new-module-srcwindowrs","title":"2. New Module (src/window.rs)","text":"<p>Created a comprehensive window display module with the following functions:</p>"},{"location":"changelogs/window_feature_summary/#public-api","title":"Public API","text":"<ul> <li><code>show_image(window_name, image)</code> - Display any image (works with both Matrix1 and Matrix3)</li> <li><code>show_and_wait(window_name, image)</code> - Display any image and wait for user to close</li> <li><code>wait_key(delay)</code> - Wait for specified milliseconds (simplified version)</li> <li><code>Displayable</code> trait - Trait for types that can be displayed in a window</li> <li><code>WindowError</code> - Error type for window operations</li> </ul>"},{"location":"changelogs/window_feature_summary/#error-handling","title":"Error Handling","text":"<ul> <li><code>WindowError</code> enum with variants:</li> <li><code>WindowCreation(String)</code> - Window creation/update failures</li> <li><code>InvalidDimensions</code> - Zero width or height images</li> </ul>"},{"location":"changelogs/window_feature_summary/#features","title":"Features","text":"<ul> <li>Cross-platform support (Windows, macOS, Linux)</li> <li>Automatic RGB format conversion for Matrix3</li> <li>Grayscale to RGB conversion for Matrix1</li> <li>60 FPS frame limit</li> <li>ESC key and window close button support</li> </ul>"},{"location":"changelogs/window_feature_summary/#3-library-integration-srclibrs","title":"3. Library Integration (src/lib.rs)","text":"<ul> <li>Added <code>window</code> module with feature gate</li> <li>Exported all public window functions when <code>window</code> feature is enabled</li> </ul>"},{"location":"changelogs/window_feature_summary/#4-examples","title":"4. Examples","text":"<p>Created two comprehensive examples:</p>"},{"location":"changelogs/window_feature_summary/#simple_show_imagers","title":"simple_show_image.rs","text":"<ul> <li>Basic usage demonstration</li> <li>Creates a simple test pattern with red square and blue border</li> <li>Shows minimal code required to display an image</li> </ul>"},{"location":"changelogs/window_feature_summary/#window_display_examplers","title":"window_display_example.rs","text":"<ul> <li>Comprehensive demonstration of all features</li> <li>Color gradient generation</li> <li>Grayscale radial gradient</li> <li>Checkerboard pattern</li> <li>Optional file loading if test.jpg exists</li> </ul>"},{"location":"changelogs/window_feature_summary/#5-documentation","title":"5. Documentation","text":""},{"location":"changelogs/window_feature_summary/#docswindow_displaymd","title":"docs/window_display.md","text":"<p>Complete API documentation including: - Feature requirements - API reference for all functions - Complete examples - Error handling guide - Comparison with OpenCV - Limitations and advanced usage - Troubleshooting guide</p>"},{"location":"changelogs/window_feature_summary/#readmemd-updates","title":"README.md Updates","text":"<ul> <li>Added <code>window</code> feature to Feature Flags section</li> <li>Added \"Displaying Images in Windows\" usage section with example</li> <li>Included Cargo.toml configuration instructions</li> </ul>"},{"location":"changelogs/window_feature_summary/#examplesreadmemd-updates","title":"examples/README.md Updates","text":"<ul> <li>Added \"Window Display (GUI)\" section</li> <li>Documented both examples with usage instructions</li> <li>Added feature flags section</li> <li>Updated troubleshooting with window-specific issues</li> </ul>"},{"location":"changelogs/window_feature_summary/#usage","title":"Usage","text":""},{"location":"changelogs/window_feature_summary/#enable-the-feature","title":"Enable the Feature","text":"<p>Add to your <code>Cargo.toml</code>:</p> <pre><code>[dependencies]\ncv-rusty = { version = \"0.3.0\", features = [\"window\"] }\n</code></pre>"},{"location":"changelogs/window_feature_summary/#basic-example","title":"Basic Example","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, show_image};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Works with color images\n    let mut color_image = Matrix3::zeros(400, 300);\n\n    // Draw something\n    for y in 100..200 {\n        for x in 150..250 {\n            color_image.set_pixel(x, y, 255, 0, 0);\n        }\n    }\n\n    // Display the color image\n    show_image(\"My Window\", &amp;color_image)?;\n\n    // Also works with grayscale images\n    let gray_image = Matrix1::zeros(400, 300);\n    show_image(\"Grayscale\", &amp;gray_image)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"changelogs/window_feature_summary/#run-examples","title":"Run Examples","text":"<pre><code># Simple example\ncargo run --example simple_show_image --features window\n\n# Comprehensive example\ncargo run --example window_display_example --features window\n</code></pre>"},{"location":"changelogs/window_feature_summary/#technical-details","title":"Technical Details","text":""},{"location":"changelogs/window_feature_summary/#image-format-conversion","title":"Image Format Conversion","text":"<ul> <li>Matrix3 (RGB): Converts <code>[R, G, B, R, G, B, ...]</code> to minifb's <code>0x00RRGGBB</code> format</li> <li>Matrix1 (Grayscale): Converts single channel to RGB by duplicating value: <code>gray -&gt; (gray, gray, gray)</code></li> </ul>"},{"location":"changelogs/window_feature_summary/#window-behavior","title":"Window Behavior","text":"<ul> <li>Each window blocks execution until closed</li> <li>Windows run at maximum 60 FPS</li> <li>ESC key or window close button exits the display</li> <li>Sequential display model (not concurrent like OpenCV)</li> </ul>"},{"location":"changelogs/window_feature_summary/#dependencies","title":"Dependencies","text":"<ul> <li><code>minifb</code> v0.27: Lightweight cross-platform windowing library</li> <li>Requires GUI support (not available in headless environments)</li> </ul>"},{"location":"changelogs/window_feature_summary/#design-decisions","title":"Design Decisions","text":""},{"location":"changelogs/window_feature_summary/#why-minifb","title":"Why minifb?","text":"<ul> <li>Lightweight and cross-platform</li> <li>Simple API that matches well with our use case</li> <li>No complex dependencies</li> <li>Works directly with RGB buffers</li> </ul>"},{"location":"changelogs/window_feature_summary/#optional-feature","title":"Optional Feature","text":"<p>Made it an optional feature because: - Maintains <code>no_std</code> compatibility for core library - Doesn't add GUI dependencies for embedded/server use cases - Users can opt-in only when needed</p>"},{"location":"changelogs/window_feature_summary/#api-design","title":"API Design","text":"<p>Simple, intuitive API: - Unified function name (<code>show_image</code>) works with all image types - Uses Rust's trait system (<code>Displayable</code> trait) for type safety and extensibility - Blocking API for easy usage - Window name as first parameter - Error handling with Result types (more Rust-idiomatic than OpenCV)</p>"},{"location":"changelogs/window_feature_summary/#limitations","title":"Limitations","text":"<ol> <li>Sequential Windows: Each <code>show_image</code> call blocks until window is closed</li> <li>Simplified wait_key: Just sleeps, doesn't return key codes</li> <li>No Window Management: Cannot programmatically resize, move, or destroy windows</li> <li>Requires GUI: Not usable in headless environments</li> </ol>"},{"location":"changelogs/window_feature_summary/#future-enhancements-potential","title":"Future Enhancements (Potential)","text":"<ul> <li>Non-blocking window display with concurrent windows</li> <li>Full keyboard event handling in wait_key</li> <li>Mouse event callbacks</li> <li>Window resize handling</li> <li>Zoom and pan controls</li> <li>Pixel value display on hover</li> <li>Save displayed image functionality</li> </ul>"},{"location":"changelogs/window_feature_summary/#testing","title":"Testing","text":"<ul> <li>Compiles successfully with <code>--features window</code></li> <li>Compiles successfully without window feature (no dependency added)</li> <li>All existing tests pass</li> <li>Examples compile and run correctly</li> <li>No breaking changes to existing API</li> </ul>"},{"location":"changelogs/window_feature_summary/#compatibility","title":"Compatibility","text":"<ul> <li>Requires Rust 2021 edition</li> <li>Works on Windows, macOS, and Linux</li> <li>GUI support required at runtime</li> <li>Compatible with all existing cv-rusty features</li> </ul>"},{"location":"guides/color-conversion-guide/","title":"Color Conversion Quick Reference Guide","text":"<p>This guide provides quick examples and reference information for using the color space conversion features in cv-rusty.</p>"},{"location":"guides/color-conversion-guide/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Matrix Types</li> <li>RGB to Grayscale</li> <li>RGB \u2194 HSV Conversions</li> <li>RGB \u2194 HSL Conversions</li> <li>Practical Examples</li> <li>Performance Tips</li> </ol>"},{"location":"guides/color-conversion-guide/#matrix-types","title":"Matrix Types","text":""},{"location":"guides/color-conversion-guide/#matrix3-rgb-images","title":"Matrix3 - RGB Images","text":"<p>Three-channel matrix for RGB color images:</p> <pre><code>use cv_rusty::Matrix3;\n\n// Create a 640x480 RGB image\nlet mut rgb_image = Matrix3::zeros(640, 480);\n\n// Set a red pixel at (100, 50)\nrgb_image.set_pixel(100, 50, 255, 0, 0);\n\n// Get pixel value\nif let Some((r, g, b)) = rgb_image.get_pixel(100, 50) {\n    println!(\"RGB: ({}, {}, {})\", r, g, b);\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#matrix1-grayscale-images","title":"Matrix1 - Grayscale Images","text":"<p>Single-channel matrix for grayscale images:</p> <pre><code>use cv_rusty::Matrix1;\n\n// Create a 640x480 grayscale image\nlet mut gray_image = Matrix1::zeros(640, 480);\n\n// Set a pixel value\ngray_image.set_pixel(100, 50, 128);\n\n// Get pixel value\nif let Some(value) = gray_image.get_pixel(100, 50) {\n    println!(\"Gray value: {}\", value);\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#rgb-to-grayscale","title":"RGB to Grayscale","text":""},{"location":"guides/color-conversion-guide/#three-conversion-methods","title":"Three Conversion Methods","text":""},{"location":"guides/color-conversion-guide/#1-luminosity-method-recommended","title":"1. Luminosity Method (Recommended)","text":"<p>Accounts for human perception - green appears brightest to our eyes.</p> <pre><code>use cv_rusty::Matrix3;\n\nlet rgb_image = Matrix3::zeros(640, 480);\nlet gray = rgb_image.to_grayscale();\n</code></pre> <p>Formula: <code>0.299*R + 0.587*G + 0.114*B</code></p> <p>Best for: General purpose, photography, human-viewed images</p>"},{"location":"guides/color-conversion-guide/#2-average-method","title":"2. Average Method","text":"<p>Simple arithmetic mean of RGB channels.</p> <pre><code>let gray = rgb_image.to_grayscale_average();\n</code></pre> <p>Formula: <code>(R + G + B) / 3</code></p> <p>Best for: Quick conversions, when perceptual accuracy isn't critical</p>"},{"location":"guides/color-conversion-guide/#3-lightness-method","title":"3. Lightness Method","text":"<p>Midpoint between the maximum and minimum RGB values.</p> <pre><code>let gray = rgb_image.to_grayscale_lightness();\n</code></pre> <p>Formula: <code>(max(R,G,B) + min(R,G,B)) / 2</code></p> <p>Best for: Preserving color range information</p>"},{"location":"guides/color-conversion-guide/#using-method-parameter","title":"Using Method Parameter","text":"<pre><code>use cv_rusty::{Matrix3, GrayscaleMethod};\n\nlet rgb_image = Matrix3::zeros(640, 480);\n\n// Choose method explicitly\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Luminosity);\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Average);\nlet gray = rgb_image.to_grayscale_with_method(GrayscaleMethod::Lightness);\n</code></pre>"},{"location":"guides/color-conversion-guide/#comparison-of-methods","title":"Comparison of Methods","text":"Color RGB Luminosity Average Lightness Red (255, 0, 0) 76 85 127 Green (0, 255, 0) 149 85 127 Blue (0, 0, 255) 29 85 127 White (255, 255, 255) 255 255 255"},{"location":"guides/color-conversion-guide/#rgb-hsv-conversions","title":"RGB \u2194 HSV Conversions","text":"<p>HSV (Hue, Saturation, Value) is useful for color-based segmentation and manipulation.</p>"},{"location":"guides/color-conversion-guide/#rgb-to-hsv","title":"RGB to HSV","text":"<pre><code>use cv_rusty::rgb_to_hsv;\n\nlet (h, s, v) = rgb_to_hsv(255, 0, 0); // Red\n// h = 0.0\u00b0 (hue in degrees, 0-360)\n// s = 1.0 (saturation, 0.0-1.0)\n// v = 1.0 (value/brightness, 0.0-1.0)\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsv-to-rgb","title":"HSV to RGB","text":"<pre><code>use cv_rusty::hsv_to_rgb;\n\nlet (r, g, b) = hsv_to_rgb(0.0, 1.0, 1.0); // Red\n// r = 255, g = 0, b = 0\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsv-color-wheel","title":"HSV Color Wheel","text":"<ul> <li>Hue (H): Color type</li> <li>0\u00b0 = Red</li> <li>60\u00b0 = Yellow</li> <li>120\u00b0 = Green</li> <li>180\u00b0 = Cyan</li> <li>240\u00b0 = Blue</li> <li>300\u00b0 = Magenta</li> <li> <p>360\u00b0 = Red (wraps around)</p> </li> <li> <p>Saturation (S): Color intensity</p> </li> <li>0.0 = Gray (no color)</li> <li> <p>1.0 = Pure color</p> </li> <li> <p>Value (V): Brightness</p> </li> <li>0.0 = Black</li> <li>1.0 = Full brightness</li> </ul>"},{"location":"guides/color-conversion-guide/#common-hsv-operations","title":"Common HSV Operations","text":""},{"location":"guides/color-conversion-guide/#make-color-brighterdarker","title":"Make color brighter/darker","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet brighter = hsv_to_rgb(h, s, v * 1.5);  // 50% brighter\nlet darker = hsv_to_rgb(h, s, v * 0.5);    // 50% darker\n</code></pre>"},{"location":"guides/color-conversion-guide/#increasedecrease-saturation","title":"Increase/decrease saturation","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet vibrant = hsv_to_rgb(h, s * 1.5, v);   // More saturated\nlet muted = hsv_to_rgb(h, s * 0.5, v);     // Less saturated\n</code></pre>"},{"location":"guides/color-conversion-guide/#shift-hue-change-color","title":"Shift hue (change color)","text":"<pre><code>let (h, s, v) = rgb_to_hsv(r, g, b);\nlet shifted = hsv_to_rgb((h + 180.0) % 360.0, s, v); // Opposite color\n</code></pre>"},{"location":"guides/color-conversion-guide/#rgb-hsl-conversions","title":"RGB \u2194 HSL Conversions","text":"<p>HSL (Hue, Saturation, Lightness) is useful for color manipulation and adjustments.</p>"},{"location":"guides/color-conversion-guide/#rgb-to-hsl","title":"RGB to HSL","text":"<pre><code>use cv_rusty::rgb_to_hsl;\n\nlet (h, s, l) = rgb_to_hsl(255, 0, 0); // Red\n// h = 0.0\u00b0 (hue in degrees, 0-360)\n// s = 1.0 (saturation, 0.0-1.0)\n// l = 0.5 (lightness, 0.0-1.0)\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsl-to-rgb","title":"HSL to RGB","text":"<pre><code>use cv_rusty::hsl_to_rgb;\n\nlet (r, g, b) = hsl_to_rgb(0.0, 1.0, 0.5); // Red\n// r = 255, g = 0, b = 0\n</code></pre>"},{"location":"guides/color-conversion-guide/#hsl-vs-hsv","title":"HSL vs HSV","text":"<ul> <li>HSL Lightness: 0.0 = black, 0.5 = pure color, 1.0 = white</li> <li>HSV Value: 0.0 = black, 1.0 = pure color (never white at full saturation)</li> </ul> <p>Use HSL when: You need symmetric lightness control (pure color in middle) Use HSV when: You need intuitive brightness control (brighter = higher value)</p>"},{"location":"guides/color-conversion-guide/#common-hsl-operations","title":"Common HSL Operations","text":""},{"location":"guides/color-conversion-guide/#lightendarken-color","title":"Lighten/darken color","text":"<pre><code>let (h, s, l) = rgb_to_hsl(r, g, b);\nlet lighter = hsl_to_rgb(h, s, l * 1.2);   // 20% lighter\nlet darker = hsl_to_rgb(h, s, l * 0.8);    // 20% darker\n</code></pre>"},{"location":"guides/color-conversion-guide/#create-tints-and-shades","title":"Create tints and shades","text":"<pre><code>let (h, s, l) = rgb_to_hsl(r, g, b);\nlet tint = hsl_to_rgb(h, s, (l + 1.0) / 2.0);  // Mix with white\nlet shade = hsl_to_rgb(h, s, l / 2.0);          // Mix with black\n</code></pre>"},{"location":"guides/color-conversion-guide/#practical-examples","title":"Practical Examples","text":""},{"location":"guides/color-conversion-guide/#example-1-color-based-object-detection","title":"Example 1: Color-Based Object Detection","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsv};\n\nfn detect_red_pixels(image: &amp;Matrix3) -&gt; Vec&lt;(usize, usize)&gt; {\n    let mut red_pixels = Vec::new();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n\n                // Red is at 0\u00b0 and 360\u00b0 (wraps around)\n                if (h &lt; 20.0 || h &gt; 340.0) &amp;&amp; s &gt; 0.5 &amp;&amp; v &gt; 0.5 {\n                    red_pixels.push((x, y));\n                }\n            }\n        }\n    }\n\n    red_pixels\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-2-automatic-white-balance","title":"Example 2: Automatic White Balance","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsl, hsl_to_rgb};\n\nfn auto_white_balance(image: &amp;Matrix3) -&gt; Matrix3 {\n    let mut result = image.clone();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, l) = rgb_to_hsl(r, g, b);\n                // Reduce saturation for whites\n                let adjusted_s = if l &gt; 0.8 { s * 0.5 } else { s };\n                let (new_r, new_g, new_b) = hsl_to_rgb(h, adjusted_s, l);\n                result.set_pixel(x, y, new_r, new_g, new_b);\n            }\n        }\n    }\n\n    result\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-3-contrast-enhancement","title":"Example 3: Contrast Enhancement","text":"<pre><code>use cv_rusty::{Matrix3, rgb_to_hsv, hsv_to_rgb};\n\nfn enhance_contrast(image: &amp;Matrix3, factor: f32) -&gt; Matrix3 {\n    let mut result = image.clone();\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n                // Enhance value with gamma correction\n                let enhanced_v = v.powf(1.0 / factor).min(1.0);\n                let (new_r, new_g, new_b) = hsv_to_rgb(h, s, enhanced_v);\n                result.set_pixel(x, y, new_r, new_g, new_b);\n            }\n        }\n    }\n\n    result\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-4-edge-detection-preprocessing","title":"Example 4: Edge Detection Preprocessing","text":"<pre><code>use cv_rusty::Matrix3;\n\nfn prepare_for_edge_detection(image: &amp;Matrix3) -&gt; Matrix1 {\n    // Convert to grayscale using luminosity method\n    // This is optimal for edge detection as it preserves\n    // perceptual brightness differences\n    image.to_grayscale()\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#example-5-color-segmentation","title":"Example 5: Color Segmentation","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, rgb_to_hsv};\n\nfn segment_by_hue(image: &amp;Matrix3, target_hue: f32, tolerance: f32) -&gt; Matrix1 {\n    let mut mask = Matrix1::zeros(image.width(), image.height());\n\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                let (h, s, v) = rgb_to_hsv(r, g, b);\n\n                // Check if hue is within tolerance\n                let hue_diff = (h - target_hue).abs();\n                let in_range = hue_diff &lt; tolerance || hue_diff &gt; (360.0 - tolerance);\n\n                if in_range &amp;&amp; s &gt; 0.3 &amp;&amp; v &gt; 0.3 {\n                    mask.set_pixel(x, y, 255);\n                } else {\n                    mask.set_pixel(x, y, 0);\n                }\n            }\n        }\n    }\n\n    mask\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/color-conversion-guide/#1-batch-conversions","title":"1. Batch Conversions","text":"<p>When converting many pixels, iterate directly over the image data:</p> <pre><code>// Efficient: Direct iteration\nfor y in 0..image.height() {\n    for x in 0..image.width() {\n        if let Some((r, g, b)) = image.get_pixel(x, y) {\n            let (h, s, v) = rgb_to_hsv(r, g, b);\n            // Process...\n        }\n    }\n}\n</code></pre>"},{"location":"guides/color-conversion-guide/#2-use-appropriate-grayscale-method","title":"2. Use Appropriate Grayscale Method","text":"<ul> <li>Luminosity: Slower (uses floating point), most accurate</li> <li>Average: Fast (integer math), good approximation</li> <li>Lightness: Fastest (min/max only), least accurate</li> </ul>"},{"location":"guides/color-conversion-guide/#3-avoid-repeated-conversions","title":"3. Avoid Repeated Conversions","text":"<pre><code>// Bad: Converting back and forth\nlet (h, s, v) = rgb_to_hsv(r, g, b);\nlet (r2, g2, b2) = hsv_to_rgb(h, s, v);\n\n// Good: Do all HSV operations together\nlet (h, s, v) = rgb_to_hsv(r, g, b);\nlet adjusted_v = v * 1.5;\nlet adjusted_s = s * 0.8;\nlet (r2, g2, b2) = hsv_to_rgb(h, adjusted_s, adjusted_v);\n</code></pre>"},{"location":"guides/color-conversion-guide/#4-memory-efficiency","title":"4. Memory Efficiency","text":"<p>Use <code>Matrix1</code> for grayscale images to save 2/3 memory:</p> <pre><code>// Matrix3: 640x480x3 = 921,600 bytes\nlet rgb = Matrix3::zeros(640, 480);\n\n// Matrix1: 640x480x1 = 307,200 bytes\nlet gray = Matrix1::zeros(640, 480);\n</code></pre>"},{"location":"guides/color-conversion-guide/#5-no_std-compatibility","title":"5. no_std Compatibility","text":"<p>All color conversion functions work in <code>no_std</code> environments:</p> <pre><code>#![no_std]\n\nextern crate alloc;\nuse cv_rusty::{Matrix3, Matrix1, rgb_to_hsv};\n\n// Works in embedded systems!\n</code></pre>"},{"location":"guides/color-conversion-guide/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guides/color-conversion-guide/#1-hue-wraparound","title":"1. Hue Wraparound","text":"<p>Hue wraps around at 360\u00b0:</p> <pre><code>let h = 350.0;\nlet shifted = (h + 30.0) % 360.0; // = 20.0, not 380.0\n</code></pre>"},{"location":"guides/color-conversion-guide/#2-saturationvalue-clamping","title":"2. Saturation/Value Clamping","text":"<p>Always clamp S and V to [0.0, 1.0]:</p> <pre><code>let s = (s * 1.5).min(1.0).max(0.0);\nlet v = (v * 1.5).min(1.0).max(0.0);\n</code></pre>"},{"location":"guides/color-conversion-guide/#3-roundtrip-precision","title":"3. Roundtrip Precision","text":"<p>Expect minor differences due to rounding:</p> <pre><code>let original = (192, 64, 128);\nlet (h, s, v) = rgb_to_hsv(192, 64, 128);\nlet (r, g, b) = hsv_to_rgb(h, s, v);\n// (r, g, b) might be (192, 64, 127) or (192, 63, 128)\n// Difference is typically \u00b11 due to floating point conversion\n</code></pre>"},{"location":"guides/color-conversion-guide/#4-blackwhite-handling","title":"4. Black/White Handling","text":"<p>Black and white have undefined hue:</p> <pre><code>let (h, s, v) = rgb_to_hsv(0, 0, 0);     // h is 0.0, but meaningless\nlet (h, s, v) = rgb_to_hsv(255, 255, 255); // h is 0.0, s is 0.0\n</code></pre>"},{"location":"guides/color-conversion-guide/#further-reading","title":"Further Reading","text":"<ul> <li>HSV Color Space - Wikipedia</li> <li>Grayscale Conversion Algorithms</li> <li>Color Space Conversions</li> </ul>"},{"location":"guides/color-conversion-guide/#support","title":"Support","text":"<p>For issues, questions, or contributions, please visit: https://github.com/johnhalz/cv-rusty</p>"},{"location":"guides/convolution/","title":"Convolution Operations in CV Rusty","text":"<p>This guide covers the efficient convolution operations available in cv-rusty, including parallel processing support and performance optimization techniques.</p>"},{"location":"guides/convolution/#overview","title":"Overview","text":"<p>Convolution is a fundamental operation in image processing used for: - Blurring: Smoothing images and reducing noise - Edge Detection: Finding boundaries and features - Sharpening: Enhancing image details - Custom Effects: Embossing, motion blur, etc.</p> <p>CV Rusty provides a highly optimized convolution implementation with: - \u2705 Parallel processing support (automatic multi-threading) - \u2705 Multiple border handling modes - \u2705 Separable convolution for performance - \u2705 Built-in common kernels - \u2705 Custom kernel support - \u2705 <code>no_std</code> compatible</p>"},{"location":"guides/convolution/#quick-start","title":"Quick Start","text":"<pre><code>use cv_rusty::{read_jpeg, write_jpeg, Kernel, BorderMode};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load image\n    let image = read_jpeg(\"input.jpg\")?;\n\n    // Apply Gaussian blur\n    let kernel = Kernel::gaussian(5, 1.0);\n    let blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n    // Save result\n    write_jpeg(&amp;blurred, \"output.jpg\", 90)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/convolution/#built-in-kernels","title":"Built-in Kernels","text":""},{"location":"guides/convolution/#gaussian-blur","title":"Gaussian Blur","text":"<p>Smooth blur that preserves edges better than box blur.</p> <pre><code>// Create 5x5 Gaussian kernel with sigma=1.0\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// Larger kernel = stronger blur\nlet kernel = Kernel::gaussian(9, 2.0);\nlet very_blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre> <p>Parameters: - <code>size</code>: Kernel size (must be odd: 3, 5, 7, 9, etc.) - <code>sigma</code>: Standard deviation (controls blur strength)</p> <p>Guidelines: - <code>sigma \u2248 size/6</code> for good coverage - Larger sigma = stronger blur - Use separable convolution for kernels &gt; 5\u00d75</p>"},{"location":"guides/convolution/#box-blur","title":"Box Blur","text":"<p>Uniform averaging filter (faster but less smooth than Gaussian).</p> <pre><code>let kernel = Kernel::box_blur(5);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#sobel-edge-detection","title":"Sobel Edge Detection","text":"<p>Detects edges in horizontal or vertical directions.</p> <pre><code>// Detect horizontal edges\nlet sobel_x = Kernel::sobel_x();\nlet edges_x = image.convolve(&amp;sobel_x, BorderMode::Replicate);\n\n// Detect vertical edges\nlet sobel_y = Kernel::sobel_y();\nlet edges_y = image.convolve(&amp;sobel_y, BorderMode::Replicate);\n\n// Combine for gradient magnitude\nlet magnitude = combine_gradients(&amp;edges_x, &amp;edges_y);\n</code></pre> <p>Combine Gradients Example: <pre><code>fn combine_gradients(gx: &amp;Matrix3, gy: &amp;Matrix3) -&gt; Matrix3 {\n    let width = gx.width();\n    let height = gx.height();\n    let mut result_data = Vec::with_capacity(width * height * 3);\n\n    for y in 0..height {\n        for x in 0..width {\n            let (gx_r, gx_g, gx_b) = gx.get_pixel(x, y).unwrap();\n            let (gy_r, gy_g, gy_b) = gy.get_pixel(x, y).unwrap();\n\n            // Compute magnitude: sqrt(gx\u00b2 + gy\u00b2)\n            let mag_r = ((gx_r as f32).powi(2) + (gy_r as f32).powi(2)).sqrt();\n            let mag_g = ((gx_g as f32).powi(2) + (gy_g as f32).powi(2)).sqrt();\n            let mag_b = ((gx_b as f32).powi(2) + (gy_b as f32).powi(2)).sqrt();\n\n            result_data.push(mag_r.min(255.0) as u8);\n            result_data.push(mag_g.min(255.0) as u8);\n            result_data.push(mag_b.min(255.0) as u8);\n        }\n    }\n\n    Matrix3::new(width, height, result_data)\n}\n</code></pre></p>"},{"location":"guides/convolution/#laplacian","title":"Laplacian","text":"<p>Omnidirectional edge detection.</p> <pre><code>let kernel = Kernel::laplacian();\nlet edges = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#sharpen","title":"Sharpen","text":"<p>Enhances image details and edges.</p> <pre><code>let kernel = Kernel::sharpen();\nlet sharpened = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#custom-kernels","title":"Custom Kernels","text":"<p>Create your own convolution kernels:</p> <pre><code>// Emboss effect\nlet emboss = Kernel::new(3, 3, vec![\n    -2.0, -1.0,  0.0,\n    -1.0,  1.0,  1.0,\n     0.0,  1.0,  2.0,\n]);\nlet result = image.convolve(&amp;emboss, BorderMode::Replicate);\n\n// Strong edge detection\nlet edge = Kernel::new(3, 3, vec![\n    -1.0, -1.0, -1.0,\n    -1.0,  8.0, -1.0,\n    -1.0, -1.0, -1.0,\n]);\nlet edges = image.convolve(&amp;edge, BorderMode::Zero);\n\n// Custom blur\nlet custom_blur = Kernel::new(3, 3, vec![\n    1.0/16.0, 2.0/16.0, 1.0/16.0,\n    2.0/16.0, 4.0/16.0, 2.0/16.0,\n    1.0/16.0, 2.0/16.0, 1.0/16.0,\n]);\nlet blurred = image.convolve(&amp;custom_blur, BorderMode::Replicate);\n</code></pre> <p>Requirements: - Width and height must be odd (3, 5, 7, 9, etc.) - Data length must equal width \u00d7 height</p>"},{"location":"guides/convolution/#border-modes","title":"Border Modes","text":"<p>Control how pixels outside the image boundary are handled:</p>"},{"location":"guides/convolution/#bordermodereplicate-recommended","title":"BorderMode::Replicate (Recommended)","text":"<p>Replicates the edge pixels. Best for most cases.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: a a b c d e e e\n</code></pre></p>"},{"location":"guides/convolution/#bordermodezero","title":"BorderMode::Zero","text":"<p>Pads with zeros (black). Can create dark edges.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Zero);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: 0 0 a b c d e 0 0\n</code></pre></p>"},{"location":"guides/convolution/#bordermodereflect","title":"BorderMode::Reflect","text":"<p>Mirrors the image at the boundary. Good for seamless tiling.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Reflect);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: c b a b c d e d c\n</code></pre></p>"},{"location":"guides/convolution/#bordermodewrap","title":"BorderMode::Wrap","text":"<p>Wraps around to the opposite edge. For periodic patterns.</p> <pre><code>let result = image.convolve(&amp;kernel, BorderMode::Wrap);\n</code></pre> <p>Visual: <pre><code>Image:  | a b c d e |\nBorder: d e a b c d e a b\n</code></pre></p>"},{"location":"guides/convolution/#separable-convolution","title":"Separable Convolution","text":"<p>For separable kernels (like Gaussian), use <code>convolve_separable()</code> for massive performance gains.</p>"},{"location":"guides/convolution/#why-separable","title":"Why Separable?","text":"<p>A 2D convolution with an N\u00d7N kernel requires N\u00b2 operations per pixel. A separable kernel can be decomposed into two 1D convolutions, requiring only 2N operations.</p> <p>Performance Gain: - 3\u00d73: 1.5\u00d7 faster - 5\u00d75: 2.5\u00d7 faster - 9\u00d79: 4.5\u00d7 faster - 15\u00d715: 7.5\u00d7 faster - 21\u00d721: 10.5\u00d7 faster</p>"},{"location":"guides/convolution/#usage","title":"Usage","text":"<pre><code>// Create 1D Gaussian kernel\nlet kernel_1d = create_gaussian_1d(9, 2.0);\n\n// Apply separable convolution (much faster!)\nlet blurred = image.convolve_separable(\n    &amp;kernel_1d,\n    &amp;kernel_1d,\n    BorderMode::Replicate\n);\n\n// Helper function to create 1D Gaussian\nfn create_gaussian_1d(size: usize, sigma: f32) -&gt; Vec&lt;f32&gt; {\n    assert!(size % 2 == 1);\n    let half = (size / 2) as i32;\n    let mut kernel = Vec::with_capacity(size);\n    let mut sum = 0.0;\n\n    for i in -half..=half {\n        let coeff = 1.0 / (core::f32::consts::TAU.sqrt() * sigma);\n        let exp = -(i as f32 * i as f32) / (2.0 * sigma * sigma);\n        let value = coeff * exp.exp();\n        kernel.push(value);\n        sum += value;\n    }\n\n    // Normalize\n    for value in &amp;mut kernel {\n        *value /= sum;\n    }\n\n    kernel\n}\n</code></pre>"},{"location":"guides/convolution/#when-to-use-separable-convolution","title":"When to Use Separable Convolution","text":"<p>\u2705 Use separable when: - Gaussian blur (always separable) - Box blur (always separable) - Large kernel sizes (&gt; 5\u00d75) - You care about performance</p> <p>\u274c Don't use separable for: - Sobel (not separable in practice) - Laplacian (not separable) - Custom non-separable kernels - Small kernels (3\u00d73) where overhead may not be worth it</p>"},{"location":"guides/convolution/#parallel-processing","title":"Parallel Processing","text":"<p>By default, convolution uses all available CPU cores via Rayon.</p>"},{"location":"guides/convolution/#enabledisable","title":"Enable/Disable","text":"<pre><code># Cargo.toml\n\n# Enable parallel processing (default)\n[dependencies]\ncv-rusty = \"0.2.0\"\n\n# Disable parallel processing\n[dependencies]\ncv-rusty = { version = \"0.2.0\", default-features = false, features = [\"std\"] }\n</code></pre>"},{"location":"guides/convolution/#performance-impact","title":"Performance Impact","text":"<p>On a 1920\u00d71080 image with a 9\u00d79 kernel: - Single-threaded: ~200ms - Multi-threaded (8 cores): ~30ms - Speedup: ~6.7\u00d7</p> <p>Guidelines: - Parallel is best for large images (&gt; 500\u00d7500) - Parallel is best for large kernels (&gt; 5\u00d75) - Small images may be faster single-threaded due to overhead - Benchmark your specific use case</p>"},{"location":"guides/convolution/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/convolution/#1-always-use-release-mode","title":"1. Always Use Release Mode","text":"<pre><code>cargo build --release\ncargo run --release --example convolution_benchmark\n</code></pre> <p>Debug mode can be 100\u00d7 slower than release mode!</p>"},{"location":"guides/convolution/#2-use-separable-convolution-for-large-kernels","title":"2. Use Separable Convolution for Large Kernels","text":"<pre><code>// \u274c Slow: O(n\u00b2) per pixel\nlet kernel = Kernel::gaussian(15, 3.0);\nlet result = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// \u2705 Fast: O(2n) per pixel\nlet kernel_1d = create_gaussian_1d(15, 3.0);\nlet result = image.convolve_separable(&amp;kernel_1d, &amp;kernel_1d, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#3-choose-appropriate-kernel-sizes","title":"3. Choose Appropriate Kernel Sizes","text":"<p>Larger kernels = stronger effect but slower:</p> Kernel Size Effect Strength Speed (relative) 3\u00d73 Minimal 1\u00d7 (fastest) 5\u00d75 Light 3\u00d7 7\u00d77 Medium 5\u00d7 9\u00d79 Strong 9\u00d7 15\u00d715 Very Strong 25\u00d7"},{"location":"guides/convolution/#4-reuse-kernels","title":"4. Reuse Kernels","text":"<pre><code>// \u274c Recreates kernel each time\nfor image in images {\n    let kernel = Kernel::gaussian(5, 1.0);\n    let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n}\n\n// \u2705 Reuse kernel\nlet kernel = Kernel::gaussian(5, 1.0);\nfor image in images {\n    let result = image.convolve(&amp;kernel, BorderMode::Replicate);\n}\n</code></pre>"},{"location":"guides/convolution/#5-process-in-batches","title":"5. Process in Batches","text":"<p>For many images, use parallel iteration:</p> <pre><code>use rayon::prelude::*;\n\nlet results: Vec&lt;Matrix3&gt; = images\n    .par_iter()\n    .map(|img| img.convolve(&amp;kernel, BorderMode::Replicate))\n    .collect();\n</code></pre>"},{"location":"guides/convolution/#working-with-grayscale-images","title":"Working with Grayscale Images","text":"<p>Convolution works the same for <code>Matrix1</code> (grayscale):</p> <pre><code>use cv_rusty::{Matrix1, Kernel, BorderMode};\n\n// Convert to grayscale first\nlet gray = image.to_grayscale();\n\n// Apply convolution\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = gray.convolve(&amp;kernel, BorderMode::Replicate);\n\n// Grayscale is ~3\u00d7 faster than RGB (single channel)\n</code></pre>"},{"location":"guides/convolution/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/convolution/#blur-then-edge-detection","title":"Blur then Edge Detection","text":"<pre><code>// Reduce noise before edge detection\nlet kernel = Kernel::gaussian(3, 0.5);\nlet smoothed = image.convolve(&amp;kernel, BorderMode::Replicate);\n\nlet sobel_x = Kernel::sobel_x();\nlet edges = smoothed.convolve(&amp;sobel_x, BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#unsharp-mask-advanced-sharpening","title":"Unsharp Mask (Advanced Sharpening)","text":"<pre><code>// 1. Create blurred version\nlet kernel = Kernel::gaussian(5, 1.0);\nlet blurred = image.convolve(&amp;kernel, BorderMode::Replicate);\n\n// 2. Subtract blurred from original (implement pixel-wise operations)\n// 3. Add difference back to original with weight\n</code></pre>"},{"location":"guides/convolution/#multi-scale-processing","title":"Multi-scale Processing","text":"<pre><code>// Apply different kernel sizes\nlet blur_small = image.convolve(&amp;Kernel::gaussian(3, 0.5), BorderMode::Replicate);\nlet blur_medium = image.convolve(&amp;Kernel::gaussian(5, 1.0), BorderMode::Replicate);\nlet blur_large = image.convolve(&amp;Kernel::gaussian(9, 2.0), BorderMode::Replicate);\n</code></pre>"},{"location":"guides/convolution/#benchmarking","title":"Benchmarking","text":"<p>Run the benchmark example to test performance on your hardware:</p> <pre><code># With parallel processing\ncargo run --release --example convolution_benchmark\n\n# Without parallel processing\ncargo run --release --example convolution_benchmark --no-default-features --features std\n</code></pre> <p>Expected output: <pre><code>=== Convolution Performance Benchmark ===\n\nImage size: 1920x1080 (2073600 pixels)\n\u2713 Parallel processing ENABLED (using rayon)\n\n--- Small Kernel (3x3) ---\nSobel X              3x3:     8.45ms (2204 MOps/sec)\nSharpen              3x3:     8.32ms (2238 MOps/sec)\nLaplacian            3x3:     8.41ms (2214 MOps/sec)\n\n--- Medium Kernel (5x5) ---\nGaussian 5x5         5x5:    18.23ms (2553 MOps/sec)\nBox Blur 5x5         5x5:    17.89ms (2601 MOps/sec)\n\n--- Large Kernel (9x9) ---\nGaussian 9x9         9x9:    52.67ms (2848 MOps/sec)\nBox Blur 9x9         9x9:    51.34ms (2921 MOps/sec)\n\n--- Separable Convolution ---\nGaussian 5x5         5x1 + 1x5:     9.12ms (2281 MOps/sec, 2.5x speedup vs 2D)\nGaussian 9x9         9x1 + 1x9:    16.45ms (2532 MOps/sec, 4.5x speedup vs 2D)\nGaussian 15x15       15x1 + 1x15:   27.89ms (2236 MOps/sec, 7.5x speedup vs 2D)\n\nThroughput: 73.52 Mpixels/sec\n</code></pre></p>"},{"location":"guides/convolution/#no_std-support","title":"no_std Support","text":"<p>Convolution works in <code>no_std</code> environments:</p> <pre><code>#![no_std]\n\nextern crate alloc;\nuse alloc::vec;\nuse cv_rusty::{Matrix3, Kernel, BorderMode};\n\nfn process_camera_frame(frame: &amp;Matrix3) -&gt; Matrix3 {\n    // Edge detection for embedded vision system\n    let kernel = Kernel::sobel_x();\n    frame.convolve(&amp;kernel, BorderMode::Replicate)\n}\n</code></pre> <p>Note: Parallel processing requires <code>std</code> and is automatically disabled in <code>no_std</code> builds.</p>"},{"location":"guides/convolution/#examples","title":"Examples","text":"<p>See the examples directory for complete working examples:</p> <ul> <li><code>convolution_demo.rs</code> - Demonstrates all built-in kernels</li> <li><code>convolution_benchmark.rs</code> - Performance testing</li> <li>Examples in <code>examples/README.md</code></li> </ul>"},{"location":"guides/convolution/#api-reference","title":"API Reference","text":""},{"location":"guides/convolution/#kernel-methods","title":"Kernel Methods","text":"<pre><code>impl Kernel {\n    pub fn new(width: usize, height: usize, data: Vec&lt;f32&gt;) -&gt; Self;\n    pub fn box_blur(size: usize) -&gt; Self;\n    pub fn gaussian(size: usize, sigma: f32) -&gt; Self;\n    pub fn sobel_x() -&gt; Self;\n    pub fn sobel_y() -&gt; Self;\n    pub fn laplacian() -&gt; Self;\n    pub fn sharpen() -&gt; Self;\n    pub fn width(&amp;self) -&gt; usize;\n    pub fn height(&amp;self) -&gt; usize;\n    pub fn data(&amp;self) -&gt; &amp;[f32];\n}\n</code></pre>"},{"location":"guides/convolution/#matrix-methods","title":"Matrix Methods","text":"<pre><code>impl Matrix1 {\n    pub fn convolve(&amp;self, kernel: &amp;Kernel, border_mode: BorderMode) -&gt; Self;\n    pub fn convolve_separable(&amp;self, kernel_x: &amp;[f32], kernel_y: &amp;[f32], border_mode: BorderMode) -&gt; Self;\n}\n\nimpl Matrix3 {\n    pub fn convolve(&amp;self, kernel: &amp;Kernel, border_mode: BorderMode) -&gt; Self;\n    pub fn convolve_separable(&amp;self, kernel_x: &amp;[f32], kernel_y: &amp;[f32], border_mode: BorderMode) -&gt; Self;\n}\n</code></pre>"},{"location":"guides/convolution/#bordermode-enum","title":"BorderMode Enum","text":"<pre><code>pub enum BorderMode {\n    Zero,\n    Replicate,\n    Reflect,\n    Wrap,\n}\n</code></pre>"},{"location":"guides/convolution/#further-reading","title":"Further Reading","text":"<ul> <li>Convolution on Wikipedia</li> <li>Gaussian Blur</li> <li>Sobel Operator</li> <li>Image Filtering Tutorial</li> </ul>"},{"location":"guides/custom_rotation/","title":"Custom Rotation Feature Guide","text":"<p>This document provides a comprehensive guide to the custom rotation feature added to cv-rusty, which supports arbitrary rotation angles with both degrees and radians.</p>"},{"location":"guides/custom_rotation/#overview","title":"Overview","text":"<p>The custom rotation feature extends cv-rusty's rotation capabilities beyond the original 90-degree increments to support any arbitrary angle. This enables precise image adjustments, straightening tilted images, and creating artistic effects.</p>"},{"location":"guides/custom_rotation/#key-features","title":"Key Features","text":"<ul> <li>\u2705 Arbitrary Angles: Rotate by any angle, not just 90\u00b0 increments</li> <li>\u2705 Dual Units: Support for both degrees and radians</li> <li>\u2705 Bidirectional: Positive values rotate clockwise, negative counter-clockwise</li> <li>\u2705 Interpolation Options: Choose between nearest neighbor (fast) or bilinear (quality)</li> <li>\u2705 Auto-sizing: Output dimensions automatically calculated to fit entire rotated image</li> <li>\u2705 no_std Compatible: Works in embedded environments</li> <li>\u2705 Both Matrix Types: Available for Matrix3 (RGB) and Matrix1 (grayscale)</li> </ul>"},{"location":"guides/custom_rotation/#api-reference","title":"API Reference","text":""},{"location":"guides/custom_rotation/#rotation-enum","title":"Rotation Enum","text":"<pre><code>pub enum Rotation {\n    /// Rotation in degrees (e.g., 45.0 for 45 degrees clockwise)\n    Degrees(f32),\n    /// Rotation in radians (e.g., PI/4 for 45 degrees clockwise)\n    Radians(f32),\n}\n</code></pre>"},{"location":"guides/custom_rotation/#methods","title":"Methods","text":"<pre><code>impl Rotation {\n    /// Converts the rotation to radians\n    pub fn to_radians(&amp;self) -&gt; f32\n\n    /// Converts the rotation to degrees\n    pub fn to_degrees(&amp;self) -&gt; f32\n}\n</code></pre>"},{"location":"guides/custom_rotation/#matrix-methods","title":"Matrix Methods","text":"<pre><code>impl Matrix3 {\n    /// Rotates the image by an arbitrary angle using interpolation\n    pub fn rotate_custom(&amp;self, angle: Rotation, method: InterpolationMethod) -&gt; Self\n}\n\nimpl Matrix1 {\n    /// Rotates the image by an arbitrary angle using interpolation\n    pub fn rotate_custom(&amp;self, angle: Rotation, method: InterpolationMethod) -&gt; Self\n}\n</code></pre>"},{"location":"guides/custom_rotation/#usage-examples","title":"Usage Examples","text":""},{"location":"guides/custom_rotation/#basic-usage-with-degrees","title":"Basic Usage with Degrees","text":"<pre><code>use cv_rusty::{Matrix3, Rotation, InterpolationMethod};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Rotate 45 degrees clockwise\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(45.0),\n    InterpolationMethod::Bilinear\n);\n\nprintln!(\"New dimensions: {}x{}\", rotated.width(), rotated.height());\n</code></pre>"},{"location":"guides/custom_rotation/#basic-usage-with-radians","title":"Basic Usage with Radians","text":"<pre><code>use cv_rusty::{Matrix3, Rotation, InterpolationMethod};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Rotate PI/4 radians (45 degrees)\nlet rotated = image.rotate_custom(\n    Rotation::Radians(std::f32::consts::PI / 4.0),\n    InterpolationMethod::Bilinear\n);\n</code></pre>"},{"location":"guides/custom_rotation/#counter-clockwise-rotation","title":"Counter-Clockwise Rotation","text":"<pre><code>// Use negative angles to rotate counter-clockwise\nlet rotated_ccw = image.rotate_custom(\n    Rotation::Degrees(-30.0),\n    InterpolationMethod::Bilinear\n);\n\n// Also works with radians\nlet rotated_ccw = image.rotate_custom(\n    Rotation::Radians(-std::f32::consts::PI / 6.0),\n    InterpolationMethod::Bilinear\n);\n</code></pre>"},{"location":"guides/custom_rotation/#choosing-interpolation-method","title":"Choosing Interpolation Method","text":"<pre><code>// Bilinear: Better quality, slightly slower\nlet high_quality = image.rotate_custom(\n    Rotation::Degrees(15.0),\n    InterpolationMethod::Bilinear\n);\n\n// Nearest Neighbor: Faster, more pixelated\nlet fast = image.rotate_custom(\n    Rotation::Degrees(15.0),\n    InterpolationMethod::NearestNeighbor\n);\n</code></pre>"},{"location":"guides/custom_rotation/#converting-between-units","title":"Converting Between Units","text":"<pre><code>use cv_rusty::Rotation;\n\n// Create rotation in degrees\nlet deg_45 = Rotation::Degrees(45.0);\nprintln!(\"In radians: {}\", deg_45.to_radians()); // 0.785398...\n\n// Create rotation in radians\nlet rad_pi4 = Rotation::Radians(std::f32::consts::PI / 4.0);\nprintln!(\"In degrees: {}\", rad_pi4.to_degrees()); // 45.0\n</code></pre>"},{"location":"guides/custom_rotation/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guides/custom_rotation/#1-straightening-tilted-images","title":"1. Straightening Tilted Images","text":"<pre><code>fn straighten_image(image: &amp;Matrix3, tilt_angle: f32) -&gt; Matrix3 {\n    // Negative angle to correct the tilt\n    image.rotate_custom(\n        Rotation::Degrees(-tilt_angle),\n        InterpolationMethod::Bilinear\n    )\n}\n\n// Example: straighten a photo that's 2.3 degrees tilted\nlet tilted = read_jpeg(\"tilted_photo.jpg\")?;\nlet straightened = straighten_image(&amp;tilted, 2.3);\nwrite_jpeg(&amp;straightened, \"straightened.jpg\", 90)?;\n</code></pre>"},{"location":"guides/custom_rotation/#2-creating-rotated-thumbnails","title":"2. Creating Rotated Thumbnails","text":"<pre><code>fn create_rotated_thumbnail(image: &amp;Matrix3, angle: f32, size: usize) -&gt; Matrix3 {\n    image\n        .resize(size, size, InterpolationMethod::Bilinear)\n        .rotate_custom(\n            Rotation::Degrees(angle),\n            InterpolationMethod::Bilinear\n        )\n}\n\nlet thumbnail = create_rotated_thumbnail(&amp;image, 15.0, 200);\n</code></pre>"},{"location":"guides/custom_rotation/#3-artistic-effects-multiple-rotations","title":"3. Artistic Effects - Multiple Rotations","text":"<pre><code>fn create_kaleidoscope_effect(image: &amp;Matrix3, divisions: usize) -&gt; Vec&lt;Matrix3&gt; {\n    let angle_step = 360.0 / divisions as f32;\n\n    (0..divisions)\n        .map(|i| {\n            let angle = i as f32 * angle_step;\n            image.rotate_custom(\n                Rotation::Degrees(angle),\n                InterpolationMethod::Bilinear\n            )\n        })\n        .collect()\n}\n\n// Create 8 rotated versions at different angles\nlet rotations = create_kaleidoscope_effect(&amp;image, 8);\n</code></pre>"},{"location":"guides/custom_rotation/#4-precise-alignment","title":"4. Precise Alignment","text":"<pre><code>fn align_images(base: &amp;Matrix3, overlay: &amp;Matrix3, alignment_angle: f32) -&gt; Matrix3 {\n    // Rotate overlay to match base image orientation\n    overlay.rotate_custom(\n        Rotation::Degrees(alignment_angle),\n        InterpolationMethod::Bilinear\n    )\n}\n</code></pre>"},{"location":"guides/custom_rotation/#5-batch-processing-with-different-angles","title":"5. Batch Processing with Different Angles","text":"<pre><code>fn process_with_angles(image: &amp;Matrix3, angles: &amp;[f32]) -&gt; Vec&lt;Matrix3&gt; {\n    angles.iter()\n        .map(|&amp;angle| {\n            image.rotate_custom(\n                Rotation::Degrees(angle),\n                InterpolationMethod::Bilinear\n            )\n        })\n        .collect()\n}\n\nlet angles = vec![15.0, 30.0, 45.0, 60.0, 75.0];\nlet rotated_images = process_with_angles(&amp;image, &amp;angles);\n</code></pre>"},{"location":"guides/custom_rotation/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/custom_rotation/#interpolation-method-impact","title":"Interpolation Method Impact","text":"Method Speed Quality Best For Nearest Neighbor ~2x faster Lower Speed-critical, pixel art Bilinear Baseline Higher Photos, general use"},{"location":"guides/custom_rotation/#angle-impact","title":"Angle Impact","text":"<ul> <li>Small angles (&lt; 15\u00b0) are fastest</li> <li>45\u00b0 angles are moderate</li> <li>Output image size increases with angle</li> <li>Maximum size occurs at 45\u00b0 for square images</li> </ul>"},{"location":"guides/custom_rotation/#memory-usage","title":"Memory Usage","text":"<pre><code>// Calculate memory requirements\nlet original_size = width * height * 3; // RGB image\n\n// Worst case (45\u00b0 rotation of square image):\nlet max_size = (width as f32 * 1.414) as usize; // sqrt(2) \u2248 1.414\nlet rotated_size = max_size * max_size * 3;\n\nlet total_memory = original_size + rotated_size; // Both exist during operation\n</code></pre>"},{"location":"guides/custom_rotation/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Crop before rotating - Reduce input size first</li> <li>Choose appropriate interpolation - Use nearest neighbor when quality isn't critical</li> <li>Avoid repeated rotations - Rotate once to final angle</li> <li>Consider 90\u00b0 increments - Use <code>rotate()</code> instead when possible (faster, lossless)</li> </ol>"},{"location":"guides/custom_rotation/#output-dimensions","title":"Output Dimensions","text":"<p>The output image is automatically sized to contain the entire rotated image without cropping.</p>"},{"location":"guides/custom_rotation/#example-dimension-changes","title":"Example Dimension Changes","text":"<p>Square Images (100\u00d7100): - 0\u00b0: 100\u00d7100 - 15\u00b0: ~104\u00d7104 - 30\u00b0: ~116\u00d7116 - 45\u00b0: ~141\u00d7141 (maximum) - 90\u00b0: 100\u00d7100</p> <p>Rectangular Images (200\u00d7100): - 0\u00b0: 200\u00d7100 - 30\u00b0: ~249\u00d7230 - 45\u00b0: ~212\u00d7212 - 90\u00b0: 100\u00d7200</p>"},{"location":"guides/custom_rotation/#comparison-fixed-vs-custom-rotation","title":"Comparison: Fixed vs Custom Rotation","text":"Feature <code>rotate()</code> <code>rotate_custom()</code> Angles 90\u00b0, 180\u00b0, 270\u00b0 Any angle Speed Very fast Moderate Quality Lossless Depends on interpolation Dimensions Predictable Auto-calculated Use Case Simple rotations Precise adjustments Overhead None Interpolation required"},{"location":"guides/custom_rotation/#when-to-use-each-method","title":"When to Use Each Method","text":""},{"location":"guides/custom_rotation/#use-rotate-fixed-angles-when","title":"Use <code>rotate()</code> (Fixed Angles) When:","text":"<ul> <li>You need 90\u00b0, 180\u00b0, or 270\u00b0 rotation</li> <li>Performance is critical</li> <li>You want lossless transformation</li> <li>Dimensions are important to predict</li> </ul>"},{"location":"guides/custom_rotation/#use-rotate_custom-arbitrary-angles-when","title":"Use <code>rotate_custom()</code> (Arbitrary Angles) When:","text":"<ul> <li>You need precise angle control</li> <li>Straightening tilted images</li> <li>Creating artistic effects</li> <li>Aligning images</li> <li>Small adjustments (&lt; 45\u00b0)</li> </ul>"},{"location":"guides/custom_rotation/#error-handling","title":"Error Handling","text":"<p>Both methods always succeed and return a valid image:</p> <pre><code>// No Result type - always succeeds\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(45.0),\n    InterpolationMethod::Bilinear\n);\n</code></pre> <p>Pixels outside the original image bounds are filled with black (0, 0, 0).</p>"},{"location":"guides/custom_rotation/#no_std-compatibility","title":"no_std Compatibility","text":"<p>The custom rotation feature is fully compatible with <code>no_std</code> environments:</p> <pre><code>#![no_std]\nextern crate alloc;\n\nuse cv_rusty::{Matrix3, Rotation, InterpolationMethod};\n\n// Works in embedded systems\nlet image = Matrix3::zeros(320, 240);\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(30.0),\n    InterpolationMethod::NearestNeighbor\n);\n</code></pre> <p>Uses <code>libm</code> for trigonometric functions in <code>no_std</code> mode.</p>"},{"location":"guides/custom_rotation/#testing","title":"Testing","text":"<p>Run the custom rotation tests:</p> <pre><code># Run all transform tests\ncargo test transform::\n\n# Run specific rotation tests\ncargo test rotate_custom\n\n# Test with all features\ncargo test --all-features\n\n# Verify no_std compatibility\ncargo build --no-default-features\n</code></pre>"},{"location":"guides/custom_rotation/#example-program","title":"Example Program","text":"<p>See <code>examples/transform_demo.rs</code> for a complete demonstration:</p> <pre><code>cargo run --example transform_demo --release\n</code></pre> <p>This will create several output files demonstrating: - 45\u00b0 rotation with degrees - 30\u00b0 rotation with nearest neighbor - PI/6 radians rotation - -22.5\u00b0 counter-clockwise rotation</p>"},{"location":"guides/custom_rotation/#mathematical-background","title":"Mathematical Background","text":""},{"location":"guides/custom_rotation/#rotation-matrix","title":"Rotation Matrix","text":"<p>For angle \u03b8 (in radians), clockwise rotation:</p> <pre><code>[cos(\u03b8)  -sin(\u03b8)]\n[sin(\u03b8)   cos(\u03b8)]\n</code></pre>"},{"location":"guides/custom_rotation/#implementation","title":"Implementation","text":"<p>Uses inverse rotation to map output pixels to source:</p> <pre><code>For each output pixel (x_out, y_out):\n  1. Translate to origin (subtract center)\n  2. Apply inverse rotation\n  3. Translate back (add center)\n  4. Sample source image with interpolation\n</code></pre>"},{"location":"guides/custom_rotation/#why-inverse-rotation","title":"Why Inverse Rotation?","text":"<p>Forward rotation would leave gaps. Inverse rotation ensures every output pixel is filled by sampling the appropriate source location.</p>"},{"location":"guides/custom_rotation/#limitations","title":"Limitations","text":"<ol> <li>No arbitrary center: Rotation is always around the image center</li> <li>No crop to original size: Output is always sized to fit the full rotation</li> <li>Quality loss: Unlike 90\u00b0 rotations, interpolation causes some quality loss</li> <li>Performance: Slower than fixed-angle rotations</li> </ol>"},{"location":"guides/custom_rotation/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions: - [ ] Rotation around custom pivot point - [ ] Crop to original dimensions option - [ ] Bicubic interpolation - [ ] SIMD optimizations - [ ] GPU acceleration</p>"},{"location":"guides/custom_rotation/#additional-resources","title":"Additional Resources","text":"<ul> <li>Main documentation: <code>README.md</code></li> <li>Transform operations guide: <code>TRANSFORM_OPERATIONS.md</code></li> <li>Quick reference: <code>docs/quick-reference.md</code></li> <li>API docs: Run <code>cargo doc --open</code></li> </ul>"},{"location":"guides/custom_rotation/#questions","title":"Questions?","text":"<p>For more information: 1. Check the examples in <code>examples/transform_demo.rs</code> 2. Read the API documentation: <code>cargo doc --open</code> 3. Look at the test cases in <code>src/transform.rs</code></p>"},{"location":"guides/drawing/","title":"Drawing Shapes Guide","text":"<p>The drawing module provides functionality to render shapes (rectangles and circles) on both grayscale (<code>Matrix1</code>) and RGB (<code>Matrix3</code>) images.</p>"},{"location":"guides/drawing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Color System</li> <li>Drawing Rectangles</li> <li>Drawing Circles</li> <li>Performance Considerations</li> <li>Examples</li> <li>Advanced Techniques</li> </ul>"},{"location":"guides/drawing/#overview","title":"Overview","text":"<p>The drawing module is <code>no_std</code> compatible and provides:</p> <ul> <li>\u2705 Rectangle drawing with rotation, stroke, and fill</li> <li>\u2705 Circle drawing with stroke and fill</li> <li>\u2705 Grayscale support via <code>Matrix1</code></li> <li>\u2705 RGB support via <code>Matrix3</code></li> <li>\u2705 Flexible styling with customizable colors, stroke width, and fill</li> <li>\u2705 Rotation support for rectangles (in degrees)</li> <li>\u2705 Opacity/transparency support with alpha blending</li> <li>\u2705 Anti-aliasing-free rendering (pixel-perfect)</li> </ul>"},{"location":"guides/drawing/#color-system","title":"Color System","text":"<p>The <code>Color</code> enum provides a unified way to specify colors for both grayscale and RGB images:</p> <pre><code>use cv_rusty::drawing::Color;\n\n// Create colors using constructors\nlet black = Color::black();           // RGB(0, 0, 0)\nlet white = Color::white();           // RGB(255, 255, 255)\nlet red = Color::rgb(255, 0, 0);      // RGB color\nlet gray = Color::gray(128);          // Grayscale\n\n// Create colors from hex strings\nlet blue = Color::from_hex(\"#0000FF\").unwrap();      // 6-digit with #\nlet green = Color::from_hex(\"00FF00\").unwrap();      // 6-digit without #\nlet cyan = Color::from_hex(\"#0FF\").unwrap();         // 3-digit format\nlet magenta = Color::from_hex(\"F0F\").unwrap();       // 3-digit without #\n\n// Parse from strings using FromStr trait\nlet yellow: Color = \"#FFFF00\".parse().unwrap();\nlet orange: Color = \"FF8800\".parse().unwrap();\n\n// Create colors with custom opacity (0.0 = fully transparent, 1.0 = fully opaque)\nlet semi_red = Color::rgb_with_opacity(255, 0, 0, 0.5);      // 50% transparent red\nlet semi_gray = Color::gray_with_opacity(128, 0.7);          // 70% opaque gray\n\n// Modify opacity of existing colors\nlet opaque_blue = Color::rgb(0, 0, 255);\nlet transparent_blue = opaque_blue.with_opacity(0.3);        // 30% opaque blue\n\n// Get opacity value\nlet opacity = semi_red.opacity();     // 0.5\n\n// Conversions\nlet rgb_tuple = red.to_rgb();         // (255, 0, 0)\nlet gray_value = red.to_gray();       // 76 (using luminance formula)\n</code></pre>"},{"location":"guides/drawing/#hex-color-format","title":"Hex Color Format","text":"<p>The <code>Color::from_hex()</code> method and <code>FromStr</code> trait support multiple hex formats:</p> <p>6-digit format (RRGGBB): - <code>\"#FF0000\"</code> or <code>\"FF0000\"</code> \u2192 Red (255, 0, 0) - <code>\"#00FF00\"</code> or <code>\"00FF00\"</code> \u2192 Green (0, 255, 0) - <code>\"#0000FF\"</code> or <code>\"0000FF\"</code> \u2192 Blue (0, 0, 255)</p> <p>3-digit format (RGB): - <code>\"#F00\"</code> or <code>\"F00\"</code> \u2192 Red (255, 0, 0) - expands to FF0000 - <code>\"#0F0\"</code> or <code>\"0F0\"</code> \u2192 Green (0, 255, 0) - expands to 00FF00 - <code>\"#00F\"</code> or <code>\"00F\"</code> \u2192 Blue (0, 0, 255) - expands to 0000FF</p> <p>The 3-digit format expands each digit: <code>F</code> \u2192 <code>FF</code>, <code>0</code> \u2192 <code>00</code>, etc. This means <code>#369</code> expands to <code>#336699</code> (RGB: 51, 102, 153).</p> <p>Case insensitive: - <code>\"#FFFFFF\"</code>, <code>\"#ffffff\"</code>, or <code>\"#FfFfFf\"</code> all work</p> <p>With or without hash: - Both <code>\"#FF0000\"</code> and <code>\"FF0000\"</code> are valid</p>"},{"location":"guides/drawing/#opacity-and-alpha-blending","title":"Opacity and Alpha Blending","text":"<p>Colors support opacity values between 0.0 (fully transparent) and 1.0 (fully opaque). When drawing with semi-transparent colors, the new color is blended with the existing pixel using alpha blending:</p> <pre><code>result = existing_color * (1 - opacity) + new_color * opacity\n</code></pre> <p>Key features: - Default opacity is <code>1.0</code> (fully opaque) for all standard constructors - Opacity is automatically clamped to the range <code>[0.0, 1.0]</code> - Works with both grayscale and RGB images - Fully transparent colors (opacity = 0.0) do not modify pixels - Blending occurs for each color channel independently</p> <pre><code>// Create semi-transparent colors\nlet semi_red = Color::rgb_with_opacity(255, 0, 0, 0.5);\nlet semi_gray = Color::gray_with_opacity(200, 0.3);\n\n// Modify opacity of existing colors\nlet blue = Color::rgb(0, 0, 255);\nlet transparent_blue = blue.with_opacity(0.4);\n\n// Draw with transparency\ndraw_circle(\n    &amp;mut image,\n    320.0, 240.0,\n    50.0,\n    None,\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.6))  // 60% opaque red\n);\n</code></pre>"},{"location":"guides/drawing/#grayscale-conversion","title":"Grayscale Conversion","text":"<p>When drawing RGB colors on grayscale images or vice versa, automatic conversion occurs:</p> <ul> <li>RGB \u2192 Gray: Uses standard luminance formula: <code>0.299*R + 0.587*G + 0.114*B</code></li> <li>Gray \u2192 RGB: Replicates gray value across all channels: <code>(gray, gray, gray)</code></li> </ul>"},{"location":"guides/drawing/#drawing-rectangles","title":"Drawing Rectangles","text":"<p>Rectangles are drawn with their center at the specified <code>(x, y)</code> position.</p>"},{"location":"guides/drawing/#function-signatures","title":"Function Signatures","text":"<pre><code>// Works with both RGB (Matrix3) and grayscale (Matrix1) images\npub fn draw_rectangle&lt;T: DrawTarget&gt;(\n    image: &amp;mut T,\n    x: f32,                    // X coordinate of center\n    y: f32,                    // Y coordinate of center\n    width: f32,                // Width of rectangle\n    height: f32,               // Height of rectangle\n    rotation: f32,             // Rotation in degrees (clockwise)\n    stroke: Option&lt;Stroke&gt;,    // Optional stroke with width and color\n    fill_color: Option&lt;Color&gt;, // Fill color (None for no fill)\n)\n</code></pre>"},{"location":"guides/drawing/#basic-rectangle","title":"Basic Rectangle","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, draw_rectangle, Color, Stroke};\n\n// Works with RGB images\nlet mut rgb_image = Matrix3::zeros(480, 640);\ndraw_rectangle(\n    &amp;mut rgb_image,\n    320.0, 240.0,  // Center at (320, 240)\n    100.0, 60.0,   // 100 pixels wide, 60 pixels tall\n    0.0,           // No rotation\n    Some(Stroke::new(2, Color::rgb(0, 0, 0))),  // 2px black border\n    Some(Color::rgb(255, 0, 0))                 // Red fill\n);\n\n// Also works with grayscale images\nlet mut gray_image = Matrix1::zeros(480, 640);\ndraw_rectangle(\n    &amp;mut gray_image,\n    320.0, 240.0,\n    100.0, 60.0,\n    0.0,\n    Some(Stroke::new(2, Color::gray(255))),  // 2px white border\n    Some(Color::gray(100))                   // Dark gray fill\n);\n</code></pre>"},{"location":"guides/drawing/#rotated-rectangle","title":"Rotated Rectangle","text":"<pre><code>// Draw a green rectangle rotated 45 degrees (works with any image type)\ndraw_rectangle(\n    &amp;mut rgb_image,\n    200.0, 150.0,  // Center position\n    80.0, 120.0,   // Width and height\n    45.0,          // 45 degrees clockwise\n    Some(Stroke::new(3, Color::rgb(255, 255, 255))),  // 3px white border\n    Some(Color::rgb(0, 255, 0))                       // Green fill\n);\n</code></pre>"},{"location":"guides/drawing/#outline-only-rectangle","title":"Outline-Only Rectangle","text":"<pre><code>// Draw just the outline (no fill, works with any image type)\ndraw_rectangle(\n    &amp;mut rgb_image,\n    400.0, 300.0,\n    150.0, 100.0,\n    30.0,          // Rotated 30 degrees\n    Some(Stroke::new(4, Color::rgb(0, 0, 255))),  // 4px blue outline\n    None           // No fill\n);\n</code></pre>"},{"location":"guides/drawing/#fill-only-rectangle","title":"Fill-Only Rectangle","text":"<pre><code>// Draw filled rectangle without border (works with any image type)\ndraw_rectangle(\n    &amp;mut rgb_image,\n    500.0, 200.0,\n    60.0, 60.0,\n    0.0,\n    None,          // No stroke\n    Some(Color::rgb(255, 255, 0))    // Yellow fill\n);\n</code></pre>"},{"location":"guides/drawing/#semi-transparent-rectangle","title":"Semi-Transparent Rectangle","text":"<pre><code>// Draw overlapping semi-transparent rectangles\ndraw_rectangle(\n    &amp;mut rgb_image,\n    200.0, 200.0,\n    150.0, 100.0,\n    0.0,\n    None,\n    Some(Color::rgb(0, 0, 255))  // Opaque blue background\n);\n\n// Overlapping semi-transparent red rectangle\ndraw_rectangle(\n    &amp;mut rgb_image,\n    250.0, 220.0,\n    150.0, 100.0,\n    0.0,\n    None,\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.5))  // 50% transparent red\n);\n// The overlap will show a purple blend\n</code></pre>"},{"location":"guides/drawing/#drawing-circles","title":"Drawing Circles","text":"<p>Circles are drawn with their center at the specified <code>(x, y)</code> position.</p>"},{"location":"guides/drawing/#function-signatures_1","title":"Function Signatures","text":"<pre><code>// Works with both RGB (Matrix3) and grayscale (Matrix1) images\npub fn draw_circle&lt;T: DrawTarget&gt;(\n    image: &amp;mut T,\n    x: f32,                    // X coordinate of center\n    y: f32,                    // Y coordinate of center\n    radius: f32,               // Radius of circle\n    stroke: Option&lt;Stroke&gt;,    // Optional stroke with width and color\n    fill_color: Option&lt;Color&gt;, // Fill color (None for no fill)\n)\n</code></pre>"},{"location":"guides/drawing/#basic-circle","title":"Basic Circle","text":"<pre><code>use cv_rusty::{Matrix3, Matrix1, draw_circle, Color, Stroke};\n\n// Works with RGB images\nlet mut rgb_image = Matrix3::zeros(480, 640);\ndraw_circle(\n    &amp;mut rgb_image,\n    320.0, 240.0,  // Center at (320, 240)\n    50.0,          // Radius of 50 pixels\n    Some(Stroke::new(3, Color::rgb(255, 255, 255))),  // 3px white border\n    Some(Color::rgb(0, 0, 255))                       // Blue fill\n);\n\n// Also works with grayscale images\nlet mut gray_image = Matrix1::zeros(480, 640);\ndraw_circle(\n    &amp;mut gray_image,\n    320.0, 240.0,\n    50.0,\n    Some(Stroke::new(3, Color::gray(255))),  // 3px white border\n    Some(Color::gray(100))                   // Dark gray fill\n);\n</code></pre>"},{"location":"guides/drawing/#outline-only-circle","title":"Outline-Only Circle","text":"<pre><code>// Draw just the outline (no fill, works with any image type)\ndraw_circle(\n    &amp;mut rgb_image,\n    200.0, 200.0,\n    60.0,          // Radius\n    Some(Stroke::new(5, Color::rgb(255, 0, 0))),  // 5px red outline\n    None           // No fill\n);\n</code></pre>"},{"location":"guides/drawing/#fill-only-circle","title":"Fill-Only Circle","text":"<pre><code>// Draw filled circle without border (works with any image type)\ndraw_circle(\n    &amp;mut rgb_image,\n    450.0, 350.0,\n    40.0,          // Radius\n    None,          // No stroke\n    Some(Color::rgb(0, 255, 0))      // Green fill\n);\n</code></pre>"},{"location":"guides/drawing/#semi-transparent-circle","title":"Semi-Transparent Circle","text":"<pre><code>// Draw overlapping semi-transparent circles for a Venn diagram effect\ndraw_circle(\n    &amp;mut rgb_image,\n    200.0, 240.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(200, 0, 0))),\n    Some(Color::rgb_with_opacity(255, 0, 0, 0.6))  // 60% opaque red\n);\n\ndraw_circle(\n    &amp;mut rgb_image,\n    260.0, 240.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(0, 200, 0))),\n    Some(Color::rgb_with_opacity(0, 255, 0, 0.6))  // 60% opaque green\n);\n\ndraw_circle(\n    &amp;mut rgb_image,\n    230.0, 290.0,\n    60.0,\n    Some(Stroke::new(2, Color::rgb(0, 0, 200))),\n    Some(Color::rgb_with_opacity(0, 0, 255, 0.6))  // 60% opaque blue\n);\n// Overlapping areas blend the colors\n</code></pre>"},{"location":"guides/drawing/#unified-api-for-all-image-types","title":"Unified API for All Image Types","text":"<p>The drawing functions work seamlessly with both RGB (<code>Matrix3</code>) and grayscale (<code>Matrix1</code>) images using the <code>DrawTarget</code> trait:</p> <pre><code>use cv_rusty::{Matrix1, Matrix3, draw_rectangle, draw_circle, Color};\n\n// Create both image types\nlet mut rgb_image = Matrix3::zeros(480, 640);\nlet mut gray_image = Matrix1::zeros(480, 640);\n\n// Same function works for both!\ndraw_rectangle(\n    &amp;mut rgb_image,\n    200.0, 150.0,\n    100.0, 80.0,\n    15.0,\n    2,\n    Some(Color::rgb(255, 255, 255)),  // White border\n    Some(Color::rgb(255, 0, 0))       // Red fill\n);\n\ndraw_rectangle(\n    &amp;mut gray_image,\n    200.0, 150.0,\n    100.0, 80.0,\n    15.0,\n    2,\n    Some(Color::gray(255)),  // White border\n    Some(Color::gray(50))    // Dark gray fill\n);\n\n// Colors are automatically converted to the appropriate format\ndraw_circle(\n    &amp;mut gray_image,\n    400.0, 300.0,\n    60.0,\n    3,\n    Some(Color::rgb(0, 0, 0)),    // RGB black automatically converts to gray\n    Some(Color::gray(200))        // Light gray fill\n);\n</code></pre>"},{"location":"guides/drawing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/drawing/#rectangle-drawing","title":"Rectangle Drawing","text":"<ul> <li>Axis-aligned rectangles (rotation = 0\u00b0) are slightly faster than rotated ones</li> <li>Rotation uses scanline rendering with point-in-polygon tests</li> <li>Time complexity: O(bounding_box_area) for rotated rectangles</li> <li>Best for: UI elements, bounding boxes, region marking</li> </ul>"},{"location":"guides/drawing/#circle-drawing","title":"Circle Drawing","text":"<ul> <li>Uses efficient circle filling algorithm with distance checks</li> <li>Time complexity: O(bounding_box_area)</li> <li>Stroke width is centered on the circle's radius</li> <li>Best for: Markers, highlights, buttons, pie charts</li> </ul>"},{"location":"guides/drawing/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Batch drawing operations when possible</li> <li>Avoid overdraw of large filled shapes when possible</li> <li>Use appropriate stroke widths - very large stroke widths can be slow</li> <li>Consider clipping to image bounds before drawing off-screen shapes</li> </ol>"},{"location":"guides/drawing/#typical-performance","title":"Typical Performance","text":"<p>On a modern CPU (example: Apple M1):</p> Operation Image Size Time Notes Circle (r=50) 640\u00d7480 ~50 \u00b5s With fill and stroke Rectangle 640\u00d7480 ~30 \u00b5s Axis-aligned Rectangle (rotated) 640\u00d7480 ~45 \u00b5s 45\u00b0 rotation 100 shapes 640\u00d7480 ~4 ms Mixed circles and rectangles"},{"location":"guides/drawing/#examples","title":"Examples","text":""},{"location":"guides/drawing/#complete-drawing-example","title":"Complete Drawing Example","text":"<pre><code>use cv_rusty::{Matrix3, draw_rectangle, draw_circle, write_png, Color, Stroke};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Create white canvas\n    let mut image = Matrix3::zeros(600, 800);\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            image.set_pixel(x, y, 255, 255, 255);\n        }\n    }\n\n    // Draw background elements\n    draw_rectangle(\n        &amp;mut image,\n        400.0, 300.0,\n        700.0, 500.0,\n        0.0,\n        None,\n        Some(Color::rgb(240, 240, 255))  // Light blue background\n    );\n\n    // Draw a title bar\n    draw_rectangle(\n        &amp;mut image,\n        400.0, 50.0,\n        700.0, 60.0,\n        0.0,\n        Some(Stroke::new(2, Color::rgb(100, 100, 100))),\n        Some(Color::rgb(60, 120, 200))\n    );\n\n    // Draw some UI elements\n    for i in 0..5 {\n        let x = 150.0 + (i as f32 * 130.0);\n        draw_circle(\n            &amp;mut image,\n            x, 150.0,\n            40.0,\n            Some(Stroke::new(3, Color::rgb(50, 50, 50))),\n            Some(Color::rgb(100, 200, 100))\n        );\n    }\n\n    // Draw rotated indicator\n    draw_rectangle(\n        &amp;mut image,\n        400.0, 450.0,\n        200.0, 30.0,\n        -10.0,  // Slightly rotated\n        Some(Stroke::new(2, Color::rgb(0, 0, 0))),\n        Some(Color::rgb(255, 200, 50))\n    );\n\n    write_png(&amp;image, \"ui_mockup.png\")?;\n    Ok(())\n}\n</code></pre>"},{"location":"guides/drawing/#data-visualization","title":"Data Visualization","text":"<pre><code>use cv_rusty::{Matrix3, draw_circle, draw_rectangle, Color, Stroke};\n\nfn draw_bar_chart(data: &amp;[f32]) -&gt; Matrix3 {\n    let mut image = Matrix3::zeros(400, 600);\n\n    // White background\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            image.set_pixel(x, y, 255, 255, 255);\n        }\n    }\n\n    let bar_width = 40.0;\n    let spacing = 20.0;\n    let max_height = 300.0;\n    let base_y = 350.0;\n\n    for (i, &amp;value) in data.iter().enumerate() {\n        let x = 50.0 + (i as f32 * (bar_width + spacing));\n        let height = value * max_height;\n\n        draw_rectangle(\n            &amp;mut image,\n            x + bar_width / 2.0,\n            base_y - height / 2.0,\n            bar_width,\n            height,\n            0.0,\n            Some(Stroke::new(2, Color::rgb(0, 0, 0))),\n            Some(Color::rgb(100, 150, 255))\n        );\n\n        // Data point marker\n        draw_circle(\n            &amp;mut image,\n            x + bar_width / 2.0,\n            base_y - height,\n            5.0,\n            Some(Stroke::new(1, Color::rgb(0, 0, 0))),\n            Some(Color::rgb(255, 100, 100))\n        );\n    }\n\n    image\n}\n\n// Usage\nlet data = vec![0.3, 0.7, 0.5, 0.9, 0.4, 0.6, 0.8];\nlet chart = draw_bar_chart(&amp;data);\n</code></pre>"},{"location":"guides/drawing/#annotation-tool","title":"Annotation Tool","text":"<pre><code>use cv_rusty::{Matrix3, draw_rectangle, draw_circle, Color, Stroke};\n\nfn annotate_image(\n    image: &amp;mut Matrix3,\n    bbox: (f32, f32, f32, f32),  // x, y, width, height\n    confidence: f32\n) {\n    let (x, y, w, h) = bbox;\n\n    // Draw bounding box\n    let color = if confidence &gt; 0.8 {\n        Color::rgb(0, 255, 0)  // Green for high confidence\n    } else if confidence &gt; 0.5 {\n        Color::rgb(255, 255, 0)  // Yellow for medium\n    } else {\n        Color::rgb(255, 0, 0)  // Red for low confidence\n    };\n\n    draw_rectangle(\n        image,\n        x + w / 2.0,\n        y + h / 2.0,\n        w, h,\n        0.0,\n        Some(Stroke::new(3, color)),\n        None  // No fill, just outline\n    );\n\n    // Draw confidence indicator (corner circles)\n    let radius = 5.0;\n    for (cx, cy) in [\n        (x, y), (x + w, y), (x + w, y + h), (x, y + h)\n    ] {\n        draw_circle(\n            image,\n            cx, cy,\n            radius,\n            None,\n            Some(color)\n        );\n    }\n}\n</code></pre>"},{"location":"guides/drawing/#advanced-techniques","title":"Advanced Techniques","text":""},{"location":"guides/drawing/#layered-drawing","title":"Layered Drawing","text":"<p>Draw shapes in order from back to front for proper layering:</p> <pre><code>// 1. Draw background\ndraw_rectangle(&amp;mut image, 400.0, 300.0, 700.0, 500.0, 0.0, 0, None, \n               Some(Color::rgb(200, 200, 200)));\n\n// 2. Draw middle layer\ndraw_circle(&amp;mut image, 400.0, 300.0, 100.0, 0, None,\n            Some(Color::rgb(100, 100, 255)));\n\n// 3. Draw foreground\ndraw_rectangle(&amp;mut image, 400.0, 300.0, 50.0, 50.0, 45.0, 2,\n               Some(Color::rgb(0, 0, 0)), Some(Color::rgb(255, 255, 255)));\n</code></pre>"},{"location":"guides/drawing/#shape-combinations","title":"Shape Combinations","text":"<p>Create complex shapes by combining primitives:</p> <pre><code>// Draw a target/bullseye\nlet center_x = 400.0;\nlet center_y = 300.0;\n\nfor i in 0..5 {\n    let radius = 100.0 - (i as f32 * 20.0);\n    let color = if i % 2 == 0 {\n        Color::rgb(255, 0, 0)\n    } else {\n        Color::rgb(255, 255, 255)\n    };\n\n    draw_circle(&amp;mut image, center_x, center_y, radius, 0, None, Some(color));\n}\n</code></pre>"},{"location":"guides/drawing/#grid-patterns","title":"Grid Patterns","text":"<pre><code>// Draw a grid\nlet cols = 10;\nlet rows = 8;\nlet cell_size = 50.0;\nlet start_x = 100.0;\nlet start_y = 50.0;\n\nfor row in 0..rows {\n    for col in 0..cols {\n        let x = start_x + (col as f32 * cell_size);\n        let y = start_y + (row as f32 * cell_size);\n\n        let fill = if (row + col) % 2 == 0 {\n            Color::rgb(200, 200, 200)\n        } else {\n            Color::rgb(255, 255, 255)\n        };\n\n        draw_rectangle(\n            &amp;mut image,\n            x + cell_size / 2.0,\n            y + cell_size / 2.0,\n            cell_size,\n            cell_size,\n            0.0,\n            1,\n            Some(Color::rgb(100, 100, 100)),\n            Some(fill)\n        );\n    }\n}\n</code></pre>"},{"location":"guides/drawing/#best-practices","title":"Best Practices","text":"<ol> <li>Pre-calculate coordinates when drawing many shapes</li> <li>Use appropriate data types - functions accept <code>f32</code> for smooth positioning</li> <li>Handle edge cases - shapes are clipped to image bounds automatically</li> <li>Layer thoughtfully - later draws overwrite earlier ones</li> <li>Consider color contrast - ensure shapes are visible against background</li> <li>Test with various rotations - especially for rectangles</li> <li>Validate inputs - ensure dimensions and positions are reasonable</li> </ol>"},{"location":"guides/drawing/#limitations","title":"Limitations","text":"<ul> <li>No anti-aliasing (pixel-perfect rendering only)</li> <li>No line drawing (use thin rectangles as workaround)</li> <li>No ellipse support (use circles only)</li> <li>No polygon support (use multiple rectangles)</li> <li>Rectangle rotation is centered (not arbitrary pivot points)</li> <li>Transparency blending is simple alpha compositing (no premultiplied alpha)</li> </ul>"},{"location":"guides/drawing/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions in future versions:</p> <ul> <li>Line drawing with thickness</li> <li>Polygon drawing</li> <li>Ellipse support</li> <li>Anti-aliasing options</li> <li>Premultiplied alpha blending</li> <li>Gradient fills</li> <li>Pattern fills</li> <li>Bezier curves</li> <li>Custom pivot points for rotation</li> </ul>"},{"location":"guides/drawing/#see-also","title":"See Also","text":"<ul> <li>Matrix Guide - Working with image matrices</li> <li>Color Conversion Guide - Color space conversions</li> <li>Transform Guide - Image transformations</li> <li>API Documentation - Full API reference</li> </ul>"},{"location":"guides/image-writing/","title":"Image Writing Functionality","text":"<p>This document describes the image writing capabilities added to cv-rusty, allowing you to save <code>Matrix3</code> objects as JPEG or PNG files.</p>"},{"location":"guides/image-writing/#overview","title":"Overview","text":"<p>The library now supports writing RGB image data from <code>Matrix3</code> objects to disk in two popular formats: - JPEG - Lossy compression with adjustable quality - PNG - Lossless compression</p>"},{"location":"guides/image-writing/#api-reference","title":"API Reference","text":""},{"location":"guides/image-writing/#writing-jpeg-images","title":"Writing JPEG Images","text":"<pre><code>pub fn write_jpeg&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n    quality: u8,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the JPEG should be saved - <code>quality</code>: Compression quality (1-100)   - <code>1</code>: Lowest quality, smallest file size   - <code>100</code>: Highest quality, largest file size   - <code>90</code>: Recommended for most use cases   - Values outside 1-100 are automatically clamped</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_jpeg};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write high-quality JPEG\nwrite_jpeg(&amp;image, \"output.jpg\", 95)?;\n\n// Write smaller file with lower quality\nwrite_jpeg(&amp;image, \"compressed.jpg\", 60)?;\n</code></pre></p>"},{"location":"guides/image-writing/#writing-png-images","title":"Writing PNG Images","text":"<pre><code>pub fn write_png&lt;P: AsRef&lt;Path&gt;&gt;(\n    matrix: &amp;Matrix3,\n    path: P,\n) -&gt; Result&lt;(), ImageError&gt;\n</code></pre> <p>Parameters: - <code>matrix</code>: Reference to a <code>Matrix3</code> containing RGB data - <code>path</code>: File path where the PNG should be saved</p> <p>Example: <pre><code>use cv_rusty::{Matrix3, write_png};\n\nlet image = Matrix3::zeros(640, 480);\n// ... populate image data ...\n\n// Write lossless PNG\nwrite_png(&amp;image, \"output.png\")?;\n</code></pre></p>"},{"location":"guides/image-writing/#format-comparison","title":"Format Comparison","text":""},{"location":"guides/image-writing/#jpeg","title":"JPEG","text":"<p>Pros: - Smaller file sizes - Adjustable quality/size tradeoff - Widely supported - Good for photographs</p> <p>Cons: - Lossy compression (data loss) - Not suitable for text or sharp edges - No transparency support</p> <p>Typical file sizes (640\u00d7480 image): - Quality 95: ~35 KB - Quality 75: ~11 KB - Quality 50: ~6 KB</p>"},{"location":"guides/image-writing/#png","title":"PNG","text":"<p>Pros: - Lossless compression (no data loss) - Perfect for graphics with sharp edges - Supports transparency (though cv-rusty uses RGB without alpha) - Good for iterative editing</p> <p>Cons: - Larger file sizes than JPEG - Less efficient for photographs</p> <p>Typical file sizes (640\u00d7480 image): - RGB gradient: ~240 KB</p>"},{"location":"guides/image-writing/#complete-workflow-example","title":"Complete Workflow Example","text":"<pre><code>use cv_rusty::{read_jpeg, write_jpeg, write_png, Matrix3};\n\nfn process_and_save() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Read an image\n    let mut image = read_jpeg(\"input.jpg\")?;\n\n    // Process the image (example: invert colors)\n    for y in 0..image.height() {\n        for x in 0..image.width() {\n            if let Some((r, g, b)) = image.get_pixel(x, y) {\n                image.set_pixel(x, y, 255 - r, 255 - g, 255 - b);\n            }\n        }\n    }\n\n    // Save in multiple formats\n    write_jpeg(&amp;image, \"output_high_quality.jpg\", 95)?;\n    write_jpeg(&amp;image, \"output_web_quality.jpg\", 80)?;\n    write_png(&amp;image, \"output_lossless.png\")?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/image-writing/#error-handling","title":"Error Handling","text":"<p>Both functions return <code>Result&lt;(), ImageError&gt;</code> which can have the following error types:</p> <ul> <li><code>ImageError::Io</code>: File system errors (permissions, disk space, etc.)</li> <li><code>ImageError::JpegEncode</code>: JPEG encoding errors</li> <li><code>ImageError::PngEncode</code>: PNG encoding errors</li> </ul> <pre><code>use cv_rusty::io::{write_jpeg, ImageError};\n\nmatch write_jpeg(&amp;image, \"output.jpg\", 90) {\n    Ok(_) =&gt; println!(\"Image saved successfully\"),\n    Err(ImageError::Io(e)) =&gt; eprintln!(\"I/O error: {}\", e),\n    Err(ImageError::JpegEncode(e)) =&gt; eprintln!(\"Encoding error: {}\", e),\n    Err(e) =&gt; eprintln!(\"Other error: {}\", e),\n}\n</code></pre>"},{"location":"guides/image-writing/#quality-guidelines","title":"Quality Guidelines","text":""},{"location":"guides/image-writing/#jpeg-quality-recommendations","title":"JPEG Quality Recommendations","text":"Quality Use Case File Size Visual Quality 90-100 Archival, printing, professional use Large Excellent 80-89 High-quality web images Medium Very Good 60-79 Standard web images, general use Small Good 40-59 Thumbnails, low-bandwidth scenarios Very Small Acceptable 1-39 Extreme compression Minimal Poor"},{"location":"guides/image-writing/#when-to-use-each-format","title":"When to Use Each Format","text":"<p>Use JPEG when: - Working with photographs - File size is a concern - Minor quality loss is acceptable - Sharing on the web</p> <p>Use PNG when: - Preserving exact pixel values is critical - Working with graphics, text, or line art - Need to perform multiple save operations - File size is not a primary concern</p>"},{"location":"guides/image-writing/#dependencies","title":"Dependencies","text":"<p>The image writing functionality requires the <code>std</code> feature (enabled by default) and uses: - <code>jpeg-encoder</code> (v0.6) for JPEG encoding - <code>png</code> (v0.17) for PNG encoding</p> <p>These dependencies are automatically included when using the default <code>std</code> feature.</p>"},{"location":"guides/image-writing/#examples","title":"Examples","text":"<p>Run the included examples to see the functionality in action:</p> <pre><code># Create gradient images in both formats\ncargo run --example write_image_example\n\n# Convert an existing image to different formats\ncargo run --example image_conversion input.jpg\n\n# View all examples\nls examples/\n</code></pre>"},{"location":"guides/image-writing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>JPEG encoding is generally faster than PNG for photographs</li> <li>PNG encoding time increases with image complexity</li> <li>Both encoders are optimized for single-threaded operation</li> <li>Memory usage is proportional to image size: width \u00d7 height \u00d7 3 bytes for RGB data</li> </ul>"},{"location":"guides/image-writing/#future-enhancements","title":"Future Enhancements","text":"<p>Potential improvements for future versions: - Support for writing grayscale images - PNG transparency (RGBA) support - Progressive JPEG encoding - Configurable PNG compression levels - Batch processing utilities - SIMD-optimized encoding</p>"},{"location":"guides/image-writing/#see-also","title":"See Also","text":"<ul> <li>README.md - General library documentation</li> <li>ARCHITECTURE.md - Library architecture</li> <li>API Documentation - Full API reference</li> </ul>"},{"location":"guides/transform_operations/","title":"Image Transform Operations","text":"<p>This document provides an overview of the image transformation operations added to cv-rusty.</p>"},{"location":"guides/transform_operations/#overview","title":"Overview","text":"<p>The transform module provides three core operations for image manipulation: - Resize: Scale images up or down with different interpolation methods - Crop: Extract rectangular regions from images - Rotate: Rotate images in 90-degree increments (fast, lossless) or by arbitrary angles with interpolation</p> <p>All operations are <code>no_std</code> compatible and work with both <code>Matrix3</code> (RGB) and <code>Matrix1</code> (grayscale) image types.</p>"},{"location":"guides/transform_operations/#resize","title":"Resize","text":"<p>Resize images to specified dimensions with configurable interpolation methods.</p>"},{"location":"guides/transform_operations/#interpolation-methods","title":"Interpolation Methods","text":""},{"location":"guides/transform_operations/#nearest-neighbor-interpolationmethodnearestneighbor","title":"Nearest Neighbor (<code>InterpolationMethod::NearestNeighbor</code>)","text":"<ul> <li>Speed: Fastest</li> <li>Quality: Lowest</li> <li>Best for: Pixel art, icons, when speed is critical</li> <li>Algorithm: Selects the nearest pixel without blending</li> </ul>"},{"location":"guides/transform_operations/#bilinear-interpolationmethodbilinear","title":"Bilinear (<code>InterpolationMethod::Bilinear</code>)","text":"<ul> <li>Speed: Moderate</li> <li>Quality: Good</li> <li>Best for: Most general-purpose resizing, photos</li> <li>Algorithm: Linear interpolation in both directions</li> </ul>"},{"location":"guides/transform_operations/#usage","title":"Usage","text":"<pre><code>use cv_rusty::{Matrix3, InterpolationMethod};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Downscale with bilinear interpolation\nlet thumbnail = image.resize(320, 240, InterpolationMethod::Bilinear);\n\n// Upscale with nearest neighbor\nlet enlarged = image.resize(1280, 960, InterpolationMethod::NearestNeighbor);\n</code></pre>"},{"location":"guides/transform_operations/#performance-characteristics","title":"Performance Characteristics","text":"<ul> <li>Nearest Neighbor: O(width \u00d7 height) - very fast</li> <li>Bilinear: O(width \u00d7 height) - slightly slower due to interpolation calculations</li> <li>Memory: Creates a new image buffer, original remains unchanged</li> </ul>"},{"location":"guides/transform_operations/#crop","title":"Crop","text":"<p>Extract a rectangular region from an image.</p>"},{"location":"guides/transform_operations/#parameters","title":"Parameters","text":"<ul> <li><code>x</code>: X-coordinate of top-left corner (0-based)</li> <li><code>y</code>: Y-coordinate of top-left corner (0-based)</li> <li><code>width</code>: Width of the crop region</li> <li><code>height</code>: Height of the crop region</li> </ul>"},{"location":"guides/transform_operations/#usage_1","title":"Usage","text":"<pre><code>use cv_rusty::Matrix3;\n\nlet image = Matrix3::zeros(640, 480);\n\n// Crop a 200x200 region starting at (100, 100)\nlet cropped = image.crop(100, 100, 200, 200).unwrap();\n\n// Center crop\nlet (w, h) = image.dimensions();\nlet crop_size = 300;\nlet x = (w - crop_size) / 2;\nlet y = (h - crop_size) / 2;\nlet center = image.crop(x, y, crop_size, crop_size).unwrap();\n</code></pre>"},{"location":"guides/transform_operations/#error-handling","title":"Error Handling","text":"<p>The <code>crop()</code> method returns <code>Option&lt;Matrix&gt;</code>: - <code>Some(Matrix)</code> if the crop region is valid - <code>None</code> if the region extends beyond image boundaries</p> <pre><code>match image.crop(x, y, width, height) {\n    Some(cropped) =&gt; println!(\"Crop successful\"),\n    None =&gt; println!(\"Invalid crop region\"),\n}\n</code></pre>"},{"location":"guides/transform_operations/#performance-characteristics_1","title":"Performance Characteristics","text":"<ul> <li>Time Complexity: O(width \u00d7 height) - linear copy operation</li> <li>Memory: Efficiently copies only the required region</li> <li>Optimization: Uses <code>copy_from_slice</code> for row-wise copying</li> </ul>"},{"location":"guides/transform_operations/#rotate","title":"Rotate","text":"<p>Rotate images using two methods: 1. Fixed angles (90\u00b0, 180\u00b0, 270\u00b0) - Fast, lossless transformation 2. Arbitrary angles - Custom rotation with interpolation</p>"},{"location":"guides/transform_operations/#fixed-angle-rotation-fast-lossless","title":"Fixed Angle Rotation (Fast, Lossless)","text":""},{"location":"guides/transform_operations/#rotation-angles","title":"Rotation Angles","text":"<ul> <li><code>RotationAngle::Rotate90</code>: 90 degrees clockwise</li> <li><code>RotationAngle::Rotate180</code>: 180 degrees</li> <li><code>RotationAngle::Rotate270</code>: 270 degrees clockwise (90 degrees counter-clockwise)</li> </ul>"},{"location":"guides/transform_operations/#usage_2","title":"Usage","text":"<pre><code>use cv_rusty::{Matrix3, RotationAngle};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Rotate 90 degrees clockwise (output: 480\u00d7640)\nlet rotated = image.rotate(RotationAngle::Rotate90);\n\n// Rotate 180 degrees (output: 640\u00d7480)\nlet flipped = image.rotate(RotationAngle::Rotate180);\n\n// Rotate 270 degrees clockwise (output: 480\u00d7640)\nlet rotated_ccw = image.rotate(RotationAngle::Rotate270);\n</code></pre>"},{"location":"guides/transform_operations/#dimension-changes","title":"Dimension Changes","text":"Original Size Rotation Result Size 640\u00d7480 90\u00b0 480\u00d7640 640\u00d7480 180\u00b0 640\u00d7480 640\u00d7480 270\u00b0 480\u00d7640"},{"location":"guides/transform_operations/#performance-characteristics_2","title":"Performance Characteristics","text":"<ul> <li>Time Complexity: O(width \u00d7 height) - single pass pixel remapping</li> <li>Quality: Lossless - no interpolation needed</li> <li>Memory: Creates a new image buffer with transposed dimensions for 90\u00b0/270\u00b0 rotations</li> </ul>"},{"location":"guides/transform_operations/#custom-angle-rotation-arbitrary-angles","title":"Custom Angle Rotation (Arbitrary Angles)","text":"<p>Rotate images by any angle (not just 90-degree increments) using interpolation.</p>"},{"location":"guides/transform_operations/#rotation-units","title":"Rotation Units","text":"<p>The <code>Rotation</code> enum supports both degrees and radians:</p> <ul> <li><code>Rotation::Degrees(angle)</code>: Specify rotation in degrees</li> <li><code>Rotation::Radians(angle)</code>: Specify rotation in radians</li> </ul> <p>Positive values rotate clockwise, negative values rotate counter-clockwise.</p>"},{"location":"guides/transform_operations/#usage-with-degrees","title":"Usage with Degrees","text":"<pre><code>use cv_rusty::{Matrix3, Rotation, InterpolationMethod};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Rotate 45 degrees clockwise\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(45.0),\n    InterpolationMethod::Bilinear\n);\n\n// Rotate 30 degrees with nearest neighbor (faster)\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(30.0),\n    InterpolationMethod::NearestNeighbor\n);\n\n// Rotate counter-clockwise with negative angle\nlet rotated = image.rotate_custom(\n    Rotation::Degrees(-22.5),\n    InterpolationMethod::Bilinear\n);\n</code></pre>"},{"location":"guides/transform_operations/#usage-with-radians","title":"Usage with Radians","text":"<pre><code>use cv_rusty::{Matrix3, Rotation, InterpolationMethod};\n\nlet image = Matrix3::zeros(640, 480);\n\n// Rotate PI/4 radians (45 degrees)\nlet rotated = image.rotate_custom(\n    Rotation::Radians(std::f32::consts::PI / 4.0),\n    InterpolationMethod::Bilinear\n);\n\n// Rotate PI/6 radians (30 degrees)\nlet rotated = image.rotate_custom(\n    Rotation::Radians(std::f32::consts::PI / 6.0),\n    InterpolationMethod::Bilinear\n);\n\n// Negative radians for counter-clockwise\nlet rotated = image.rotate_custom(\n    Rotation::Radians(-std::f32::consts::PI / 8.0),\n    InterpolationMethod::Bilinear\n);\n</code></pre>"},{"location":"guides/transform_operations/#converting-between-units","title":"Converting Between Units","text":"<pre><code>let deg_45 = Rotation::Degrees(45.0);\nlet radians = deg_45.to_radians();  // Returns 0.785398... (PI/4)\nlet degrees = deg_45.to_degrees();  // Returns 45.0\n\nlet rad_pi4 = Rotation::Radians(std::f32::consts::PI / 4.0);\nlet degrees = rad_pi4.to_degrees(); // Returns 45.0\nlet radians = rad_pi4.to_radians(); // Returns 0.785398...\n</code></pre>"},{"location":"guides/transform_operations/#output-image-size","title":"Output Image Size","text":"<p>Custom rotation automatically calculates the output dimensions to contain the entire rotated image without cropping.</p> <p>Example: Rotating a 100\u00d7100 image by 45\u00b0 - Output size: approximately 141\u00d7141 (to fit diagonal)</p>"},{"location":"guides/transform_operations/#performance-characteristics_3","title":"Performance Characteristics","text":"<ul> <li>Time Complexity: O(width \u00d7 height) - processes all output pixels</li> <li>Quality: Depends on interpolation method</li> <li>Bilinear: Good quality, slight blur</li> <li>Nearest Neighbor: Faster, more pixelated</li> <li>Memory: Creates new image buffer sized to contain full rotated image</li> </ul>"},{"location":"guides/transform_operations/#comparison-fixed-vs-custom-rotation","title":"Comparison: Fixed vs Custom Rotation","text":"Feature Fixed (90\u00b0/180\u00b0/270\u00b0) Custom (Arbitrary) Speed Very Fast Moderate Quality Lossless Depends on interpolation Angles 90\u00b0 increments only Any angle Dimensions Predictable Calculated dynamically Use Case Simple rotations Precise adjustments"},{"location":"guides/transform_operations/#chaining-operations","title":"Chaining Operations","text":"<p>All transform operations return new <code>Matrix</code> objects, allowing for easy chaining:</p> <pre><code>use cv_rusty::{Matrix3, InterpolationMethod, RotationAngle};\n\nlet processed = image\n    .crop(50, 50, 500, 400)     // Crop region\n    .unwrap()\n    .resize(250, 200, InterpolationMethod::Bilinear)  // Resize\n    .rotate(RotationAngle::Rotate90);  // Rotate\n</code></pre>"},{"location":"guides/transform_operations/#recommended-operation-order","title":"Recommended Operation Order","text":"<p>For best results, chain operations in this order:</p> <ol> <li>Crop - Reduce data size first</li> <li>Rotate - Apply lossless transformations</li> <li>Resize - Final scaling (may introduce interpolation artifacts)</li> </ol> <pre><code>// Efficient pipeline\nlet thumbnail = image\n    .crop(100, 100, 400, 300)   // 1. Reduce to region of interest\n    .unwrap()\n    .rotate(RotationAngle::Rotate90)  // 2. Lossless rotation\n    .resize(150, 200, InterpolationMethod::Bilinear);  // 3. Final resize\n</code></pre>"},{"location":"guides/transform_operations/#no_std-compatibility","title":"<code>no_std</code> Compatibility","text":"<p>All transform operations are fully compatible with <code>no_std</code> environments:</p> <pre><code>#![no_std]\nextern crate alloc;\n\nuse cv_rusty::{Matrix3, InterpolationMethod, RotationAngle};\n\n// All operations work in no_std\nlet image = Matrix3::zeros(320, 240);\nlet resized = image.resize(160, 120, InterpolationMethod::Bilinear);\nlet cropped = image.crop(10, 10, 100, 100).unwrap();\nlet rotated = image.rotate(RotationAngle::Rotate90);\n</code></pre>"},{"location":"guides/transform_operations/#memory-considerations-for-embedded-systems","title":"Memory Considerations for Embedded Systems","text":"<p>When working in memory-constrained environments:</p> <pre><code>// Calculate memory requirements before operations\nlet original_size = width * height * 3;  // RGB image\nlet resized_size = new_width * new_height * 3;\nlet total_memory = original_size + resized_size;  // Both exist during operation\n\n// Consider dropping original after transform\nlet resized = {\n    let temp = Matrix3::zeros(640, 480);\n    temp.resize(320, 240, InterpolationMethod::NearestNeighbor)\n    // temp is dropped here, freeing memory\n};\n</code></pre>"},{"location":"guides/transform_operations/#examples","title":"Examples","text":""},{"location":"guides/transform_operations/#create-thumbnails","title":"Create Thumbnails","text":"<pre><code>fn create_thumbnail(image: &amp;Matrix3, max_size: usize) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let scale = max_size as f32 / w.max(h) as f32;\n    let new_w = (w as f32 * scale) as usize;\n    let new_h = (h as f32 * scale) as usize;\n\n    image.resize(new_w, new_h, InterpolationMethod::Bilinear)\n}\n</code></pre>"},{"location":"guides/transform_operations/#center-crop-and-resize","title":"Center Crop and Resize","text":"<pre><code>fn center_crop_resize(image: &amp;Matrix3, size: usize) -&gt; Matrix3 {\n    let (w, h) = image.dimensions();\n    let crop_size = w.min(h);\n    let x = (w - crop_size) / 2;\n    let y = (h - crop_size) / 2;\n\n    image.crop(x, y, crop_size, crop_size)\n        .unwrap()\n        .resize(size, size, InterpolationMethod::Bilinear)\n}\n</code></pre>"},{"location":"guides/transform_operations/#image-tiling","title":"Image Tiling","text":"<pre><code>fn create_tiles(image: &amp;Matrix3, tile_size: usize) -&gt; Vec&lt;Matrix3&gt; {\n    let (w, h) = image.dimensions();\n    let mut tiles = Vec::new();\n\n    for y in (0..h).step_by(tile_size) {\n        for x in (0..w).step_by(tile_size) {\n            let tw = tile_size.min(w - x);\n            let th = tile_size.min(h - y);\n            if let Some(tile) = image.crop(x, y, tw, th) {\n                tiles.push(tile);\n            }\n        }\n    }\n\n    tiles\n}\n</code></pre>"},{"location":"guides/transform_operations/#batch-processing","title":"Batch Processing","text":"<pre><code>fn batch_resize(images: Vec&lt;Matrix3&gt;, width: usize, height: usize) -&gt; Vec&lt;Matrix3&gt; {\n    images.into_iter()\n        .map(|img| img.resize(width, height, InterpolationMethod::Bilinear))\n        .collect()\n}\n</code></pre>"},{"location":"guides/transform_operations/#rotate-and-straighten","title":"Rotate and Straighten","text":"<pre><code>// Rotate image to straighten it based on detected angle\nfn straighten_image(image: &amp;Matrix3, angle_degrees: f32) -&gt; Matrix3 {\n    // Rotate to correct the angle\n    image.rotate_custom(\n        Rotation::Degrees(-angle_degrees),\n        InterpolationMethod::Bilinear\n    )\n}\n\n// Example: straighten a slightly tilted scan\nlet tilted_scan = Matrix3::zeros(640, 480);\nlet straightened = straighten_image(&amp;tilted_scan, 2.3); // Correct 2.3\u00b0 tilt\n</code></pre>"},{"location":"guides/transform_operations/#create-panorama-effect","title":"Create Panorama Effect","text":"<pre><code>// Rotate multiple copies at different angles\nfn create_fan_effect(image: &amp;Matrix3, steps: usize) -&gt; Vec&lt;Matrix3&gt; {\n    let angle_step = 360.0 / steps as f32;\n    (0..steps)\n        .map(|i| {\n            let angle = i as f32 * angle_step;\n            image.rotate_custom(\n                Rotation::Degrees(angle),\n                InterpolationMethod::Bilinear\n            )\n        })\n        .collect()\n}\n</code></pre>"},{"location":"guides/transform_operations/#testing","title":"Testing","text":"<p>The transform module includes comprehensive tests:</p> <pre><code># Run all tests\ncargo test\n\n# Run transform-specific tests\ncargo test transform::\n\n# Run with all features\ncargo test --all-features\n\n# Test no_std compatibility\ncargo build --no-default-features\n</code></pre>"},{"location":"guides/transform_operations/#performance-tips","title":"Performance Tips","text":"<ol> <li>Choose the right interpolation method:</li> <li>Use <code>NearestNeighbor</code> for pixel art or when speed is critical</li> <li> <p>Use <code>Bilinear</code> for photos and general-purpose resizing</p> </li> <li> <p>Crop before resize:</p> </li> <li> <p>Process less data by cropping first</p> </li> <li> <p>Avoid multiple resizes:</p> </li> <li> <p>Calculate target size once and resize directly</p> </li> <li> <p>Use rotation for 90\u00b0 increments:</p> </li> <li> <p>Much faster and lossless compared to arbitrary angle rotation</p> </li> <li> <p>Reuse memory when possible:</p> </li> <li>Drop intermediate results to free memory</li> </ol>"},{"location":"guides/transform_operations/#implementation-details","title":"Implementation Details","text":""},{"location":"guides/transform_operations/#resize-algorithm","title":"Resize Algorithm","text":"<p>Nearest Neighbor: <pre><code>for each output pixel (x, y):\n    src_x = floor(x * width_ratio)\n    src_y = floor(y * height_ratio)\n    output[x, y] = input[src_x, src_y]\n</code></pre></p> <p>Bilinear: <pre><code>for each output pixel (x, y):\n    src_x, src_y = fractional source coordinates\n    x1, y1 = floor(src_x, src_y)\n    x2, y2 = x1+1, y1+1\n    dx, dy = fractional parts\n\n    # Weighted average of 4 nearest pixels\n    value = p11 * (1-dx) * (1-dy) +\n            p21 * dx * (1-dy) +\n            p12 * (1-dx) * dy +\n            p22 * dx * dy\n</code></pre></p>"},{"location":"guides/transform_operations/#crop-algorithm","title":"Crop Algorithm","text":"<p>Direct memory copy of rectangular regions, optimized with <code>copy_from_slice</code> for row-wise copying.</p>"},{"location":"guides/transform_operations/#rotate-algorithm","title":"Rotate Algorithm","text":"<p>Fixed Angle (90\u00b0/180\u00b0/270\u00b0):</p> <p>Pixel remapping based on rotation angle: - 90\u00b0 CW: <code>(x, y) \u2192 (height-1-y, x)</code> - 180\u00b0: <code>(x, y) \u2192 (width-1-x, height-1-y)</code> - 270\u00b0 CW: <code>(x, y) \u2192 (y, width-1-x)</code></p> <p>Custom Angle (Arbitrary):</p> <p>Uses inverse rotation with interpolation:</p> <ol> <li>Calculate output dimensions to fit entire rotated image</li> <li>For each output pixel:</li> <li>Apply inverse rotation transformation</li> <li>Sample source image at calculated position</li> <li>Use interpolation for sub-pixel accuracy</li> </ol> <pre><code>For angle \u03b8 in radians:\ncos_\u03b8 = cos(\u03b8)\nsin_\u03b8 = sin(\u03b8)\n\n# Inverse rotation from output to source coordinates\nsrc_x = (dst_x - center_x) * cos_\u03b8 + (dst_y - center_y) * sin_\u03b8 + center_x\nsrc_y = -(dst_x - center_x) * sin_\u03b8 + (dst_y - center_y) * cos_\u03b8 + center_y\n</code></pre>"},{"location":"guides/transform_operations/#future-enhancements","title":"Future Enhancements","text":"<p>Potential additions to the transform module:</p> <ul> <li> Additional interpolation methods (bicubic, Lanczos)</li> <li> Arbitrary angle rotation (with interpolation)</li> <li> Flip operations (horizontal/vertical)</li> <li> Perspective transforms</li> <li> Affine transformations</li> <li> SIMD optimizations</li> <li> GPU acceleration support</li> </ul>"},{"location":"guides/transform_operations/#api-reference","title":"API Reference","text":"<p>For complete API documentation, run:</p> <pre><code>cargo doc --open\n</code></pre> <p>Then navigate to the <code>transform</code> module documentation.</p>"},{"location":"guides/window_display/","title":"Window Display Module","text":"<p>The window display module provides functionality for displaying images in GUI windows. The <code>show_image()</code> function works with both grayscale and color images through Rust's trait system.</p>"},{"location":"guides/window_display/#features","title":"Features","text":"<ul> <li>Display grayscale images (<code>Matrix1</code>)</li> <li>Display color images (<code>Matrix3</code>)</li> <li>Simple API similar to OpenCV</li> <li>Cross-platform support (Windows, macOS, Linux)</li> <li>Automatic window management</li> </ul>"},{"location":"guides/window_display/#requirements","title":"Requirements","text":"<p>This feature requires the <code>window</code> feature flag to be enabled:</p> <pre><code>[dependencies]\ncv-rusty = { version = \"0.3.0\", features = [\"window\"] }\n</code></pre> <p>Note: The window feature requires GUI support and is not available in headless environments (e.g., CI servers, Docker containers without X11).</p>"},{"location":"guides/window_display/#api-overview","title":"API Overview","text":""},{"location":"guides/window_display/#show_imagewindow_name-image","title":"<code>show_image(window_name, image)</code>","text":"<p>Displays an image in a window. Works with both grayscale (<code>Matrix1</code>) and color (<code>Matrix3</code>) images.</p> <p>Arguments: - <code>window_name: &amp;str</code> - Name of the window - <code>image: &amp;T</code> - Image to display (any type implementing <code>Displayable</code> trait)</p> <p>Returns: <code>Result&lt;(), WindowError&gt;</code></p> <p>Examples: <pre><code>use cv_rusty::{Matrix1, Matrix3, show_image};\n\n// Display a color image\nlet color_image = Matrix3::zeros(640, 480);\nshow_image(\"Color Window\", &amp;color_image)?;\n\n// Display a grayscale image\nlet gray_image = Matrix1::zeros(640, 480);\nshow_image(\"Grayscale Window\", &amp;gray_image)?;\n</code></pre></p>"},{"location":"guides/window_display/#show_and_waitwindow_name-image","title":"<code>show_and_wait(window_name, image)</code>","text":"<p>Displays an image and waits for user to close the window. Works with both color and grayscale images.</p> <p>Arguments: - <code>window_name: &amp;str</code> - Name of the window - <code>image: &amp;T</code> - Image to display (any type implementing <code>Displayable</code> trait)</p> <p>Returns: <code>Result&lt;(), WindowError&gt;</code></p> <p>Examples: <pre><code>use cv_rusty::{Matrix1, Matrix3, show_and_wait};\n\n// Works with color images\nlet color_image = Matrix3::zeros(640, 480);\nshow_and_wait(\"Color Window\", &amp;color_image)?;\n\n// Works with grayscale images\nlet gray_image = Matrix1::zeros(640, 480);\nshow_and_wait(\"Grayscale Window\", &amp;gray_image)?;\n</code></pre></p>"},{"location":"guides/window_display/#wait_keydelay","title":"<code>wait_key(delay)</code>","text":"<p>Waits for a key press for a specified duration (simplified version).</p> <p>Arguments: - <code>delay: u64</code> - The number of milliseconds to wait. Use 0 to wait indefinitely.</p> <p>Example: <pre><code>use cv_rusty::wait_key;\n\nwait_key(1000); // Wait for 1 second\n</code></pre></p> <p>Note: This is a simplified implementation that just sleeps. For more complex event handling with multiple windows, consider using the minifb window handle directly.</p>"},{"location":"guides/window_display/#complete-example","title":"Complete Example","text":"<pre><code>use cv_rusty::{read_jpeg, show_image, Matrix3, Matrix1};\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Load an image from disk\n    let image = read_jpeg(\"input.jpg\")?;\n    println!(\"Loaded {}x{} image\", image.width(), image.height());\n\n    // Display the image\n    show_image(\"Original Image\", &amp;image)?;\n\n    // Create a modified version\n    let mut modified = image.clone();\n    for y in 100..200 {\n        for x in 150..250 {\n            modified.set_pixel(x, y, 255, 0, 0);\n        }\n    }\n\n    // Display the modified image\n    show_image(\"Modified Image\", &amp;modified)?;\n\n    // Convert to grayscale and display\n    let gray = image.to_grayscale(cv_rusty::GrayscaleMethod::Average);\n    show_image(\"Grayscale\", &amp;gray)?;\n\n    Ok(())\n}\n</code></pre>"},{"location":"guides/window_display/#keyboard-controls","title":"Keyboard Controls","text":"<ul> <li>ESC - Close the window</li> <li>Window close button - Close the window</li> </ul>"},{"location":"guides/window_display/#window-behavior","title":"Window Behavior","text":"<p>Each call to <code>show_image</code> creates a new window that: - Opens immediately with the specified image - Runs at a maximum of 60 FPS - Remains open until the user presses ESC or closes the window - Blocks execution until closed</p>"},{"location":"guides/window_display/#error-handling","title":"Error Handling","text":"<p>The window functions return <code>Result&lt;(), WindowError&gt;</code> with the following error types:</p> <ul> <li><code>WindowError::WindowCreation(String)</code> - Failed to create or update the window</li> <li><code>WindowError::InvalidDimensions</code> - Image has zero width or height</li> </ul>"},{"location":"guides/window_display/#error-handling_1","title":"Error Handling","text":"<p>Example: <pre><code>use cv_rusty::{Matrix3, show_image, WindowError};\n\nlet image = Matrix3::zeros(640, 480);\n\nmatch show_image(\"My Window\", &amp;image) {\n    Ok(_) =&gt; println!(\"Image displayed successfully\"),\n    Err(WindowError::InvalidDimensions) =&gt; {\n        eprintln!(\"Image has invalid dimensions\");\n    }\n    Err(WindowError::WindowCreation(msg)) =&gt; {\n        eprintln!(\"Failed to create window: {}\", msg);\n    }\n}\n</code></pre></p>"},{"location":"guides/window_display/#comparison-with-opencv","title":"Comparison with OpenCV","text":"Feature cv-rusty OpenCV Display any image <code>show_image(\"name\", &amp;image)</code> <code>imshow(\"name\", image)</code> Wait for key <code>wait_key(delay)</code> (simplified) <code>waitKey(delay)</code> Close window ESC or close button <code>destroyWindow()</code> or ESC Multiple windows Sequential Concurrent Type system Unified API via traits Single function for all types"},{"location":"guides/window_display/#limitations","title":"Limitations","text":"<ol> <li>Sequential windows: Unlike OpenCV, windows are displayed sequentially. Each <code>show_image</code> call blocks until the window is closed.</li> <li>Simplified wait_key: The <code>wait_key</code> function is a simplified sleep implementation and doesn't return key codes.</li> <li>No window management: Windows cannot be moved, resized programmatically, or destroyed without user interaction.</li> <li>Requires GUI: Cannot be used in headless environments.</li> </ol>"},{"location":"guides/window_display/#advanced-usage","title":"Advanced Usage","text":""},{"location":"guides/window_display/#creating-custom-displayable-types","title":"Creating Custom Displayable Types","text":"<p>You can implement the <code>Displayable</code> trait for your own image types:</p> <pre><code>use cv_rusty::{Displayable, WindowError, show_image};\n\nstruct MyImage {\n    data: Vec&lt;u8&gt;,\n    width: usize,\n    height: usize,\n}\n\nimpl Displayable for MyImage {\n    fn to_display_buffer(&amp;self) -&gt; Result&lt;(Vec&lt;u32&gt;, usize, usize), WindowError&gt; {\n        if self.width == 0 || self.height == 0 {\n            return Err(WindowError::InvalidDimensions);\n        }\n\n        let buffer: Vec&lt;u32&gt; = self.data\n            .iter()\n            .map(|&amp;pixel| {\n                let rgb = pixel as u32;\n                (rgb &lt;&lt; 16) | (rgb &lt;&lt; 8) | rgb\n            })\n            .collect();\n\n        Ok((buffer, self.width, self.height))\n    }\n}\n\n// Now you can use show_image with your custom type\nlet my_image = MyImage { data: vec![128; 640 * 480], width: 640, height: 480 };\nshow_image(\"Custom Image\", &amp;my_image)?;\n</code></pre> <p>For more advanced window control, you can use the underlying <code>minifb</code> crate directly by converting images using the <code>Displayable</code> trait.</p>"},{"location":"guides/window_display/#examples","title":"Examples","text":"<p>See the following examples for more demonstrations:</p> <ul> <li><code>examples/simple_show_image.rs</code> - Basic usage</li> <li><code>examples/window_display_example.rs</code> - Comprehensive examples with gradients and patterns</li> </ul> <p>Run examples with: <pre><code>cargo run --example simple_show_image --features window\ncargo run --example window_display_example --features window\n</code></pre></p>"},{"location":"guides/window_display/#troubleshooting","title":"Troubleshooting","text":""},{"location":"guides/window_display/#this-example-requires-the-window-feature","title":"\"This example requires the 'window' feature\"","text":"<p>Enable the window feature: <code>cargo run --example simple_show_image --features window</code></p>"},{"location":"guides/window_display/#failed-to-create-window","title":"\"Failed to create window\"","text":"<ul> <li>Ensure you have GUI support (not running in headless environment)</li> <li>On Linux, ensure X11 or Wayland is available</li> <li>Check that image dimensions are valid (&gt; 0)</li> </ul>"},{"location":"guides/window_display/#window-doesnt-appear","title":"Window doesn't appear","text":"<ul> <li>Check that the image has valid dimensions</li> <li>Ensure the program isn't terminating immediately after the show_image call</li> <li>Try adding error handling to see if an error is being silently ignored</li> </ul>"},{"location":"guides/window_display/#image-colors-look-wrong","title":"Image colors look wrong","text":"<ul> <li>Ensure your image data is in RGB format (not BGR)</li> </ul>"},{"location":"guides/window_display/#benefits-of-the-unified-api","title":"Benefits of the Unified API","text":"<p>The unified <code>show_image()</code> function provides several advantages:</p> <ol> <li>Single Function: No need to remember separate functions for color vs grayscale</li> <li>Type Safe: The compiler ensures you're passing a displayable image type</li> <li>Extensible: You can implement <code>Displayable</code> for custom image types</li> <li>Clean Code: More concise and easier to read</li> </ol> <p>Before (separate functions): <pre><code>show_image_color(\"Color\", &amp;color_image)?;\nshow_image(\"Grayscale\", &amp;gray_image)?;\n</code></pre></p> <p>After (unified function): <pre><code>show_image(\"Color\", &amp;color_image)?;\nshow_image(\"Grayscale\", &amp;gray_image)?;\n</code></pre> - cv-rusty uses RGB ordering: <code>[R, G, B, R, G, B, ...]</code></p>"}]}